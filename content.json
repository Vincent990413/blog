{"meta":{"title":"阿浪的博客:3","subtitle":"","description":"Volantis 是一个功能丰富、高度模块化的 Hexo 博客主题。得益于其强大的模块化特性，您可以轻松搭建一个极简风格的博客，也可以仿照官网搭建一个多人协作的、包含文档模块的大体量综合型博客。","author":"Volantis Team","url":"https://github.com/Vincent990413/blog","root":"/"},"pages":[{"title":"","date":"2021-11-08T15:38:43.479Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"404.html","permalink":"https://github.com/Vincent990413/blog/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"鸣谢项目和社区贡献者","date":"2021-11-08T15:38:43.577Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"contributors/index.html","permalink":"https://github.com/Vincent990413/blog/contributors/","excerpt":"Volantis 社区的发展离不开团队大佬们的无私奉献和社区小伙伴们的热情互助。每一个心怀梦想、有着独特见解的朋友都可以成为团队的一员。目前 Volantis 社区正处于建设初期，我们缺少各方面的人才，如果您使用主题至少一个月且长期活跃于社区，例如： 解答 issues / discussions 提交有效的建议 官网文档补全/纠错 发现并收录有意思的文章（搭建博客方面）到官网 我们非常欢迎您的加入，请在论坛发帖告诉我们。","text":"Volantis 社区的发展离不开团队大佬们的无私奉献和社区小伙伴们的热情互助。每一个心怀梦想、有着独特见解的朋友都可以成为团队的一员。目前 Volantis 社区正处于建设初期，我们缺少各方面的人才，如果您使用主题至少一个月且长期活跃于社区，例如： 解答 issues / discussions 提交有效的建议 官网文档补全/纠错 发现并收录有意思的文章（搭建博客方面）到官网 我们非常欢迎您的加入，请在论坛发帖告诉我们。 感谢开发者 感谢社区建设者 如何参与社区建设社区建设主要包括 Issues Discussions(论坛) 官网博客收录 官网文档维护 几个方面。 如何维护文档目前 Volantis 4.x 已是已知的 Hexo 主题中文档最全面的，但仍有部分功能缺少明确的文档、部分文档已经过时，如果您发现了遗漏或者错误之处，我们非常希望您能够帮忙完善一下。 Volantis 官网支持 CI ，您可以直接在线编辑源码： 在线编辑文档https://github.com/volantis-x/community/tree/master/source 如何收录博客每位用户在使用或更新主题的时候都需要阅读官网的文档，收录的相关内容能帮助用户更高效地上手，同时也能够提高被收录的文章的曝光率。如果在官网能看到更多的有价值的文章，就会有更多 Volantis 用户或者非 Volantis 用户来访问。 如果您有或者发现了与 Hexo 博客搭建相关的文章，可以转载外链到 Volantis 官网，示例如下： _posts/blogs/2020-05-17-pjax.md1234567891011---title: Volantis 主题部署 Pjaxdate: 2020-05-17updated: 2020-08-07categories: [开发心得]author: inksslink: https://inkss.cn/blog/76993423/description: 本篇文章记录了我对 Volantis 主题做 Pjax 兼容的种种，大抵算是种记录吧~headimg: # 可以设置文章头图backup: https://archive.vn/U36NG # 将页面存档到 archive.tody 网页快照档案馆的存档链接 https://archive.tody--- 如果这篇文章的作者是第一次出现在官网，还需要在 _data/author.yml 文件中添加作者信息，例如： _data/author.yml12345...inkss: name: 枋柚梓 avatar: https://cdn.jsdelivr.net/gh/inkss/common@1.4.2/hexo/img/static/avatar.jpg url: https://inkss.cn 注意事项文章存放在 _posts/blogs/ 目录中，且文件名格式为「年-月-日-文章话题」。鼓励原创文章，摘要部分300字符以内。如果想不出摘要可以不写，不要在摘要里重复一遍文章标题。最好选择一个文章分类，如果现有的分类中没有合适的，可以自己新增。如果有文章头图，请确保图片内最多只有一个单词或短语，图片不清晰或者与文章无关的话不建议使用。不仅限于自己的文章，可以在征得文章作者同意的情况下将其链接收录到官网。 在线编辑文档https://github.com/volantis-x/community/tree/master/source/_posts/blogs"},{"title":"","date":"2021-11-08T15:38:43.579Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"examples/index.html","permalink":"https://github.com/Vincent990413/blog/examples/","excerpt":"示 例 博 客 社区维护团队的博客xaoxuu开发者MHuiG划水Colsrch开发者inkss摸鱼W4J1e打杂volantis-x.js.orgTest Site For Development 使用 Volantis 的博客示例","text":"示 例 博 客 社区维护团队的博客xaoxuu开发者MHuiG划水Colsrch开发者inkss摸鱼W4J1e打杂volantis-x.js.orgTest Site For Development 使用 Volantis 的博客示例 如何添加自己的博客链接 第一步：新建 Issue 按照格式填写并提交 12345678&#123; &quot;title&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, &quot;screenshot&quot;: &quot;&quot;, &quot;url&quot;: &quot;&quot;, &quot;avatar&quot;: &quot;&quot;, &quot;version&quot;: &quot;版本：^4.0&quot;&#125;为了提高图片加载速度，建议优化图片尺寸：打开 压缩图 上传自己的截图，将图片的高度调整到 360px 后下载。将压缩后的图片上传到 去不图床 并使用此图片链接作为截图链接。 第二步：刷新 回来刷新即可生效。 如何更新自己的博客链接 如果是自己创建的 issue ，可以自己修改。 如果是管理员创建的，请自己重新创建一份，然后让管理员删掉旧的。"},{"title":"categories","date":"2021-11-08T15:51:36.000Z","updated":"2021-11-08T15:51:36.841Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/Vincent990413/blog/categories/","excerpt":"","text":""},{"title":"常见问题与反馈渠道","date":"2021-11-08T15:38:43.581Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"faqs/index.html","permalink":"https://github.com/Vincent990413/blog/faqs/","excerpt":"通常来说，一个全新的工程全部使用默认配置是正常没有故障的。如果无法使用或者效果与示例有较大区别，可以使用 Hexo 官方提供的用于单元测试的博客应用本主题查看样式是否正常，对比 _config.yml 文件排查问题。 Hexo 官方的单元测试项目： https://github.com/hexojs/hexo-theme-unit-test 向开发者反馈问题","text":"通常来说，一个全新的工程全部使用默认配置是正常没有故障的。如果无法使用或者效果与示例有较大区别，可以使用 Hexo 官方提供的用于单元测试的博客应用本主题查看样式是否正常，对比 _config.yml 文件排查问题。 Hexo 官方的单元测试项目： https://github.com/hexojs/hexo-theme-unit-test 向开发者反馈问题 如何更新主题使用主题的时候，尽量 fork 主题到自己的 GitHub，然后进行修改并使用。这样做的好处是：当主题进行重要更新的时候可以根据需要拉取合并代码，使自己 DIY 的主题能够通过更新获取 BUG 修复或者新特性。 如果不懂请自行搜索关键词：fork 更新 实用小技巧所有需要写在主题配置文件中的配置都可以写在站点配置文件的 theme_config: 中，在 Hexo 5.0 后，还可以写在 _config.volantis.yml 文件中，详见 Hexo 官方文档：覆盖主题配置https://hexo.io/zh-cn/docs/configuration#%E8%A6%86%E7%9B%96%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE也可以直接查看本站源码中站点配置文件的写法：_config.volantis.yml 无法成功运行本地预览 可能是没有安装依赖，请按照「开始」页面中的步骤进行安装，并安装所需依赖。 如果开启了某些第三方服务，请查看文档中是否要求安装插件。 如果报错信息有 lastIndex，你可以尝试把博客根目录配置文件中找到 highlight，并将 auto_detect 设置为 false。 主题配置修改没有生效请确认文档中要求修改的是博客主目录的配置文件 blog/_config.yml 还是主题的配置文件 blog/_config.volantis.yml。 主题样式修改没有生效如果主题配置文件中开启了 cdn 服务，那么修改本地的样式是不会生效的，需要关闭 cdn 服务。 修改什么都没有生效需要 hexo clean 然后重新 hexo s 如果安装了「相关文章推荐」插件后，每次修改 md 文件后都需要重新 hexo s 关掉 CDN 之后样式错乱 请前往文档「开始」页面，检查是否安装了必要的依赖包。 搜索无法使用 请前往文档「开始」页面，检查是否安装了必要的依赖包。 检查根目录配置文件是否有 search 字段冲突。 如果以上两步都无法找到问题，请下载示例源码进行对比。 搜索结果链接不正确请检查根目录配置文件中的链接是否正确，如： blog/_config.yml12url: https://xaoxuu.comroot: / 教程与指南 Hexo 官方文档 | Valine 官方文档请一定要阅读官方文档！ 可供交流的渠道解决问题 渠道 方式 用途 Issues @volantis-x/hexo-theme-volantis 和开发者沟通的唯一渠道，用于跟进和解决问题 请不要发送邮件开源项目的开发者很反感别人不通过正确的途径如 Issues 而是通过私人邮件询问开源项目问题，所以一般不会回复此类邮件。 交流 渠道 方式 用途 论坛 @volantis-x/discussions 慢，相对正式，方便检索，可以给其他用户参考 QQ群 1146399464 (验证码: vlts-2021) 非正式，即时通讯，易于斗图；不利于给其他用户参考 佛系互动 渠道 方式 用途 评论区 留言 可以测试、灌水、推广自己的博客。"},{"title":"如何正确地更新主题","date":"2021-11-08T15:38:43.585Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"how-to-update/index.html","permalink":"https://github.com/Vincent990413/blog/how-to-update/","excerpt":"","text":"如何正确地更新主题https://github.com/volantis-x/hexo-theme-volantis/issues/459 稳定版本如果您以内容创作为主，推荐使用稳定版本：1npm i hexo-theme-volantis 更新时，把 package.json 中的版本号改为 * 再执行 npm i 就可以了。 如果您需要对主题的源文件进行修改，推荐 fork引用并修改自己 fork 的那份，当主题有更新时，合并到自己的分支。 如果您不 fork 而直接修改主题源码，是没办法获得更新的！Fork 篇&ensp;&emsp;本文以 GitKraken 软件的使用展开，相关链接：GitKraken: Free Git GUI Client - Windows, Mac, Linux &ensp;&emsp;如果您按照主题文章中的 设置子模块 已经克隆了一份主题并添加到自己的博客仓库中，那么本篇文章将极大的帮助到您，如果您还没有如此操作，不妨尝试一番。这里是本文的仓库环境：博客仓库 Hexo-Blog 、主题仓库 volantis 。 一、GitKraken 的简单操作&ensp;&emsp;在 GitKraken 的软件界面中，位于正中间面积最大的区域是仓库的历史提交信息，右边为选中提交记录的详情，左边则放有一些仓库相关的信息，将目光集中到左边的 SUBMODULES 选项栏，如果您已经正常的将 Fork 的主题仓库添加到博客仓库中，您便可以在这里看到。展开 SUBMODULES 选项卡，右键并选择 Open this submodlue 打开子模块： 博客仓库 打开子模块 &ensp;&emsp;如此进入的仓库为您的主题仓库，可以在当前页面中查看到所有提交的历史记录等等。为了避免一些拗口的称呼所带来的不良影响，这里设定如下：将 Fork 的仓库称为 主题仓库 ，将 hexo-theme-volantis 仓库称为 volantis 仓库。 主题仓库 &ensp;&emsp;在图中，当前 Fork 的主题仓库所处的分支为 master-theme ，图中右侧展示的是个人主题仓库的最后一次提交信息。中间区域，较上部分在写有 master 标记的为 volantis 仓库的分支（您可以通过右侧的 Logo 图片进行区别）。显而易见的，当前主题仓库已经落后 Volantis 仓库，下面我们便需要合并代码到自己的主题仓库中。如果您打开后的界面并没有看到 Volantis 的仓库信息，意味着当前没有添加 Volantis 仓库为远端，您可以按照如下操作添加： 添加 Volantis 远端仓库信息 &ensp;&emsp;在左侧面板的 REMOTE 选项卡处，点击加号，进入如下图所示界面，选中 volantis-x/hexo-theme-volantis 后添加即可。 二、GitKraken 的合并操作1. Merge&ensp;&emsp;在 volantis 仓库的 master 分支处右键，选择 Merge volantis/master into xxxx，进行合并操作。至于为什么不选择变基（Rebase），个人认为保留仓库的提交历史比修改历史更好。通常，合并操作会自动完成，但是如若冲突时，会收到如此提醒：Merge Failed ,There are merge conflicts that need tobe resolved. 如它所说存在需要解决的冲突，此时右侧选项卡会展示 Merge conflicted detected 窗口，已解决的和冲突文件会显示在其中。 &ensp;&emsp;点击待解决冲突的窗口，在这个页面中，上半部分为本地和远端的代码，下半部分为合并后的内容。您可以根据实际情况，如回忆修改历史，选择是选中左边本地，还是右边远端，抑或是两边都选择，如果对选择后的结果不满意，您还可以手动修改 Output 窗口中的内容，当一切结束后，点击 Save 结束操作。（原则上您必须选择其中的一方，而不是直接修改 Output 的内容） &ensp;&emsp;有时，可能遇到远端删除了某个文件，收到如下提示：GitKraken was unable to determine whether to keep source/css/_plugins/gitalkstyl, would you like to keep it? GitKraken 不会主动删除您的文件，不过一般情形下无需保留，Delete The File 即可。 &ensp;&emsp;最后，在解决完所有冲突文件后，回到仓库列表界面，点击 Commit and Merge 完成提交。 A. 合并操作 B. 合并冲突检测 C. 选择合适的内容 D. 提交内容 2. Rebase&ensp;&emsp;简言之，Rebase 将你的所有修改（提交）重新放到了公共分支的最后面，当然后果是可能会经常面临是否强制提交，而且不太适合与 Merge 操作共同使用。以下内容摘抄自：Rebase - 廖雪峰的官方网站 多人在同一个分支上协作时，很容易出现冲突。后 Push 的童鞋不得不先 Pull ，在本地合并，然后才能 Push 成功。 总之看上去很乱，有强迫症的童鞋会问：为什么 Git 的提交历史不能是一条干净的直线？其实是可以做到的！Git 有一种称为 Rebase 的操作，有人把它翻译成“变基”。 Rebase 操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 Rebase 操作可以把本地未push的分叉提交历史整理成直线； Rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 三、冲突的产生与避免&ensp;&emsp;冲突一般产生于同一处被不同人修改时，Git 无法自动处理，抛出错误让用户解决。由于主题目前仍处于青少年阶段，更新迭代速度比较快，冲突现象可能会比较明显，下面提供一些思路减少这类情况。 &ensp;&emsp;1.首先是配置文件，根据 Hexo 的规则，所有对配置的修改都可以独立出来，无需直接修改主题仓库下的 config.yml ，这里可以参阅：创建主题配置文件。配置类文件是最不该产生冲突的地方。 &ensp;&emsp;2.样式文件，根据 css 的覆盖规则，使用样式覆盖比直接修改样式来的欢快，例如主题中的光标便是采用的样式覆盖的思路。 四、代码历史维护&ensp;&emsp;您可以对单个文件进行历史查看操作，以此来对比您所做出的个人修改，最大程度上的避免代码丢失。正所谓熟能生巧，多加操作后主题更新将不再是一件麻烦的事情，末尾愿您一路走来，最终回归创建博客的初心，完结撒花 ★,°:.☆(￣▽￣)/$:.°★ 。 历史记录"},{"title":"文章分类","date":"2021-11-08T15:38:43.573Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"blog/categories/index.html","permalink":"https://github.com/Vincent990413/blog/blog/categories/","excerpt":"","text":""},{"title":"所有标签","date":"2021-11-08T15:38:43.575Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"blog/tags/index.html","permalink":"https://github.com/Vincent990413/blog/blog/tags/","excerpt":"","text":""},{"title":"进阶设定","date":"2021-11-08T15:38:43.671Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"v5/advanced-settings/index.html","permalink":"https://github.com/Vincent990413/blog/v5/advanced-settings/","excerpt":"","text":"设置子模块 将主题添加为子模块 开始前需要确认不存在 themes/volantis 文件夹, 如果有, 请自行删除.sshhttps1git submodule add git@github.com:volantis-x/hexo-theme-volantis.git themes/volantis1git submodule add https://github.com/volantis-x/hexo-theme-volantis.git themes/volantis 多人协同默认的作者信息在主题配置文件中设置： blog/themes/volantis/_config.yml12345678910# 文章布局article: ... body: ... meta_library: author: avatar: name: 请设置文章作者 url: / Volantis 支持多个作者在一个站点发布文章，其他作者信息需要写在数据文件中，例如： blog/source/_data/author.yml12345678Jon: name: Jon Snow avatar: https://cn.bing.com/th?id=AMMS_fc8f99fd41ebd737a71c4e13806db9a0&amp;w=110&amp;h=110&amp;c=7&amp;rs=1&amp;qlt=80&amp;pcl=f9f9f9&amp;cdv=1&amp;dpr=2&amp;pid=16.1 url: https://gameofthrones.fandom.com/wiki/Jon_SnowDany: name: Daenerys Targaryen avatar: https://tse1-mm.cn.bing.net/th?id=OIP.Yax4wLzIFbcBVUa_RsKywQHaLH&amp;w=80&amp;h=80&amp;c=8&amp;rs=1&amp;qlt=90&amp;dpr=2&amp;pid=3.1&amp;rm=2 url: https://gameofthrones.fandom.com/wiki/Daenerys_Targaryen 在文章的 front-matter 中新增 author 即可： 1234---title: Jon Snow | Game of Thrones Wiki | Fandomauthor: Jon--- 为网站提速加载速度 减少不必要的 js 插件，例如字数统计、动态背景。 查找并解决拖慢速度的资源，以 Chrome 浏览器为例： 页面中点击右键，选择「检查」。 在右边的窗口中「Network」选项卡，并勾选「Disable cache」。 刷新网页，查看加载速度慢的资源。 加载缓慢的图片，建议使用 CDN。 加载缓慢的可以不用的 js 插件，建议舍弃。 加载缓慢却必须使用的 js 插件，建议下载并自己上传至 jsdelivr。 运行速度 访问具有动态特效背景（如雪花、粒子等）的网站时，手机很快会发烫变卡，笔记本很快会风扇狂转并且浏览器提示建议关闭此页面。如果你希望网站有好的使用体验请尽量不要安装这类插件。 优化 SEORobotsblog/_config.volantis.yml123456789101112seo: # When there are no keywords in the article&#x27;s front-matter, use tags as keywords. use_tags_as_keywords: true # When there is no description in the article&#x27;s front-matter, use excerpt as the description. use_excerpt_as_description: true robots: home_first_page: index,follow home_other_pages: noindex,follow archive: noindex,follow category: noindex,follow tag: noindex,follow # robots can be written in front-matter 在 front-matter 中，可以设置 keywords、description、robots 和 seo_title。其中 seo_title 仅仅用作网页标题，优先级高于 title。 文章内部不要使用 H1 标题。 通过死链检测工具检查并删除无法访问的链接。 安装 SEO 优化插件： hexo-autonofollowhttps://github.com/liuzc/hexo-autonofollow hexo-generator-seo-friendly-sitemaphttps://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap 页面不要堆砌关键词，不要频繁更改路径。 Open Graphblog/_config.volantis.yml1234567# https://ogp.me/# https://hexo.io/zh-cn/docs/helpers#open-graphopen_graph: image: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/android-chrome-192x192.png twitter_card: summary # summary_large_image , summary #twitter_id: #twitter_site: Structured Datablog/_config.volantis.yml123456789101112131415161718# SEO 入门文档: https://developers.google.com/search/docs# https://schema.org.cn/# 结构化数据用于更改搜索结果的显示效果# 目前内置的结构化数据: blogposting, breadcrumblist, organization, person, website# 目前内置的富媒体搜索结果: 路径(面包屑导航), 徽标(Logo), 站点链接搜索框(SearchAction)# https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data# 富媒体搜索结果测试: https://search.google.com/test/rich-resultsstructured_data: enable: true # 以下是覆盖配置, 默认配置见 scripts/helpers/structured-data/lib/config.js data: person: sns: - https://github.com/volantis-x logo: path: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/android-chrome-192x192.png width: 192 height: 192 使用 CDN对于大部分将博客 deploy 到 GitHub 的用户来说，直接加载本地资源速度比较慢，可以使用 jsdelivr 为开源项目提供的 CDN 服务。 开启方法blog/_config.volantis.yml123456789101112# 本地静态文件使用jsdelivr的min版本加速 https://www.jsdelivr.com/features# 默认使用 https://cdn.jsdelivr.net/npm/hexo-theme-volantis@&lt;%- theme.info.theme_version %&gt;/source/js/*.min.js 的CDN压缩版本(min.js)，注意版本号对应关系！！可以通过修改以下配置项覆盖# 开发者注意 cdn.enable 设置为 falsecdn: enable: false prefix: # CDN 前缀，为空使用默认值，链接最后不加 &quot;/&quot;,例如： https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page 填写最后编译生成的源码CDN地址前缀，此路径下应该含有/js与/css目录,该配置默认值是：&quot;https://cdn.jsdelivr.net/npm/hexo-theme-volantis@&quot;+ theme.info.theme_version +&quot;/source&quot; # 以下配置可以覆盖 cdn.prefix,配置项的值可以为空，但是要使用CDN必须依据路径填写配置项的键 set: js: app: #/js/app.js css: style: #/css/style.css # (异步加载样式) 如果你需要对样式进行 DIY，可以只关闭 style 文件的 CDN。 从V5版本开始，首屏样式采用硬编码的方式写在HTML中。首屏样式内含 cover navbar search 的样式，其他样式放入/css/style.css异步加载。 如果你需要对样式进行 DIY，请注意首屏渲染和异步延迟加载的差异。 可以对 style.css 使用 HTTP/2 Server Push，但是此方案并不推荐。我们已经对style.css进行了preload处理，推荐使用对服务器压力成本较小的 CDN 服务。 自定义 CDN如果你把对应的文件上传到自己的 CDN 服务器，可以把对应的链接改为自己的 CDN 链接。 尝试使用 Terser 压缩 ES6安装压缩工具12npm install -g gulpnpm install --save-dev gulp gulp-html-minifier-terser gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-terser gulp 配置文件 gulp 配置文件 blog/gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require(&#x27;gulp&#x27;);var minifycss = require(&#x27;gulp-minify-css&#x27;);var htmlmin = require(&#x27;gulp-html-minifier-terser&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);var terser = require(&#x27;gulp-terser&#x27;);// 压缩css文件const minify_css = () =&gt; ( gulp.src([&#x27;./public/**/*.css&#x27;]) .pipe(minifycss()) .pipe(gulp.dest(&#x27;./public&#x27;)));// 压缩html文件const minify_html = () =&gt; ( gulp.src([&#x27;./public/**/*.html&#x27;,&#x27;!./public/&#123;lib,lib/**&#125;&#x27;]) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;)))// 压缩js文件const minify_js = () =&gt; ( gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;,&#x27;!./public/&#123;lib,lib/**&#125;&#x27;]) .pipe(terser()) .pipe(gulp.dest(&#x27;./public&#x27;)))module.exports = &#123; minify_html: minify_html, minify_css: minify_css, minify_js: minify_js&#125;;gulp.task(&#x27;one&#x27;, gulp.parallel( minify_html, minify_css, minify_js))gulp.task(&#x27;default&#x27;, gulp.series(&#x27;one&#x27;)); 运行压缩1gulp 安装 Service Worker 服务方案一 安装插件安装 hexo-offline-popup 或者 hexo-offline 插件，初次加载速度不变，后期切换页面和刷新网页速度越来越快。 方案二 使用 workbox 自定义配置 step 1. 修改 blog/_config.yml 文件。 blog/_config.yml1234# 全局导入import: script: - &lt;script&gt;&quot;serviceWorker&quot;in navigator&amp;&amp;navigator.serviceWorker.register(&quot;/sw.js&quot;).then(function(n)&#123;n.onupdatefound=function()&#123;var e=n.installing;e.onstatechange=function()&#123;switch(e.state)&#123;case&quot;installed&quot;:navigator.serviceWorker.controller?console.log(&quot;Updated serviceWorker.&quot;):console.log(&quot;serviceWorker Sucess!&quot;);break;case&quot;redundant&quot;:console.log(&quot;The installing service worker became redundant.&quot;)&#125;&#125;&#125;&#125;).catch(function(e)&#123;console.log(&quot;Error during service worker registration:&quot;,e)&#125;); &lt;/script&gt; step 2. 在 blog/source 中创建 sw.js 文件。 blog/source/sw.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139importScripts(&#x27;https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.3/workbox/workbox-sw.js&#x27;);workbox.setConfig(&#123; modulePathPrefix: &#x27;https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.3/workbox/&#x27;&#125;);const &#123; core, precaching, routing, strategies, expiration, cacheableResponse, backgroundSync &#125; = workbox;const &#123; CacheFirst, NetworkFirst, NetworkOnly, StaleWhileRevalidate &#125; = strategies;const &#123; ExpirationPlugin &#125; = expiration;const &#123; CacheableResponsePlugin &#125; = cacheableResponse;const cacheSuffixVersion = &#x27;-000010&#x27;, // 缓存版本号 极端重要，修改静态文件后发布网页一定要修改缓存版本号 maxEntries = 100;self.addEventListener(&#x27;activate&#x27;, (event) =&gt; &#123; event.waitUntil( caches.keys().then((keys) =&gt; &#123; return Promise.all(keys.map((key) =&gt; &#123; if (!key.includes(cacheSuffixVersion)) return caches.delete(key); &#125;)); &#125;) );&#125;);core.setCacheNameDetails(&#123; prefix: &#x27;volantis&#x27;, // 极端重要 自己拟定一个名字 suffix: cacheSuffixVersion&#125;);core.skipWaiting();core.clientsClaim();precaching.cleanupOutdatedCaches();/* * Precache * - Static Assets */precaching.precacheAndRoute( // 极端重要 定义首次缓存的静态文件 如果开启CDN需要修改为CDN链接 [ &#123; url: &#x27;/css/first.css&#x27;, revision: null &#125;, &#123; url: &#x27;/css/style.css&#x27;, revision: null &#125;, &#123; url: &#x27;/js/app.js&#x27;, revision: null &#125;, ],);/* * Cache File From CDN * * Method: CacheFirst * cacheName: static-immutable * cacheTime: 30d */// cdn.jsdelivr.net - cors enabledrouting.registerRoute( /.*cdn\\.jsdelivr\\.net/, new CacheFirst(&#123; cacheName: &#x27;static-immutable&#x27; + cacheSuffixVersion, fetchOptions: &#123; mode: &#x27;cors&#x27;, credentials: &#x27;omit&#x27; &#125;, plugins: [ new ExpirationPlugin(&#123; maxAgeSeconds: 30 * 24 * 60 * 60, purgeOnQuotaError: true &#125;) ] &#125;));// m7.music.126.net - cors enabledrouting.registerRoute( /.*m7\\.music\\.126\\.net/, new CacheFirst(&#123; cacheName: &#x27;static-immutable&#x27; + cacheSuffixVersion, fetchOptions: &#123; mode: &#x27;cors&#x27;, credentials: &#x27;omit&#x27; &#125;, plugins: [ new ExpirationPlugin(&#123; maxAgeSeconds: 30 * 24 * 60 * 60, purgeOnQuotaError: true &#125;) ] &#125;));/* * No Cache * * Method: networkOnly */routing.registerRoute( /.*baidu\\.com.*/, new NetworkOnly());/* * Others img fonts * Method: staleWhileRevalidate */routing.registerRoute( // Cache image fonts files /.*\\.(?:png|jpg|jpeg|svg|gif|webp|ico|eot|ttf|woff|woff2|mp3)/, new StaleWhileRevalidate());/* * Static Assets * Method: staleWhileRevalidate */routing.registerRoute( // Cache CSS files /.*\\.(css|js)/, // Use cache but update in the background ASAP new StaleWhileRevalidate());/* * sw.js - Revalidate every time * staleWhileRevalidate */routing.registerRoute( &#x27;/sw.js&#x27;, // 本文件名 new StaleWhileRevalidate());/* * Default - Serve as it is * networkFirst */routing.setDefaultHandler( new NetworkFirst(&#123; networkTimeoutSeconds: 3 &#125;)); 如果你使用了此方案，修改静态文件后发布网页一定要修改缓存版本号。 安装「相关文章」插件 安装插件 1npm i -S hexo-related-popular-posts 插件的自定义配置方法： hexo-related-popular-postshttps://github.com/tea3/hexo-related-popular-posts 如果您使用了头图，可以在站点配置文件中添加以下设置来让相关文章显示正确的文章头图： blog/_config.yml12popularPosts: eyeCatchImageAttributeName: headimg 注意需要升级到 5.0.1 及以上版本才可以支持自定义头图，详见 #29 分析与统计数据统计PV 和 UV默认支持 不蒜子 的访问统计和 leancloud 统计，在配置文件中设置。 字数和阅读时长 安装以下插件：1npm i --save hexo-wordcount 修改配置文件，将 wordcount 插件打开blog/_config.volantis.yml12345plugins: ... # 文章字数统计、阅读时长，开启需要安装插件: npm i --save hexo-wordcount wordcount: enable: #true 然后修改配置文件，将 wordcount 写入需要显示的 meta 位置：blog/_config.volantis.yml123456789101112# 文章布局article: ... # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [..., wordcount, ...] ... # 文章底部信息 # 从 meta_library 中取 bottom_meta: [..., wordcount, ...] 数据分析百度统计blog/_config.yml1baidu_analytics_key: 百度统计的key Google Analyticsblog/_config.yml1google_analytics_key: Google Analytics Key 腾讯前端性能监控blog/_config.yml1tencent_aegis_id: 上报 id CNZZ 统计请参考 ZYMIN 的这篇教程： Hexo hexo+ejs+material x 添加CNZZ统计代码https://zymin.cn/arcticle/hexo+ejs+material.html 更多进阶玩法详见 @TRHX 的这篇博客： Hexo 博客主题个性化https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 内含卡片半透明、增加卡通人物、自定义鼠标样式、鼠标特效、烟花特效、彩色滚动字体、网站运行时间、动态浏览器标题、雪花飘落特效等多种详细教程。 主题官网 #进阶玩法https://volantis.js.org/categories/进阶玩法/"},{"title":"","date":"2021-11-08T15:38:43.675Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"v5/getting-started/index.html","permalink":"https://github.com/Vincent990413/blog/v5/getting-started/","excerpt":"","text":"&ensp;Volantis5 A Wonderful Theme for Hexo Volantis 是一个功能丰富、高度模块化的 Hexo 博客主题。得益于其强大的模块化特性，您可以轻松搭建一个极简风格的博客，也可以仿照官网搭建一个多人协作的、包含文档模块的大体量综合型博客。 示例博客https://volantis.js.org/examples/ 所有的 Volantis 用户都可以按照格式自行创建 Issue 来将自己的博客添加到官网的示例博客页面中。 准备工作能力条件环境配置条件自建博客需要一定的相关知识，在开始前，请务必确保您会使用 markdown 语法，掌握简单的 git 知识，最最重要的是，遇到困难知道该怎么寻求解决： 翻阅和搜索文档 搜索 issues 中是否有解决办法 新建 issue 并按照要求进行操作，详尽地描述您遇到的问题 如果您没有使用过 Hexo 也不要着急，可以先通读一遍 Hexo 中文文档，要想使用地得心应手，最好参照团队提供的开源项目的源码进行搭建： Demo 源码 ｜ 官网源码如果您从旧版本更新或着其它主题迁移，请确保环境版本不要太低，否则会产生兼容性问题。 1234Hexo: 4.2 ~ 5.xhexo-cli: 3.1 ~ 4.xnode.js: 12.16 ~ latest # 推荐使用 LTS 版npm: 6.13 ~ latest 快速体验如果您已经具备环境配置条件，可以在终端中输入下面这行代码，稍等片刻即可尝鲜体验： 1git clone https://github.com/volantis-x/demo.git &amp;&amp; cd demo &amp;&amp; npm i &amp;&amp; hexo s 下载与安装volantis 5.x 目前正处于 「alpha 阶段」 volantis 4.x 目前正处于 「stable 阶段」 volantis 开发发布周期依次经过: 「alpha 阶段」=&gt;「beta 阶段」=&gt;「rc 阶段」=&gt;「stable 阶段」 rc 阶段的测试版本和 stable 阶段的正式版本 我们统称为 「稳定版本」 , 只有 「稳定版本」 发布到 npm 安装或更新 「稳定版本」 (rc 阶段的测试版本 或 stable 阶段的正式版本) 全新博客安装从其它主题迁移第 1/2 步：修改站点配置文件在 blog/_config.yml 文件中找到并修改：1theme: volantis第 2/2 步：下载主题在终端中输入：1npm i hexo-theme-volantis 如果您是 Mac 用户，可以使用脚本完成全部流程 在博客路径打开终端，下载安装并应用主题：1curl -s https://volantis.js.org/start | bash这行命令将会自动检测并安装所需环境，初始化博客，然后下载安装并应用主题。脚本详细使用方法：#hexo.sh 第 1/3 步：修改站点配置文件在 blog/_config.yml 文件中找到并修改：1theme: volantis第 2/3 步：下载主题如果您已经升级到 Hexo 5.0.2 及以上，可以直接使用 npm 命令安装：1npm i hexo-theme-volantis对于旧版本，需要下载主题源码到 themes/ 文件夹：1git clone https://github.com/volantis-x/hexo-theme-volantis themes/volantis如果您无法访问 GitHub 可以使用国内镜像源：1git clone https://e.coding.net/volantis-x/p/hexo-theme-volantis.git themes/volantis第 3/3 步：检查并安装依赖安装 Hexo 搜索的依赖包：1npm i hexo-generator-search hexo-generator-json-content安装 Stylus 渲染器：1npm i hexo-renderer-stylus alpha 阶段的开发测试版本 和 beta 阶段的测试版本 我们统称为 「小白鼠测试版本」, 「小白鼠测试版本」 仅存在于 Github 仓库的 dev 分支 安装或更新 「小白鼠测试版本」 (alpha 阶段的开发测试版本 或 beta 阶段的测试版本) 第 1/3 步：修改站点配置文件在 blog/_config.yml 文件中找到并修改：1theme: volantis第 2/3 步：将主题仓库添加为子模块 将主题添加为子模块 开始前需要确认不存在 themes/volantis 文件夹, 如果有, 请自行删除.sshhttps1git submodule add git@github.com:volantis-x/hexo-theme-volantis.git themes/volantis1git submodule add https://github.com/volantis-x/hexo-theme-volantis.git themes/volantis 第 3/3 步：将主题仓库切换为 dev 分支在终端中输入：12cd themes/volantisgit checkout dev第 n/n 步：更新主题在终端中输入：1git pull 诚聘小白鼠！！！ 版本更新注意事项使用主题的时候，尽量 fork 主题到自己的 GitHub，然后进行修改并使用。这样做的好处是：当主题进行重要更新的时候可以根据需要拉取合并代码，使自己 DIY 的主题能够通过更新获取 BUG 修复或者新特性。 如果不懂请自行搜索关键词：fork 更新 实用小技巧所有需要写在主题配置文件中的配置都可以写在站点配置文件的 theme_config: 中，在 Hexo 5.0 后，还可以写在 _config.volantis.yml 文件中，详见 Hexo 官方文档：覆盖主题配置https://hexo.io/zh-cn/docs/configuration#%E8%A6%86%E7%9B%96%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE也可以直接查看本站源码中站点配置文件的写法：_config.volantis.yml 请对照 更新日志 进行更新. 如何正确地更新主题/how-to-update/ 许可协议本主题采用 MIT开源许可协议 ，永久无限制免费使用。 MIT开源许可协议被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本。被授权人可根据程式的需要修改授权条款为适当的内容。在软件和软件的所有副本中都必须包含版权声明和许可声明。 配置与使用配置与使用/v5/site-settings/"},{"title":"页面配置","date":"2021-11-08T15:38:43.678Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"v5/page-settings/index.html","permalink":"https://github.com/Vincent990413/blog/v5/page-settings/","excerpt":"","text":"页面布局模板布局模板 取值 含义 page 独立页面 post 文章页面 docs 文档页面 category 分类页面 tag 标签页面 friends 友链页面 list 列表页面 page &amp; post &amp; docs这三种页面相同，但是有以下细微区别： post 文章有 title 时，向下滚动网页，导航栏会向上移出屏幕显出文章标题，而 page 和 docs 不会。 post 文章末尾最多可以显示「参考资料」、「相关文章」、「版权标识」、「打赏」四个模块。 docs 文章末尾最多可以显示「参考资料」一个模块。 除了归档页面是自动生成的，其它独立页面都需要手动创建 md 文件。 归档页面归档页面是自动生成的，并且初始化的时候已经生成，路径如下： blog/_config.yml12# Directoryarchive_dir: archives 关于页面Create file if not exists: source/about/index.md1234567891011---layout: docsseo_title: 关于bottom_meta: falsesidebar: []valine: placeholder: 有什么想对我说的呢？---下面写关于自己的内容 分类页面Create file if not exists: source/categories/index.md12345---layout: categoryindex: truetitle: 所有分类--- 标签页面Create file if not exists: source/tags/index.md12345---layout: tagindex: truetitle: 所有标签--- 列表页面Create file if not exists: source/mylist/index.md12345---layout: listgroup: mylistindex: true--- 结果就是筛选出所有文章中 front-matter 部分含有 group: mylist 的文章。 友链页面创建页面文件Create file if not exists: source/friends/index.md1234567891011---layout: friends # 必须title: 我的朋友们 # 可选，这是友链页的标题---这里写友链上方的内容。&lt;!-- more --&gt;这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。 插入友链数据可以 选择布局方案 或 使用友链标签 选择布局方案在主题配置文件中找到以下内容： 1234pages: # 友链页面配置 friends: layout_scheme: traditional # simple: 简单布局, traditional: 传统布局 目前提供2种布局方案： simple: 简单布局，只有头像和标题。 traditional: 传统布局，是 Volantis 旧版本的风格。 以上2种友链的数据源写在以下路径，如果没有请自行创建： 1blog/source/_data/friends.yml 内容格式为： blog/source/_data/friends.yml123456789101112131415- group: # 分组标题 description: # 分组描述 items: - title: # 名称 avatar: # 头像 url: # 链接 screenshot: # 截图 keywords: # 关键词 description: # 描述 - title: # 名称 avatar: # 头像 url: # 链接 screenshot: # 截图 keywords: # 关键词 description: # 描述 不同的布局方式，会用到一部分的字段，一般来说，title、avatar 和 url 都是必须的。这些数据被转成 HTML 标签插入到友链页面的 &lt;!-- more --&gt; 部分。 Volantis 4.x 新增的网站卡片标签的样式 sites 网站卡片布局 在5.0版本移除 被 sites标签 friends标签 contributors标签 替代 issues 标签在5.0版本移除 被 sites标签 friends标签 contributors标签 替代 使用友链标签使用 友链标签 您可以在任何位置插入友链，支持静态数据和动态数据, 关于如何使用 友链标签 插入友链，详见： volantis 主题文档 #友链标签/v5/tag-plugins/#友链标签 404页面Create file if not exists: source/404.md12345678910111213141516---cover: truerobots: noindex,nofollowsitemap: falseseo_title: 404 Not Foundbottom_meta: falsesidebar: []valine: path: /404.html placeholder: 请留言告诉我您要访问哪个页面找不到了---&#123;% p logo center huge, 404 %&#125;&#123;% p center bold, 很抱歉，您访问的页面不存在 %&#125;&#123;% p center small, 可能是输入地址有误或该地址已被删除 %&#125; front-matterfront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量。更多请见 Hexo 官方文档：#front-matter 字段 含义 值类型 默认值 layout 布局模版 String - title 页面标题 String - seo_title 网页标题 String page.title short_title 页面标题（在group列表中显示） String page.title date 创建时间 Date 文件创建时间 updated 更新日期 Date 文件修改时间 link 外部文章网址 String - music 内部音乐控件 [Object] - robots robots String - keywords 页面关键词 String - description 页面描述、摘要 String - cover 是否显示封面 Bool true top_meta 是否显示文章或页面顶部的meta信息 Bool true bottom_meta 是否显示文章或页面底部的meta信息 Bool true sidebar 页面侧边栏 Bool, Array theme.layout.*.sidebar body 页面主体元素 Array theme.layout.on_page.body thumbnail 缩略图 String false icons 图标 Array [] pin 是否置顶 Bool false headimg 文章头图 url - layout:post 时特有的字段： 字段 含义 值类型 默认值 author 文章作者 [Object] config.author categories 分类 String, Array - tags 标签 String, Array - toc 是否生成目录 Bool true music 字段 是否必须 值类型 server 是 netease, tencent, kugou, xiami, baidu type 是 song, playlist, album, search, artist id 是 song id / playlist id / album id / search keyword 文章置顶在 front-matter 中设置以下值： front-matter1pin: true 文章分类多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类： front-matter123---categories: [分类A, 分类B]--- 或者 front-matter12345---categories: - 分类A - 分类B--- 并列分类 front-matter123categories: - [分类A] - [分类B] 多级+并列分类 front-matter123categories: - [分类A, 分类B] - [分类C, 分类D] 文章摘要在文章中插入 &lt;!-- more --&gt;，前面的部分即为摘要。 某篇文章源码12345678910---title: xxxdate: 2020-02-21---这是摘要&lt;!-- more --&gt;这是正文 注意： &lt;!-- more --&gt; 前后一定要有空行，不然可能导致显示错位。 设置文章作者Volantis 支持多个作者在一个站点发布文章，其他作者信息需要写在数据文件中，例如： blog/source/_data/author.yml12345678Jon: name: Jon Snow avatar: https://cn.bing.com/th?id=AMMS_fc8f99fd41ebd737a71c4e13806db9a0&amp;w=110&amp;h=110&amp;c=7&amp;rs=1&amp;qlt=80&amp;pcl=f9f9f9&amp;cdv=1&amp;dpr=2&amp;pid=16.1 url: https://gameofthrones.fandom.com/wiki/Jon_SnowDany: name: Daenerys Targaryen avatar: https://tse1-mm.cn.bing.net/th?id=OIP.Yax4wLzIFbcBVUa_RsKywQHaLH&amp;w=80&amp;h=80&amp;c=8&amp;rs=1&amp;qlt=90&amp;dpr=2&amp;pid=3.1&amp;rm=2 url: https://gameofthrones.fandom.com/wiki/Daenerys_Targaryen 在文章的 front-matter 中新增 author 即可： front-matter1234---title: Jon Snow | Game of Thrones Wiki | Fandomauthor: Jon--- 引入外部文章利用 link，搭配自定义的文章作者信息，你可以在文章列表中显示外部文章或者网址，例如： blog/source/_data/author.yml1234xaoxuu: name: xaoxuu avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png url: https://xaoxuu.com front-matter12345678910111213---layout: postdate: 2017-07-05title: [转]如何搭建基于Hexo的独立博客categories: [Dev, Hexo]tags: - Hexoauthor: xaoxuulink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/---![](https://img.vim-cn.com/d9/a9af7dc49fc0af8ca3e6dd2450a2f7095a87db.png) 置顶对于任何文章或者页面，设置 pin: true 即可置顶在首页。 front-matter123---pin: true--- 这会导致一个小问题：首页 post 卡片数量多于设定值，如果有强迫症希望每一个分页数量一致，可以安装插件来实现，详见：#421 不归档存放在 _posts 文件夹下的文章一般都会出现在归档页，如果某篇文章不希望出现在归档页面： front-matter123---archive: false--- 页面自定义布局显示迷你音乐播放器标题右边显示迷你音乐播放器，支持的字段有：server、type、id。 front-matter123456---music: server: netease # netease, tencent, kugou, xiami, baidu type: song # song, playlist, album, search, artist id: 16846091 # song id / playlist id / album id / search keyword--- 实际效果见： #contributors 显示 meta 标签文章顶部和底部的日期、分类、更新日期、标签、分享等属于 meta 标签。 front-matter1234---top_meta: falsebottom_meta: false--- 如果一个页面没有 title 则不会显示 top_meta ，像404、关于页面就可以完全隐藏： front-matter12345---seo_title: 关于top_meta: falsebottom_meta: false--- 标题右边显示缩略图front-matter123---thumbnail: https://img.vim-cn.com/17/0c7b02722686d1527a1df807dae0794d995860.png--- 缩略图仅在文章列表和文章页面显示，不会在归档页面显示。 标题右边显示图标front-matter123---icons: [fas fa-fire red, fas fa-star green]--- 图标仅在归档页面中显示，可以用来标注热门文章。 可以通过 red / blue / green / yellow / orange / theme / accent 来设置图标的颜色 是否要显示封面如果某个页面需要封面，可以这样写： front-matter123---cover: true--- 显示侧边栏通过自由设置边栏卡片来删减对应页面的冗余信息，提高有价值的信息在页面中的权重。 如果某个页面不需要侧边栏，可以这样写： front-matter123---sidebar: []--- 某个页面想指定显示某几个侧边栏，就这样写: front-matter123---sidebar: [grid, toc, tags] # 放置任何你想要显示的侧边栏部件--- 关闭评论front-matter123---comments: false--- 页面插件 (page plugins)在 front-matter 中配置页面插件 front-matter123456789101112---plugins: - mathjax - katex - artitalk - bbtalk - hpptalk - fcircle - gitter - indent - snackbar: oldversion--- 说说页面以 Artitalk页面 为例: 创建页面文件Create file if not exists: source/artitalk/index.md123456789---seo_title: 说说comments: falseplugins: - artitalk # - bbtalk # - fcircle # - hpptalk--- 配置Artitalk在主题配置文件中找到以下内容 123456789101112131415161718192021# Artitalk https://artitalk.js.org# 配置过程请参考：https://artitalk.js.org/doc.html# 使用过旧版本的请修改Leancloud shuoshuo class部分列名：https://artitalk.js.org/release.html# 除appID和appKEY外均为选填项artitalk: # Set `plugins: [&quot;artitalk&quot;]` to enable in front-matter # 不支持 Pjax # 配置项按照yml格式继续填写即可 appId: # your appID appKey: # your appKEY # serverURL: #leancloud绑定的api访问域名，使用国际版的话不需要填写 # lang: # 语言设置，zh为汉语，en为英语，es为西班牙语。默认为汉语 # pageSize: #每页说说的显示数量 # shuoPla: #在编辑说说的输入框中的占位符 # avatarPla: #自定义头像url的输入框的占位符 # motion: #加载动画的开关，1为开，0为关，默认为开 # bgImg: #说说输入框背景图片url # color1: #说说背景颜色1&amp;按钮颜色1 # color2: #说说背景颜色2&amp;按钮颜色2 # color3: #说说字体颜色 # cssUrl: #自定义css接口 最后记得屏蔽Artitalk页面的pjax 渲染公式默认是不渲染的，如果文章内有公式，需要在 front-matter 中设置开启。即便开启了，文章列表中也不会进行渲染，请注意不要把公式写在文章开头。 example.md:123456789101112131415161718192021222324252627282930---title: 渲染公式（MathJax）date: 2020-02-23plugins: - mathjax---添加一段描述性文字&lt;!-- more --&gt;$$t+1=2$$$$\\mbox&#123;积累因子&#125;=\\begin&#123;cases&#125;1+ni &amp; \\mbox&#123;单利&#125;\\\\\\\\(1+i)^n &amp; \\mbox&#123;复利&#125;\\end&#123;cases&#125;$$$$\\begin&#123;equation&#125;\\sum_&#123;i=0&#125;^n F_i \\cdot \\phi (H, p_i) - \\sum_&#123;i=1&#125;^n a_i \\cdot ( \\tilde&#123;x_i&#125;, \\tilde&#123;y_i&#125;) + b_i \\cdot ( \\tilde&#123;x_i&#125;^2 , \\tilde&#123;y_i&#125;^2 )\\end&#123;equation&#125;$$$$\\begin&#123;equation&#125;\\beta^*(D) = \\mathop&#123;argmin&#125; \\limits_&#123;\\beta&#125; \\lambda &#123;||\\beta||&#125;^2 + \\sum_&#123;i=1&#125;^n max(0, 1 - y_i f_&#123;\\beta&#125;(x_i))\\end&#123;equation&#125;$$ 查看公式渲染效果 $$t+1=2$$$$\\mbox{积累因子}=\\begin{cases}1+ni &amp; \\mbox{单利}\\\\(1+i)^n &amp; \\mbox{复利}\\end{cases}$$$$\\begin{equation}\\sum_{i=0}^n F_i \\cdot \\phi (H, p_i) - \\sum_{i=1}^n a_i \\cdot ( \\tilde{x_i}, \\tilde{y_i}) + b_i \\cdot ( \\tilde{x_i}^2 , \\tilde{y_i}^2 )\\end{equation}$$$$\\begin{equation}\\beta^*(D) = \\mathop{argmin} \\limits_{\\beta} \\lambda {||\\beta||}^2 + \\sum_{i=1}^n max(0, 1 - y_i f_{\\beta}(x_i))\\end{equation}$$ 如果公式仍无法正确渲染可以阅读 @MicDZ 的这篇文章： 在Material-X上使用KaTeXhttps://www.micdz.cn/article/katex-on-volantis/ 页面 gitter页面配置 front-matter1234---plugins: - gitter--- 配置 gitter在主题配置文件中找到以下内容 123456plugins: .... # Gitter # https://gitter.im gitter: room: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 文章页首行缩进front-matter1234---plugins: - indent--- Snackbar (页面通知)配置数据源数据源写在以下路径，如果没有请自行创建： 1blog/source/_data/notification.yml 内容格式为： blog/source/_data/notification.yml12345678910oldversion: title: 过期的文档 message: 这份文档过于久远，如果您使用的是新版的主题，请查看新版本的文档。 position: bottom # bottom (底部通知), right (右侧通知，会自动消失) theme: warning # default, warning cache: false # 是否记住选项（下次不再弹出） buttons: - title: 查看新版文档 url: /getting-started/ dismiss: false # 点击了是否关闭底部横幅 配置 front-matterfront-matter1234---plugins: - snackbar: oldversion---"},{"title":"站点配置","date":"2021-11-08T15:38:43.680Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"v5/site-settings/index.html","permalink":"https://github.com/Vincent990413/blog/v5/site-settings/","excerpt":"","text":"博客根目录下的 _config.yml 文件通常负责站点相关配置、第三方 npm 插件相关的配置。 网站标题blog/_config.yml12# 网站标题title: my blog 网站图标简单方式完全自定义blog/_config.yml12# 网站图标，更多尺寸等图标请使用import方式批量导入favicon: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.icoblog/_config.yml123456789101112import: meta: - &lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#ffffff&quot;&gt; - &lt;meta name=&quot;msapplication-config&quot; content=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/browserconfig.xml&quot;&gt; - &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; link: - &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/apple-touch-icon.png&quot;&gt; - &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon-32x32.png&quot;&gt; - &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon-16x16.png&quot;&gt; - &lt;link rel=&quot;manifest&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/site.webmanifest&quot;&gt; - &lt;link rel=&quot;mask-icon&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/safari-pinned-tab.svg&quot; color=&quot;#5bbad5&quot;&gt; - &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon.ico&quot;&gt; 多语言设置blog/_config.yml12345language: - zh-CN - en - zh-HK - zh-TW 对应的翻译文件路径： themes/volantis/languages/ 使用 Import 导入外部文件Volantis 用户可以在不修改主题文件的情况下向 head 和 body 中添加各种标签。meta 和 link 对应 head 中的 &lt;meta&gt; 和 &lt;link&gt; 标签。script 可以在 body 末尾导入 js 代码。 blog/_config.yml1234567891011121314import: meta: - &lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#ffffff&quot;&gt; - &lt;meta name=&quot;msapplication-config&quot; content=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/browserconfig.xml&quot;&gt; - &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; link: - &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/apple-touch-icon.png&quot;&gt; - &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon-32x32.png&quot;&gt; - &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon-16x16.png&quot;&gt; - &lt;link rel=&quot;manifest&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/site.webmanifest&quot;&gt; - &lt;link rel=&quot;mask-icon&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/safari-pinned-tab.svg&quot; color=&quot;#5bbad5&quot;&gt; - &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon.ico&quot;&gt; script: - &lt;script&gt;&lt;/script&gt; 更多Hexo 官方文档 #配置https://hexo.io/zh-cn/docs/configuration"},{"title":"开发文档","date":"2021-11-08T15:38:43.673Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"v5/development-api/index.html","permalink":"https://github.com/Vincent990413/blog/v5/development-api/","excerpt":"","text":"&ensp;Volantis5 Development API for Volantis 样式文件说明/source/css/Readme.md 全局变量 volantis我们提供了全局变量 volantis 和一些全局函数等主题开发调用接口。 源码参考：layout/_partial/scripts/global.ejs PjaxPjax 重载区域划分接口我们提供了可以实现Pjax重载区域灵活划分的开发接口。 源码参考：layout/_plugins/pjax/index.ejs &lt;pjax&gt;&lt;/pjax&gt; 标签所有被 &lt;pjax&gt;&lt;/pjax&gt; 标签包裹的所有元素将被pjax重载。 请检查并确保 pjax 标签必须存在于所有页面 否则 pjax error. 12345678&lt;pjax&gt; &lt;!--我是将被pjax重载的内容 begin--&gt; &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt;&lt;/script&gt; &lt;/div&gt; &lt;!--我是将被pjax重载的内容 end--&gt;&lt;/pjax&gt; 使用案例：/layout/_partial/scripts/index.ejs script[data-pjax]所有含有 data-pjax 标记的 script 标签将被pjax重载。 1&lt;script data-pjax&gt;我是将被pjax重载的内容&lt;/script&gt; .pjax-reload script所有在 pjax-reload Class元素内部的 script 标签将被pjax重载。 123456&lt;div class=&quot;pjax-reload&quot;&gt; &lt;div&gt; &lt;div&gt;我不是将被pjax重载的内容&lt;/div&gt; &lt;script&gt;我是将被pjax重载的内容&lt;/script&gt; &lt;/div&gt;&lt;/div&gt; Pjax 回调方法我们提供了灵活的 Pjax 回调方法。 源码参考： layout/_partial/scripts/global.ejs layout/_plugins/pjax/index.ejs 使用案例：layout/_plugins/pjax/animate.ejs 中括号[]里面的内容表示选项是可选的，可以不填。下同，不再赘述。 volantis.pjax.push 在Pjax请求完成后触发。使用 volantis.pjax.push(callBack[,&quot;callBackName&quot;]) 传入pjax:complete回调函数。 callBack是回调函数,必填。 &quot;callBackName&quot; string类型 默认值是回调函数的函数名，选填。 volantis.pjax.send 在Pjax请求开始后触发。使用 volantis.pjax.send(callBack[,&quot;callBackName&quot;]) 传入pjax:send回调函数。 callBack是回调函数,必填。 &quot;callBackName&quot; string类型 默认值是回调函数的函数名，选填。 volantis.pjax.error 在Pjax请求失败后触发。使用 volantis.pjax.error(callBack[,&quot;callBackName&quot;]) 传入pjax:error回调函数。 callBack是回调函数,必填。 &quot;callBackName&quot; string类型 默认值是回调函数的函数名，选填。 暗黑模式我们提供了暗黑模式灵活的开发接口。 源码参考： layout/_partial/scripts/global.ejs layout/_partial/scripts/darkmode.ejs 暗黑模式样式详见：/source/css/Readme.md 当前模式调用 volantis.dark.mode 查看当前模式。返回值为字符串 dark 或者 light。 暗黑模式触发器调用 volantis.dark.toggle() 触发切换亮黑模式。 暗黑模式触发器回调函数调用 volantis.dark.push(callBack[,&quot;callBackName&quot;]) 传入触发器回调函数. 使用案例：layout/_plugins/comments/utterances/script.ejs Message 消息提示我们在 iziToast 的基础上封装了一个简单的消息提示： 源码参考： layout/_plugins/message/script.ejs 12volantis.message(title, message, option, done);volantis.question(title, message, option, success, cancel, done); title：标题（必填），字符串（String） message：内容（必填），字符串（String） option：配置项，对象(Object) done：完成时回调，函数(Function) success：确认时回调，函数(Function) cancel: 取消时回调，函数(Function) option 可选参数： icon, // Fontawesome 图标 time, // 持续时间 position, // 弹出位置 transitionIn, // 弹窗打开动画 transitionOut, // 弹窗关闭动画 messageColor, // 消息颜色 titleColor, // 标题颜色 backgroundColor, // 默认背景色 zindex // 层级 option 配置优先级大于配置文件设置值。 使用范例： 123456789101112131415161718// 同样弹窗volantis.message(&#x27;这里是标题&#x27;, &#x27;这里是弹窗内容&#x27;);// 居中弹窗volantis.message(&#x27;系统提示&#x27;, &#x27;这里是 Volantis 主题站，欢迎访问。&#x27;, &#123; icon: &#x27;fad fa-smile-wink light-blue&#x27;, position: &#x27;topCenter&#x27;, transitionIn:&#x27;bounceInDown&#x27;, transitionOut: &#x27;fadeOutDown&#x27;, time: 10000&#125;);// 询问弹窗volantis.question(&#x27;问卷调查&#x27;, &#x27;你是否喜欢 Volantis 主题&#x27;, &#123;&#125;, () =&gt; &#123; alert(&#x27;谢谢支持&#x27;)&#125;, () =&gt; &#123; console.log(&#x27;再接再厉&#x27;)&#125;); 如果以上两个接口仍然不能满足您的需求，可以参考 iziToast 的内容直接调用 iziToast() 动态加载脚本源码参考： layout/_partial/scripts/global.ejs 12volantis.js(&quot;src&quot;, cb)volantis.css(&quot;src&quot;) src String类型 加载脚本URL cb 可选 可以传入onload回调函数 或者 JSON对象 例如: volantis.js(&quot;src&quot;, ()=&gt;&#123;&#125;) 或 volantis.js(&quot;src&quot;, &#123;defer:true,onload:()=&gt;&#123;&#125;&#125;) 返回 Promise 对象 如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载 1234(async () =&gt; &#123; await volantis.js(&quot;...theme.plugins.aplayer.js.aplayer...&quot;) await volantis.js(&quot;...theme.plugins.aplayer.js.meting...&quot;)&#125;)(); 使用案例：layout/_plugins/aplayer/script.ejs 由于返回的是 Promise 对象，也可以采用以下方式实现加载完成后调用回调函数： 123volantis.js(&quot;https://cdn.jsdelivr.net/npm/jquery&quot;).then(()=&gt;&#123; console.log(&quot;我在脚本加载完成后调用&quot;)&#125;) 按需加载的插件源码参考： layout/_partial/scripts/global.ejs jQuery12345volantis.import.jQuery().then(()=&gt;&#123; // 依赖 jQuery 的代码段 // ..... // .....&#125;) requestAnimationFrame1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。 12345volantis.requestAnimationFrame(() =&gt; &#123; // 包含 DOM 操作的代码段 // ......... // .........&#125;) Layout Helper向目标元素动态注入 HTML 1volantis.layoutHelper(helper, html, opt) helper：Helper id（必填），字符串（String） html：HTML（必填），字符串（String） opt：配置项，对象(Object) opt 可选参数： clean, // 清除 Layout Helper 原有的所有内容, 默认 false pjax, // 支持 pjax, 默认 true helper 可选参数： page-plugins, // 页面插件 Layout, 位于 layout/_partial/article.ejs comments, // 评论 Layout, 位于 layout/_plugins/comments/index.ejs 12// 向 page-plugins 入口动态注入 id 为 artitalk_main 的 div, 不启用 pjax, 不清除 Layout Helper 原有的内容volantis.layoutHelper(&quot;page-plugins&quot;,`&lt;div id=&quot;artitalk_main&quot;&gt;&lt;/div&gt;`, &#123; pjax:false, clean:false &#125;) 滚动事件处理源码参考：layout/_partial/scripts/global.ejs 获取滚动条距离顶部的距离1volantis.scroll.getScrollTop() 获取滚动方向1volantis.scroll.del volantis.scroll.del 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动. 滚动事件回调函数使用 volantis.scroll.push(callBack[,&quot;callBackName&quot;]) 传入滚动事件回调函数, 当页面滚动时触发回调函数。 1234567volantis.scroll.push(()=&gt;&#123; if (volantis.scroll.del &gt; 0) &#123; console.log(&quot;向下滚动&quot;); &#125; else &#123; console.log(&quot;向上滚动&quot;); &#125;&#125;) 使用 volantis.scroll.unengine.push(callBack[,&quot;callBackName&quot;]) 传入非滚动事件回调函数, 当页面没有滚动时触发回调函数。 使用 volantis.scroll.unengine.remove(&quot;callBackName&quot;) 移除名称为 &quot;callBackName&quot; 的非滚动事件回调函数。 触发页面滚动至目标元素位置12// 滚动到目标 Dom 元素 &quot;ele&quot; 位置volantis.scroll.to(ele, option) ele：Dom 元素（必填） option 可选参数： top, // 类型 Float,文档中的纵轴坐标, 默认值 ele.getBoundingClientRect().top + document.documentElement.scrollTop addTop, // 类型 Float,向上面的 top 参数中 添加补偿值. behavior, // 类型 String, 表示滚动行为, 支持参数 smooth (平滑滚动), instant (瞬间滚动) observer, // 类型 Boolean, 是否启用监视器,默认值 false, 监视器用于监视元素是否滚动到指定位置 目前用于处理 toc 部分 lazyload 引起的 cls 导致的定位失败问题. observerDic, // 类型 Float, 监视器监视距离, 默认值 25. 例如: 1volantis.scroll.to(document.getElementById(&quot;locationID&quot;),&#123;addTop: - volantis.dom.header.offsetHeight - 10, behavior: &#x27;instant&#x27;&#125;) 对本地文件使用CDN源码参考： layout/_partial/scripts/_ctrl/cdnCtrl.ejs 12theme.cdn.addJS(&quot;name&quot;,&quot;source&quot;,&quot;force&quot;)theme.cdn.addCSS(&quot;name&quot;,&quot;source&quot;,&quot;force&quot;) 参数都为 String 类型，其中 source 和 force 是可选的。 返回值为 CDN 处理后的链接，并存入theme.cdn.map.js和theme.cdn.map.css中 可以使用theme.cdn.map.js[&quot;name&quot;]再次调用。 &quot;name&quot; 是自定义名称 &quot;source&quot; 是资源路径 &quot;force&quot; 是强制覆盖的资源路径 如果&quot;source&quot;为空，则将&quot;name&quot;赋值给&quot;source&quot;。 例如： 对于文件source/js/plugins/sites.js使用CND链接，使用如下方法生成。 1theme.cdn.addJS(&quot;sites&quot;,&quot;plugins/sites&quot;) 生成的CDN链接可使用 theme.cdn.map.js.sites 回调。 以下用于配置项 cdn.set 覆盖配置,下面是覆盖配置的方法 123456789101112131415cdn: enable: true # 以下配置可以覆盖 cdn.prefix,配置项的值可以为空，但是要使用CDN必须依据路径填写配置项的键 set: js: app: https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page/js/app.js rightMenu: https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page/js/rightMenu.js parallax: https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page/js/parallax.js plugins: contributors: https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page/js/plugins/contributors.js friends: https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page/js/plugins/friends.js sites: https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page/js/plugins/sites.js css: style: https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page/css/style.css message: https://cdn.jsdelivr.net/gh/volantis-x/volantis-x.github.io@gh-page/css/message.css 直接使用cdn配置项，不使用theme.cdn.addJS(&quot;sites&quot;,&quot;plugins/sites&quot;) 也可以生成 theme.cdn.map.js.sites CDN链接回调 Custom Files 自定义文件在不修改主题原始源代码的情况下添加自定义内容 注入点我们提供了一些注入点接口: 123456789101112131415161718let points=&#123; styles:[ &quot;first&quot;, &quot;style&quot;, &quot;dark&quot;, &quot;darkVar&quot;, ], views:[ &quot;head&quot;, &quot;header&quot;, &quot;side&quot;, &quot;topMeta&quot;, &quot;bottomMeta&quot;, &quot;footer&quot;, &quot;postEnd&quot;, &quot;bodyEnd&quot;, ]&#125; 样式注入点 first: 向 theme/source/css/first.styl 文件末尾注入自定义内容, 该文件中包含首屏样式,首屏样式采用硬编码的方式写在HTML中。首屏样式内含 cover navbar search 的样式. style: 向 theme/source/css/style.styl 文件末尾注入自定义内容, 该文件中包含异步延迟加载的样式,除首屏样式,其他样式放入此处异步加载. dark: 向 theme/source/css/_style/_plugins/_dark/dark_plugins.styl 文件末尾注入自定义内容, 该文件中包含异步暗黑模式样式 的 强制覆盖样式. darkVar: 向 theme/source/css/_style/_plugins/_dark/dark_async.styl 调用函数 async_dark() 末尾注入自定义内容, 该文件中包含异步暗黑模式样式 的 暗黑模式 CSS 变量. 布局视图注入点 head: 向 theme/layout/_partial/head.ejs 文件 &lt;head&gt; 标签末尾注入自定义内容. header: 向 theme/layout/_partial/header.ejs 文件 导航栏 .nav-main 末尾注入自定义内容. side: 向 theme/layout/_partial/side.ejs 文件 侧边栏 #l_side 末尾注入自定义内容. topMeta: 向 theme/layout/_partial/meta.ejs 文件 topMetas 末尾注入自定义内容. bottomMeta: 向 theme/layout/_partial/meta.ejs 文件 bottomMetas 末尾注入自定义内容. footer: 向 theme/layout/_partial/footer.ejs 文件 &lt;footer&gt; 标签末尾注入自定义内容. postEnd: 向 theme/layout/_partial/article.ejs 文件 &lt;article&gt; 标签末尾注入自定义内容. bodyEnd: 向 theme/layout/layout.ejs 文件 &lt;body&gt; 标签末尾注入自定义内容. blog/source/_volantis/ 文件夹一般的, 创建 blog/source/_volantis/ 文件夹并在此文件夹下创建与注入点同名同扩展名的文件,用以写入注入点自定义内容. 123456789101112blog/source/_volantis/ ├─ first.styl ├─ style.styl ├─ dark.styl ├─ darkVar.styl ├─ head.ejs ├─ header.ejs ├─ topMeta.ejs ├─ bottomMeta.ejs ├─ postEnd.ejs └─ bodyEnd.ejs 当然,你仍然可以修改主题配置文件将自定义布局或样式放置在特定位置.以下是默认配置,该配置已隐藏. blog/_config.volantis.yml1234567891011custom_files: first: source/_volantis/first.styl style: source/_volantis/style.styl dark: source/_volantis/dark.styl darkVar: source/_volantis/darkVar.styl head: source/_volantis/head.ejs header: source/_volantis/header.ejs topMeta: source/_volantis/topMeta.ejs bottomMeta: source/_volantis/bottomMeta.ejs postEnd: source/_volantis/postEnd.ejs bodyEnd: source/_volantis/bodyEnd.ejs 示例: blog/source/_volantis/darkVar.styl12body --color-site-body: blue !important theme_inject 过滤器使用 Hexo 过滤器 theme_inject ，可以将所需的自定义内容添加到任何注入点。 如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。您可以直接在 blog 文件夹下创建 scripts 文件夹. 123hexo.extend.filter.register(&#x27;theme_inject&#x27;, function(injects) &#123; // ...&#125;); 对于注入布局视图: 123456789// The name of same `injectPoint` suggest be unique. If same, it will override low priority configurations.// `locals` and `options` is the same as partial https://hexo.io/docs/helpers#partial.// `order` defines the order of injection, which by default depends on the priority of injection.hexo.extend.filter.register(&#x27;theme_inject&#x27;, function(injects) &#123; // it will put code from this filePath into injectPoint. injects.[injectPoint].file(name, filePath, [locals, options, order]); // it will put raw string as code into injectPoint. injects.[injectPoint].raw(name, raw, [locals, options, order]);&#125;); 对于注入样式: 1234hexo.extend.filter.register(&#x27;theme_inject&#x27;, function(injects) &#123; // it will put styleFile into injectPoint. injects.[injectPoint].push(styleFile);&#125;); Examples以文件的形式向 theme/css/style.styl 文件末尾注入自定义样式 blog/scripts/example-1.js123hexo.extend.filter.register(&#x27;theme_inject&#x27;, function(injects) &#123; injects.style.push(&#x27;source/_data/mystyle.styl&#x27;);&#125;); 以文本的形式向 &lt;body&gt; 标签末尾注入自定义脚本内容 blog/scripts/example-2.js123hexo.extend.filter.register(&#x27;theme_inject&#x27;, function(injects) &#123; injects.bodyEnd.raw(&#x27;load-custom-js&#x27;, &#x27;&lt;script src=&quot;js-path-or-cdn.js&quot;&gt;&lt;/script&gt;&#x27;);&#125;); 以文件的形式向侧栏注入自定义布局视图内容 blog/scripts/example-3.js123hexo.extend.filter.register(&#x27;theme_inject&#x27;, function(injects) &#123; injects.sidebar.file(&#x27;my-favourite-food&#x27;, &#x27;source/_data/my-favourite-food.ejs&#x27;);&#125;); 插件系统我们还支持 hexo 的插件系统，无需修改核心模块的源代码即可轻松扩展功能。你可以参考 https://hexo.io/docs/plugins.html#Plugin 学习如何创建插件。 请注意，以上是主题开发文档，不是使用文档！"},{"title":"标签插件","date":"2021-11-08T15:38:43.682Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"v5/tag-plugins/index.html","permalink":"https://github.com/Vincent990413/blog/v5/tag-plugins/","excerpt":"","text":"为了兼容老用户，旧的标签插件在重构之前依然沿用旧的格式，即 command + 空格 作为参数分隔符，而部分新增标签插件是 空格 + 英文竖线 + 空格 ，请注意区分。 我们也在探索哪种分隔符既简单又不容易引起冲突，所以可能存在多种格式，具体以对应文档描述为准。 5.0 版本起临时实验使用英文双冒号 ( :: ) 作为分隔符，之前版本的分隔符写法向下兼容 5.0 版本的分隔符最终计划使用 stellar 的分隔符，之前版本的分隔符写法没有兼容计划 text效果源码带 下划线 的文本；带 着重号 的文本；带 波浪线 的文本；带 删除线 的文本 键盘样式的文本：⌘ + D 密码样式的文本：这里没有验证码12345带 &#123;% u 下划线 %&#125; 的文本；带 &#123;% emp 着重号 %&#125; 的文本；带 &#123;% wavy 波浪线 %&#125; 的文本；带 &#123;% del 删除线 %&#125; 的文本键盘样式的文本：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125;密码样式的文本：&#123;% psw 这里没有验证码 %&#125; span语法效果源码参数本插件最后更新于 5.0 版本1&#123;% span 样式参数::文本内容 %&#125;各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。 超大号文字： Volantis A Wonderful Theme for Hexo12345各种颜色的标签，包括：&#123;% span red::红色 %&#125;、&#123;% span yellow::黄色 %&#125;、&#123;% span green::绿色 %&#125;、&#123;% span cyan::青色 %&#125;、&#123;% span blue::蓝色 %&#125;、&#123;% span gray::灰色 %&#125;。超大号文字：&#123;% span center logo large::Volantis %&#125; &#123;% span center small::A Wonderful Theme for Hexo %&#125; 属性 可选值 字体 logo, code 颜色 red, yellow, green, cyan, blue, gray 大小 small, h4, h3, h2, h1, large, huge, ultra 对齐方向 left, center, right p参数效果源码参数本插件最后更新于 5.0 版本1&#123;% p 样式参数::文本内容 %&#125;红色 黄色 绿色 青色 蓝色 灰色 Volantis A Wonderful Theme for Hexo123456789&#123;% p red::红色 %&#125;&#123;% p yellow::黄色 %&#125;&#123;% p green::绿色 %&#125;&#123;% p cyan::青色 %&#125;&#123;% p blue::蓝色 %&#125;&#123;% p gray::灰色 %&#125;&#123;% p center logo large::Volantis %&#125;&#123;% p center small::A Wonderful Theme for Hexo %&#125; 属性 可选值 字体 logo, code 颜色 red, yellow, green, cyan, blue, gray 大小 small, h4, h3, h2, h1, large, huge, ultra 对齐方向 left, center, right noteNoteBlock 是 Blockquote 的增强版，在左边显示图标，并且可以自定颜色。而 Note 是 NoteBlock 的简便写法。 最后更新于 5.0 版本1&#123;% note 样式参数::文本内容 %&#125; 演示效果经典用法可以在配置文件中设置默认样式，为简单的一句话提供最的简便写法。 note quote 适合引用一段话 note info 默认主题色，适合中性的信息 note warning 默认黄色，适合警告性的信息 note error/danger 默认红色，适合危险性的信息 note done/success 默认绿色，适合正确操作的信息 更多图标这些都是默认样式，可以手动加上颜色： note radiation 默认样式 note radiation yellow 可以加上颜色 note bug red 说明还存在的一些故障 note link green 可以放置一些链接 note paperclip blue 放置一些附件链接 note todo 待办事项 note guide clear 可以加上一段向导 note download 可以放置下载链接 note message gray 一段消息 note up 可以说明如何进行更新 note undo light 可以说明如何撤销或者回退 上述示例的源码example:123456789101112131415161718192021222324#### 经典用法&#123;% note::可以在配置文件中设置默认样式，为简单的一句话提供最的简便写法。 %&#125;&#123;% note quote::note quote 适合引用一段话 %&#125;&#123;% note info::note info 默认主题色，适合中性的信息 %&#125;&#123;% note warning::note warning 默认黄色，适合警告性的信息 %&#125;&#123;% note danger::note error/danger 默认红色，适合危险性的信息 %&#125;&#123;% note success::note done/success 默认绿色，适合正确操作的信息 %&#125;#### 更多图标这些都是默认样式，可以手动加上颜色：&#123;% note radiation::note radiation 默认样式 %&#125;&#123;% note radiation yellow::note radiation yellow 可以加上颜色 %&#125;&#123;% note bug red::note bug red 说明还存在的一些故障 %&#125;&#123;% note link green::note link green 可以放置一些链接 %&#125;&#123;% note paperclip blue::note paperclip blue 放置一些附件链接 %&#125;&#123;% note todo::note todo 待办事项 %&#125;&#123;% note guide clear::note guide clear 可以加上一段向导 %&#125;&#123;% note download::note download 可以放置下载链接 %&#125;&#123;% note message gray::note message gray 一段消息 %&#125;&#123;% note up::note up 可以说明如何进行更新 %&#125;&#123;% note undo light::note undo light 可以说明如何撤销或者回退 %&#125; 可以支持的参数样式参数位置可以写图标和颜色，多个样式参数用空格隔开。 图标彩色的1quote, info, warning, done/success, error/danger 灰色的，也可以指定颜色1radiation, bug, idea, link, paperclip, todo, message, guide, download, up, undo 颜色指定颜色1clear, light, gray, red, yellow, green, cyan, blue noteblockNoteBlock 是 Blockquote 的增强版，在左边显示图标，并且可以自定颜色。而 Note 是 NoteBlock 的简便写法。 最后更新于 5.0 版本123&#123;% noteblock 样式参数（可选）::标题（可选） %&#125;文本段落&#123;% endnoteblock %&#125; 演示效果可以在区块中放置一些复杂的结构，支持嵌套。 标题（可选）Windows 10不是為所有人設計,而是為每個人設計嵌套测试： 请坐和放宽，我正在帮你搞定一切... Folding 测试： 点击查看更多 不要说我们没有警告过你我们都有不顺利的时候 上述示例的源码example:1234567891011121314151617&#123;% noteblock::标题（可选） %&#125;Windows 10不是為所有人設計,而是為每個人設計&#123;% noteblock done %&#125;嵌套测试： 请坐和放宽，我正在帮你搞定一切...&#123;% endnoteblock %&#125;&#123;% folding yellow::Folding 测试： 点击查看更多 %&#125;&#123;% note warning::不要说我们没有警告过你 %&#125;&#123;% noteblock bug red %&#125;我们都有不顺利的时候&#123;% endnoteblock %&#125;&#123;% endfolding %&#125;&#123;% endnoteblock %&#125; 可以支持的参数样式参数位置可以写图标和颜色，多个样式参数用空格隔开。 图标彩色的1quote, info, warning, done/success, error/danger 灰色的，也可以指定颜色1radiation, bug, idea, link, paperclip, todo, message, guide, download, up, undo 颜色指定颜色1clear, light, gray, red, yellow, green, cyan, blue checkbox最后更新于 5.0 版本1&#123;% checkbox 样式参数（可选）::文本（支持简单md） %&#125; 演示效果 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 上述示例的源码example:12345678910&#123;% checkbox 纯文本测试 %&#125;&#123;% checkbox checked::支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% checkbox red::支持自定义颜色 %&#125;&#123;% checkbox green checked::绿色 + 默认选中 %&#125;&#123;% checkbox yellow checked::黄色 + 默认选中 %&#125;&#123;% checkbox cyan checked::青色 + 默认选中 %&#125;&#123;% checkbox blue checked::蓝色 + 默认选中 %&#125;&#123;% checkbox plus green checked::增加 %&#125;&#123;% checkbox minus yellow checked::减少 %&#125;&#123;% checkbox times red checked::叉 %&#125; 可以支持的参数颜色1red, yellow, green, cyan, blue 样式1plus, minus, times 选中状态1checked radio最后更新于 5.0 版本1&#123;% checkbox 样式参数（可选）::文本（支持简单md） %&#125; 演示效果 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 上述示例的源码example:1234567&#123;% radio 纯文本测试 %&#125;&#123;% radio checked::支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% radio red::支持自定义颜色 %&#125;&#123;% radio green::绿色 %&#125;&#123;% radio yellow::黄色 %&#125;&#123;% radio cyan::青色 %&#125;&#123;% radio blue::蓝色 %&#125; 可以支持的参数颜色1red, yellow, green, cyan, blue 选中状态1checked timeline最后更新于 3.0 版本123456789101112131415&#123;% timeline 时间线标题（可选） %&#125;&#123;% timenode 时间节点（标题） %&#125;正文内容&#123;% endtimenode %&#125;&#123;% timenode 时间节点（标题） %&#125;正文内容&#123;% endtimenode %&#125;&#123;% endtimeline %&#125; 演示效果 2020-07-24 2.6.6 -&gt; 3.0 如果有 hexo-lazyload-image 插件，需要删除并重新安装最新版本，设置 lazyload.isSPA: true。2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 use_cdn: true 则需要删除。2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。2.x 版本的置顶 top: true 改为了 pin: true，并且同样适用于 layout: page 的页面。如果使用了 hexo-offline 插件，建议卸载，3.0 版本默认开启了 pjax 服务。 2020-05-15 2.6.3 -&gt; 2.6.6 不需要额外处理。 2020-04-20 2.6.2 -&gt; 2.6.3 全局搜索 seotitle 并替换为 seo_title。group 组件的索引规则有变，使用 group 组件的文章内，group: group_name 对应的组件名必须是 group_name。group 组件的列表名优先显示文章的 short_title 其次是 title。 上述示例的源码example:123456789101112131415161718192021222324252627&#123;% timeline %&#125;&#123;% timenode 2020-07-24 [2.6.6 -&gt; 3.0](https://github.com/volantis-x/hexo-theme-volantis/releases) %&#125;1. 如果有 `hexo-lazyload-image` 插件，需要删除并重新安装最新版本，设置 `lazyload.isSPA: true`。2. 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 `use_cdn: true` 则需要删除。3. 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。4. 2.x 版本的置顶 `top: true` 改为了 `pin: true`，并且同样适用于 `layout: page` 的页面。5. 如果使用了 `hexo-offline` 插件，建议卸载，3.0 版本默认开启了 pjax 服务。&#123;% endtimenode %&#125;&#123;% timenode 2020-05-15 [2.6.3 -&gt; 2.6.6](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6) %&#125;不需要额外处理。&#123;% endtimenode %&#125;&#123;% timenode 2020-04-20 [2.6.2 -&gt; 2.6.3](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) %&#125;1. 全局搜索 `seotitle` 并替换为 `seo_title`。2. group 组件的索引规则有变，使用 group 组件的文章内，`group: group_name` 对应的组件名必须是 `group_name`。2. group 组件的列表名优先显示文章的 `short_title` 其次是 `title`。&#123;% endtimenode %&#125;&#123;% endtimeline %&#125; link最后更新于 5.0 版本1&#123;% link 标题::链接::图片链接（可选） %&#125; 演示效果如何参与项目https://volantis.js.org/contributors/ 上述示例的源码example:1&#123;% link 如何参与项目::https://volantis.js.org/contributors/::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png %&#125; button这个页面的标签将会在不久后重构 基础按钮请将您的 Volantis 升级至 2.4 版本以上使用。 语法格式参数列表示例写法示例效果1&#123;% btn 样式参数（可选）::标题::链接::图标（可选） %&#125; 可选的参数可以省略，但是前后顺序不能乱。样式参数 1regular, large, center 图标 第1个或者第2个参数包含 fa- 的那个被识别为图标。example.md:123456789不设置任何参数的 &#123;% btn 按钮:: / %&#125; 适合融入段落中。regular 按钮适合独立于段落之外：&#123;% btn regular::示例博客::https://xaoxuu.com::fas fa-play-circle %&#125;large 按钮更具有强调作用，建议搭配 center 使用：&#123;% btn center large::开始使用::https://volantis.js.org/v3/getting-started/::fas fa-download %&#125;行内按钮 不设置任何参数的 按钮 适合融入段落中。 空心按钮 示例博客 示例博客 示例博客 示例博客 居中： 开始使用 实心按钮 示例博客 示例博客 示例博客 示例博客 居中： 开始使用 富文本按钮请将您的 Volantis 升级至 2.3 版本以上使用。 语法格式参数列表示例写法示例效果1234&#123;% btns 样式参数 %&#125;&#123;% cell 标题::链接::图片或者图标 %&#125;&#123;% cell 标题::链接::图片或者图标 %&#125;&#123;% endbtns %&#125;样式参数位置可以写图片样式、布局方式，多个样式参数用空格隔开。 圆角样式 默认为方形 1rounded, circle 布局方式 默认为自动宽度，适合视野内只有一两个的情况。 参数 含义 wide 宽一点的按钮 fill 填充布局，自动铺满至少一行，多了会换行。 center 居中，按钮之间是固定间距。 around 居中分散 grid2 等宽最多2列，屏幕变窄会适当减少列数。 grid3 等宽最多3列，屏幕变窄会适当减少列数。 grid4 等宽最多4列，屏幕变窄会适当减少列数。 grid5 等宽最多5列，屏幕变窄会适当减少列数。 增加文字样式 可以在容器内增加 &lt;b&gt;标题&lt;/b&gt; 和 &lt;p&gt;描述文字&lt;/p&gt;如果需要显示类似「团队成员」之类的一组含有头像的链接： example.md:1234567&#123;% btns circle grid5 %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% endbtns %&#125; 或者含有图标的按钮： example.md:1234&#123;% btns rounded grid5 %&#125;&#123;% cell 下载源码::/::fas fa-download %&#125;&#123;% cell 查看文档::/::fas fa-book-open %&#125;&#123;% endbtns %&#125; 圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中 example.md:1234567891011121314&#123;% btns circle center grid5 %&#125;&lt;a href=&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;&gt; &lt;i class=&#x27;fab fa-apple&#x27;&gt;&lt;/i&gt; &lt;b&gt;心率管家&lt;/b&gt; &#123;% p red::专业版 %&#125; &lt;img src=&#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png&#x27;&gt;&lt;/a&gt;&lt;a href=&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;&gt; &lt;i class=&#x27;fab fa-apple&#x27;&gt;&lt;/i&gt; &lt;b&gt;心率管家&lt;/b&gt; &#123;% p green::免费版 %&#125; &lt;img src=&#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png&#x27;&gt;&lt;/a&gt;&#123;% endbtns %&#125;如果需要显示类似「团队成员」之类的一组含有头像的链接： xaoxuu xaoxuu xaoxuu xaoxuu xaoxuu 或者含有图标的按钮： 下载源码 查看文档 圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中 心率管家 专业版 心率管家 免费版 ghcard最后更新于 5.0 版本12&#123;% ghcard 用户名::其它参数（可选） %&#125;&#123;% ghcard 用户名/仓库::其它参数（可选） %&#125; 用户信息卡片 上述示例的源码： example:12345| &#123;% ghcard xaoxuu %&#125; | &#123;% ghcard xaoxuu::theme=vue %&#125; || -- | -- || &#123;% ghcard xaoxuu::theme=buefy %&#125; | &#123;% ghcard xaoxuu::theme=solarized-light %&#125; || &#123;% ghcard xaoxuu::theme=onedark %&#125; | &#123;% ghcard xaoxuu::theme=solarized-dark %&#125; || &#123;% ghcard xaoxuu::theme=algolia %&#125; | &#123;% ghcard xaoxuu::theme=calm %&#125; | 仓库信息卡片 上述示例的源码： example:12345| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis::theme=vue %&#125; || -- | -- || &#123;% ghcard volantis-x/hexo-theme-volantis::theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis::theme=solarized-light %&#125; || &#123;% ghcard volantis-x/hexo-theme-volantis::theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis::theme=solarized-dark %&#125; || &#123;% ghcard volantis-x/hexo-theme-volantis::theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis::theme=calm %&#125; | 更多参数选择GitHub 卡片 API 参数https://github-readme-stats.vercel.app site网站卡片可以显示网站截图、logo、标题、描述，使用方法和友链标签一模一样，唯一的区别是数据文件名称为 sites.yml，可以和友链数据混用，通过分组过滤实现不一样的效果。 示例写法1&#123;% sites only:community_team %&#125; sites only:community_team xaoxuu开发者MHuiG划水Colsrch开发者inkss摸鱼W4J1e打杂 dropmenu这个页面的标签将会在不久后重构 下拉菜单请将您的 Volantis 升级至 3.0 版本以上使用。 语法格式示例写法示例效果容器 123&#123;% menu 前缀（可省略）::标题::后缀（可省略） %&#125;菜单内容&#123;% endmenu %&#125; 菜单内容 菜单项 1&#123;% menuitem 文本::链接::图标 %&#125; 分割线 1&#123;% menuitem hr %&#125; 子菜单 123&#123;% submenu 嵌套菜单::图标 %&#125;菜单内容&#123;% endsubmenu %&#125;示例1 12345678910&#123;% menu 下拉菜单 %&#125;&#123;% menuitem 主题源码::https://github.com/volantis-x/hexo-theme-volantis/::fas fa-file-code %&#125;&#123;% menuitem 更新日志::https://github.com/volantis-x/hexo-theme-volantis/releases/::fas fa-clipboard-list %&#125;&#123;% menuitem hr %&#125;&#123;% submenu 有疑问？::fas fa-question-circle %&#125;&#123;% menuitem 看 FAQ::/faqs/ %&#125;&#123;% menuitem 看 本站源码::https://github.com/volantis-x/volantis-docs/ %&#125;&#123;% menuitem 提 Issue::https://github.com/volantis-x/hexo-theme-volantis/issues/ %&#125;&#123;% endsubmenu %&#125;&#123;% endmenu %&#125; 示例2 123&#123;% menu 这个是::下拉菜单 %&#125;（同上）&#123;% endmenu %&#125; 示例3 123&#123;% menu 这个是::下拉菜单::的示例效果。 %&#125;（同上）&#123;% endmenu %&#125;示例1 下拉菜单 主题源码 更新日志 有疑问？ 看 FAQ 看 本站源码 提 Issue 示例2 这个是 下拉菜单 主题源码 更新日志 有疑问？ 看 FAQ 看 本站源码 提 Issue 示例3 这个是 下拉菜单 主题源码 更新日志 有疑问？ 看 FAQ 看 本站源码 提 Issue 的示例效果。 tab此插件移植自 NexT #tabs 最后更新于 2.1 版本12345678&#123;% tabs 页面内不重复的ID %&#125;&lt;!-- tab 栏目1 --&gt;内容&lt;!-- endtab --&gt;&lt;!-- tab 栏目2 --&gt;内容&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 演示效果栏目1栏目2。。。！！！ 上述示例的源码example:123456789101112131415&#123;% tabs tab-id %&#125;&lt;!-- tab 栏目1 --&gt;。。。&lt;!-- endtab --&gt;&lt;!-- tab 栏目2 --&gt;！！！&lt;!-- endtab --&gt;&#123;% endtabs %&#125; folding最后更新于 5.0 版本123&#123;% folding 参数（可选）::标题 %&#125;![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)&#123;% endfolding %&#125; 演示效果 查看图片测试 查看默认打开的折叠框 这是一个默认打开的折叠框。 查看代码测试 12345&#123;% folding green::查看代码测试 %&#125;查看代码测试&#123;% endfolding %&#125; 查看列表测试 hahahehe 查看嵌套测试 查看嵌套测试2 查看嵌套测试3 hahaha 上述示例的源码example:123456789101112131415161718192021222324252627282930313233343536&#123;% folding 查看图片测试 %&#125;![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)&#123;% endfolding %&#125;&#123;% folding cyan open::查看默认打开的折叠框 %&#125;这是一个默认打开的折叠框。&#123;% endfolding %&#125;&#123;% folding green::查看代码测试 %&#125;&#123;% endfolding %&#125;&#123;% folding yellow::查看列表测试 %&#125;- haha- hehe&#123;% endfolding %&#125;&#123;% folding red::查看嵌套测试 %&#125;&#123;% folding blue::查看嵌套测试2 %&#125;&#123;% folding 查看嵌套测试3 %&#125;hahaha &lt;span&gt;&lt;img src=&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27; style=&#x27;height:24px&#x27;&gt;&lt;/span&gt;&#123;% endfolding %&#125;&#123;% endfolding %&#125;&#123;% endfolding %&#125; 可以支持的参数参数位置可以填写颜色和状态，多个参数用空格隔开。 颜色1blue, cyan, green, yellow, red 状态状态填写 open 代表默认打开。 inlineimageInlineimage 标签是一种行内图片标签，可以用来在一段话中间插入表情。 本插件最后更新于 5.0 版本1&#123;% inlineimage 图片链接::height=高度（可选） %&#125; 演示效果这是 一段话。 这又是 一段话。 上述示例的源码example:123这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif::height=40px %&#125; 一段话。 可以支持的参数高度1height=20px imageImage 标签是一种针对单个图片应用场景的标签，支持图片描述文字和指定宽度。 本插件最后更新于 5.0 版本1&#123;% image 链接::width=宽度（可选）::height=高度（可选）::alt=描述（可选）::bg=占位颜色（可选） %&#125; 演示效果添加描述： 每天下课回宿舍的路，没有什么故事。 指定宽度： 指定宽度并添加描述： 每天下课回宿舍的路，没有什么故事。 设置占位背景色： 优化不同宽度浏览的观感 上述示例的源码example:123456789101112131415添加描述：&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg::alt=每天下课回宿舍的路，没有什么故事。 %&#125;指定宽度：&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg::width=400px %&#125;指定宽度并添加描述：&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg::width=400px::alt=每天下课回宿舍的路，没有什么故事。 %&#125;设置占位背景色：&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg::width=400px::bg=#1D0C04::alt=优化不同宽度浏览的观感 %&#125; 可以支持的参数图片宽高度example:1width=300px::height=32px 图片描述example:1alt=图片描述 占位背景色example:1bg=#f2f2f2 galleryGallery 标签是一种针对一组图片应用场景的标签。 本插件最后更新于 5.0 版本1234&#123;% gallery 参数::列数::分组 %&#125;![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/67239FBB-E15D-4F4F-8EE8-0F1C9F3C4E7C.jpeg)&#123;% endgallery %&#125; 演示效果一行一个图片 图片描述 一行多个图片（不换行） 图片描述图片描述图片描述 多行多个图片（每行2～8个图片） 上述示例的源码一行一个图片 example.md:123&#123;% gallery %&#125;![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)&#123;% endgallery %&#125; 一行多个图片（不换行） example.md:12345&#123;% gallery::::one %&#125;![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg)![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/67239FBB-E15D-4F4F-8EE8-0F1C9F3C4E7C.jpeg)![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/00E0F0ED-9F1C-407A-9AA6-545649D919F4.jpeg)&#123;% endgallery %&#125; 多行多个图片（每行2～8个图片） example.md:1234567891011121314151617181920212223242526&#123;% gallery stretch::6::two %&#125;![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/007.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/008.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/009.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/010.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/011.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/013.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/014.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/015.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/017.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/018.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/020.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/021.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/022.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/023.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/024.jpg)&#123;% endgallery %&#125; 可以支持的参数对齐方向1left::center::right 缩放1stretch 列数::后面直接写列数，支持 2 ～ 8 列。设定列数之后就是「多行多图」布局，此时图片默认左对齐。为了避免图片大小不一，建议搭配 stretch 来时图片放大填充。 测试中 设定列数之后 不会产生 累积布局偏移; 没有设定列数 产生了累积布局偏移 分组相同内容的会被归档在一个分组中。 audio本插件最后更新于 2.4 版本1&#123;% audio 音频链接 %&#125; 演示效果Your browser does not support the audio tag. 上述示例的源码example:1&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125; video本插件最后更新于 5.0 版本1&#123;% video 视频链接 %&#125; 演示效果100%宽度 Your browser does not support the video tag. 50%宽度 Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. 25%宽度 Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. 上述示例的源码100%宽度 example.md:1&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125; 50%宽度 example.md:123456&#123;% videos::2 %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% endvideos %&#125; 25%宽度 example.md:12345678910&#123;% videos::4 %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% endvideos %&#125; 可以支持的参数对齐方向1left::center::right 列数::后面直接写列数，支持 1 ～ 4 列。 frame这是一个能够将图片或者视频套入设备框架中的标签，可以用来更优雅地显示截图、录屏。 本插件最后更新于 5.0 版本12&#123;% frame 框架名::img=图片链接::alt=图片描述（可选）::part=top/bottom（可选） %&#125;&#123;% frame 框架名::video=视频链接::part=top/bottom（可选） %&#125; 1&#123;% frame iphone11::img=https://7.dusays.com/2020/09/28/baa33914a34ec.jpg::video=https://7.dusays.com/2020/09/28/39db723f1e200.mp4::part=top %&#125; 在这个示例中同时出现了 img 和 video 那么它就是一个带有封面的视频，在视频加载完成之前会先显示视频封面。 设备框架目前支持的有： 1iphone11 如果您有以下其它设备框架图(svg)，欢迎 PR 兼容。 1android, ipad, macbook, watch 剪裁通过设置 part=top 或者 part=bottom 来显示上半部分或者下半部分，否则将显示完整的框架及其中的图片/视频。 aplayer主题对 APlayer 插件的样式进行了兼容。安装插件： 1npm i -S hexo-tag-aplayer 使用方法： hexo-tag-aplayerhttps://github.com/MoePlayer/hexo-tag-aplayer issuesissues 标签在5.0版本移除 被 sites标签 friends标签 contributors标签 替代 友链标签您可以在任何位置插入友链，支持静态数据和动态数据，静态数据需要写在数据文件中： blog/source/_data/friends.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657volantis_developer: title: description: items: - title: xaoxuu url: https://github.com/xaoxuu avatar: https://avatars.githubusercontent.com/u/16400144?s=60&amp;v=4 - title: MHuiG url: https://github.com/MHuiG avatar: https://avatars.githubusercontent.com/u/38281581?s=60&amp;v=4 - title: inkss url: https://github.com/inkss avatar: https://avatars.githubusercontent.com/u/31947043?s=60&amp;v=4 - title: Colsrch url: https://github.com/Colsrch avatar: https://avatars.githubusercontent.com/u/58458181?s=60&amp;v=4 - title: Drew233 url: https://github.com/Drew233 avatar: https://avatars.githubusercontent.com/u/47592224?s=60&amp;v=4 - title: Linhk1606 url: https://github.com/Linhk1606 avatar: https://avatars.githubusercontent.com/u/50829219?s=60&amp;v=4 - title: W4J1e url: https://github.com/W4J1e avatar: https://avatars.githubusercontent.com/u/74824162?s=60&amp;v=4community_builder: title: description: items: - title: xaoxuu url: https://github.com/xaoxuu avatar: https://avatars.githubusercontent.com/u/16400144?s=60&amp;v=4 - title: MHuiG url: https://github.com/MHuiG avatar: https://avatars.githubusercontent.com/u/38281581?s=60&amp;v=4 - title: Colsrch url: https://github.com/Colsrch avatar: https://avatars.githubusercontent.com/u/58458181?s=60&amp;v=4 - title: penndu url: https://github.com/penndu avatar: https://avatars.githubusercontent.com/u/46226528?s=60&amp;v=4 - title: heson525 url: https://github.com/heson525 avatar: https://avatars.githubusercontent.com/u/32234343?s=60&amp;v=4 - title: W4J1e url: https://github.com/W4J1e avatar: https://avatars.githubusercontent.com/u/74824162?s=60&amp;v=4 - title: luosiwei-cmd url: https://github.com/luosiwei-cmd avatar: https://avatars.githubusercontent.com/u/61175380?s=60&amp;v=4groupGitHub: title: 来自 GitHub 的朋友 description: &#x27;以下友链通过 [GitHub Issue](https://github.com/xaoxuu/friends/issues/) 提交，按 issue 最后更新时间排序：&#x27; api: https://issues-api.vercel.app repo: xaoxuu/friends 标题和描述都支持 md 格式，需要写在引号中。如果指定了 api 和 repo 字段，则从 issues 中取第一个 json 代码块数据作为友链。 写法如下1&#123;% friends %&#125; 数据按组筛选友链支持分组（白名单模式和黑名单模式）显示： 写法如下12345678// 显示 volantis_developer&#123;% friends only:volantis_developer %&#125;// 显示 volantis_developer 和 community_builder&#123;% friends only:volantis_developer,community_builder %&#125;// 除了 community_builder 别的都显示&#123;% friends not:community_builder %&#125; friends only:volantis_developer xaoxuuMHuiGinkssColsrchDrew233Linhk1606W4J1eericcloseheson525CRainyDayFlexistonMicDZzhaohaihaolixiang810WillyChen123ic3evi1pennduPHIKN1GHTzsStrikecode004AcceptedqinxsXuxuGoodTRHXcofmlunhui1994gyl-coderfi6 实现动态友链可以加载来自 issues 的友链数据，除了需要在 _data/friends.yml 中指定 api 和 repo 外，还需要做一下几件事： 从 xaoxuu/issues-api 作为模板克隆或者 fork 仓库，然后提交一个 issue 进行测试，不出意外的话，仓库中已经配置好了 issue 模板，只需要在模板中指定的位置填写信息就可以了。 提交完 issue 一分钟左右，如果仓库中出现了 output 分支提交，可以点击查看一下文件内容是否已经包含了刚刚提交的 issue 中的数据，如果包含，那么再次回到前端页面刷新就可以看到来自 issue 的友链数据了。 关于自建&nbsp;Vercel&nbsp;API 如果您想使用自己的 api，请把您刚创建的仓库导入到 Vercel 项目，详见 小冰博客 的教程。 特别感谢小冰博客通过 Vercel 进行加速的方案，解决了原本直接请求 GitHub API 速度过慢的问题。 只显示动态数据如果您不想创建 friends.yml 来设置任何静态数据，可以在标签中设置 repo 来只显示动态数据： 1&#123;% friends repo:xaoxuu/friends %&#125; 当然，如果您自己部署了 API 接口，可以指定： 1&#123;% friends repo:xaoxuu/friends api:https://issues-api.vercel.app %&#125; 网站卡片标签网站卡片可以显示网站截图、logo、标题、描述，使用方法和友链标签一模一样，唯一的区别是数据文件名称为 sites.yml，可以和友链数据混用，通过分组过滤实现不一样的效果。 示例写法1&#123;% sites only:test_demo %&#125; sites only:test_demo volantis-x.js.orgTest Site For Development md在局部渲染外部md文件。 示例写法1&#123;% md https://cdn.jsdelivr.net/gh/volantis-x/hexo-theme-volantis/README.md %&#125; md (()=>{ volantis.css(\"https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css\"); const contentEl = document.getElementById(\"md-b20b3fb9-d603-7977-b875-5f3b7605616a\"); const loadMarkdown = (url) => { if (!window.fetch) { contentEl.innerHTML = 'Your browser outdated. Please use the latest version of Chrome or Firefox!您的浏览器版本过低，请使用最新版的 Chrome 或 Firefox 浏览器！'; } else { contentEl.innerHTML = 'Loading ... | 加载中。。。'; fetch(url, { method: \"GET\" }) .then((resp) => { return Promise.all([ resp.ok, resp.status, resp.text(), resp.headers, ]); }) .then(([ok, status, data, headers]) => { if (ok) { return { ok, status, data, headers, }; } else { throw new Error(JSON.stringify(json.error)); } }) .then((resp) => { let data = marked(resp.data); contentEl.innerHTML = data; }) .catch((error) => { console.log(error); contentEl.innerHTML = 'There was a problem loading the file!加载文件时出现问题！'; }); }; }; volantis.js(\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\").then(()=>{ loadMarkdown(\"https://cdn.jsdelivr.net/gh/volantis-x/hexo-theme-volantis/README.md?t=\" + new Date().getTime()); })})(); Hexo 通用标签在文章中使用 &lt;!-- more --&gt;，那么 &lt;!-- more --&gt; 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。详见 Hexo 官方文档： Hexo 官方文档 #标签插件https://hexo.io/zh-cn/docs/tag-plugins"},{"title":"主题配置","date":"2021-11-08T15:38:43.685Z","updated":"2021-10-30T08:20:48.000Z","comments":true,"path":"v5/theme-settings/index.html","permalink":"https://github.com/Vincent990413/blog/v5/theme-settings/","excerpt":"","text":"创建主题配置文件主题目录下的 _config.yml 文件通常负责主题相关配置，我们强烈建议您使用代替的主题配置文件以防止自己的配置丢失。那么如何使用代替主题配置文件呢？ 第 1/2 步：创建配置文件 在博客根目录的 _config.yml 文件旁边新建一个文件： _config.volantis.yml ，这个文件中的配置信息优先级高于主题文件夹中的配置文件。 第 2/2 步：覆盖自定义配置 当您需要修改某项内容时，例如导航栏菜单，那么您需要在主题配置文件中找到相关内容，复制进自己创建的配置文件中：blog/_config.volantis.yml12345678910navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: menu: - name: 博客 icon: fas fa-rss url: /小提示使用「npm i hexo-theme-volantis」方式安装的主题，主题配置文件在「blog/node_modules/hexo-theme-volantis/_config.yml」使用传统方式安装的主题，主题配置文件在「blog/themes/volantis/_config.yml」 自定义主题外观最大布局宽度blog/_config.volantis.yml123custom_css: ... max_width: 1080px # Sum of body width and sidebar width 网页所呈现的内容的最大宽度，即 body 和 sidebar 的宽度之和。 抗锯齿blog/_config.volantis.yml123custom_css: ... font_smoothing: true # font-smoothing for webkit 自定义光标样式blog/_config.volantis.yml1234567891011custom_css: ... cursor: enable: true text: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/text.png pointer: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/pointer.png default: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/left_ptr.png not-allowed: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/circle.png zoom-out: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/zoom-out.png zoom-in: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/zoom-in.png grab: https://cdn.jsdelivr.net/gh/inkss/common@master/cursor/openhand.png 导航栏样式您可以设置导航栏的高度以及视觉特效，视觉特效目前可选的有： shadow：卡片阴影。 floatable：当鼠标移动到容器内时，呈现出浮起来的效果。 blur：背景模糊效果（毛玻璃），当浏览器不支持时显示为不透明。 blog/_config.volantis.yml12345custom_css: ... navbar: height: 64px effect: [shadow, blur] # [shadow, floatable, blur] 滚动条样式blog/_config.volantis.yml1234567custom_css: ... scrollbar: size: 4px border: 2px color: &#x27;#2196f3&#x27; hover: &#x27;#ff5722&#x27; 侧边栏样式视觉特效参数同上，值得注意的是：卡片的 floatable 效果和 blur 效果相冲突。 blog/_config.volantis.yml1234custom_css: ... sidebar: effect: [shadow] # [shadow, floatable, blur] 正文区域样式视觉特效参数同上，值得注意的是：卡片的 floatable 效果和 blur 效果相冲突。您可以在 language: true 这里设置代码块显示语言名称。text_align 可以设置 h1/h2/h3/h4/p 的文字对齐方向。 blog/_config.volantis.yml12345678910111213141516custom_css: ... body: effect: [shadow] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true text_align: # left, right, justify, center h1: left h2: left h3: left h4: left p: justify note: # style for default note: &#123;% note text %&#125; icon: &#x27;\\f054&#x27; color: &#x27;&#x27; 布局间距您可以设置几种标题的布局间距 h2/h3/h4、段落间距 line、区块内部的段落间距 inline。 blog/_config.volantis.yml12345678custom_css: ... gap: h2: 48px # Spacing above H2 (only px unit) h3: 32px # Spacing above H3 (only px unit) h4: 16px # Spacing above H4 (only px unit) paragraph: 1rem # Paragraph spacing between paragraphs row: .5rem # Paragraph spacing between other elements 自定义字体您可以自定义正文和代码字体。 blog/_config.volantis.yml123456789101112131415161718192021custom_css: ... fontfamily: logofont: fontfamily: &#x27;&quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;Varela Round&#x27; url: https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;UbuntuMono, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;UbuntuMono&#x27; url: https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal codefont: fontfamily: &#x27;Menlo, Monaco&#x27; name: &#x27;Monaco&#x27; url: https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf weight: normal style: normal 自定义颜色多彩配色方案 blog/_config.volantis.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091color_scheme: # ------------ # 通用颜色 common: # 主题色 theme: &#x27;#44D7B6&#x27; # 链接色 link: &#x27;#2196f3&#x27; # 按钮色 button: &#x27;#44D7B6&#x27; # 鼠标放到交互元素上时的色 hover: &#x27;#ff5722&#x27; # 主题色块内部的文字颜色 inner: &#x27;#fff&#x27; # 选中区域文字的背景颜色 selection: &#x27;alpha(#2196f3, 0.2)&#x27; # ------------ # 亮色主题（默认） light: # 网站背景色 site_bg: &#x27;#f4f4f4&#x27; # 网站背景上的文字 site_inner: &#x27;#fff&#x27; # 网站页脚文字 site_footer: &#x27;#666&#x27; # 卡片背景色 card: &#x27;#fff&#x27; # 卡片上的普通文字 text: &#x27;#444&#x27; # 区块和代码块背景色 block: &#x27;#f6f6f6&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#FFF7EA&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#444&#x27; h2: &#x27;#444&#x27; h3: &#x27;#444&#x27; h4: &#x27;#444&#x27; h5: &#x27;#444&#x27; h6: &#x27;#444&#x27; p: &#x27;#444&#x27; # 列表文字 list: &#x27;#666&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #000, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # ------------ # 暗色主题 dark: # 网站背景色 site_bg: &#x27;#222&#x27; # 网站背景上的文字 site_inner: &#x27;#eee&#x27; # 网站页脚文字 site_footer: &#x27;#aaa&#x27; # 卡片背景色 card: &#x27;#444&#x27; # 卡片上的普通文字 text: &#x27;#eee&#x27; # 区块和代码块背景色 block: &#x27;#3a3a3a&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#343a3c&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#eee&#x27; h2: &#x27;#eee&#x27; h3: &#x27;#ddd&#x27; h4: &#x27;#ddd&#x27; h5: &#x27;#ddd&#x27; h6: &#x27;#ddd&#x27; p: &#x27;#bbb&#x27; # 列表文字 list: &#x27;#aaa&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #fff, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # 夜间图片亮度 brightness: 70% 自定义右键菜单blog/_config.volantis.yml1234567891011121314151617181920212223242526272829303132333435363738394041# 自定义右键菜单rightmenu: enable: true faicon: fa # 公共图标类型 fa fal fas fad # hr: 分割线, music: 音乐控制器 layout: [home, hr, help, examples, contributors, hr, source_docs, source_theme, hr, print, darkmode, music] ### 可选功能项 ### print: # 只有文章页才允许自定义打印 name: 打印页面 icon: fa fa-print defaultStyles: true # 是否使用预制的打印样式 # js: # 自定义 js ，可用于修饰打印样式~， 右键剔除了对 Jquery 的依赖，所以此处你只能使用原生 js # - document.querySelector(&#x27;article#comments&#x27;).remove() # 移除评论 darkmode: # 需开启 plugins.darkmodejs name: 暗黑模式 icon: fa fa-moon customPicUrl: # 右键的图片复制：只有 Chrome 支持，且只支持 PNG 格式的图片。 enable: false # 如果使用了对象存储且开启了自适应 Webp，那么可以提供额外的链接用以替换图片的访问地址 old: #https://static.inkss.cn/img/article/ new: #https://cdn.jsdelivr.net/gh/inkss/inkss-cdn@master/img/article/ ### 自定义菜单 ### help: name: 常见问题 icon: fa fa-question url: https://volantis.js.org/faqs/ examples: name: 示例博客 icon: fa fa-rss url: https://volantis.js.org/examples/ contributors: name: 加入社区 icon: fa fa-fan fa-spin url: https://volantis.js.org/contributors/ source_docs: name: 本站源码 icon: fa fa-code-branch url: https://github.com/volantis-x/volantis-docs/ source_theme: name: 主题源码 icon: fa fa-code-branch url: https://github.com/volantis-x/hexo-theme-volantis/ 设置网站导航栏导航栏配置导航栏分为 logo、menu、search 三个区域设置，其中 logo 区域如果设置了图片，则不能显示图标和标题， menu 区域的设置可以写在一个单独的文件中。 blog/_config.volantis.yml123456789101112131415161718192021222324252627# 注意事项：建议规范全站路径 URL 最后带一个 &quot;/&quot; 例如 &quot;about/&quot;navbar: logo: # choose [img] or [icon + title] img: icon: title: menu: # The following can be written in `blog/source/_data/menu.yml` - name: 博客 icon: fas fa-rss url: / - name: 分类 icon: fas fa-folder-open url: categories/ - name: 标签 icon: fas fa-tags url: tags/ - name: 归档 icon: fas fa-archive url: archives/ - name: 友链 icon: fas fa-link url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: 搜索 # Search bar placeholder 菜单嵌套导航栏菜单支持嵌套，嵌套的属性名为 rows ，写法示例： 123456789101112131415161718192021222324...- name: 更多 icon: fas fa-ellipsis-v rows: - name: 主题源码 url: https://github.com/volantis-x/hexo-theme-volantis/ - name: 更新日志 url: https://github.com/volantis-x/hexo-theme-volantis/releases/ - name: hr - name: 有疑问？ rows: - name: 看 FAQ url: faqs/ - name: 看 本站源码 url: https://github.com/volantis-x/volantis-docs/ - name: 提 Issue url: https://github.com/volantis-x/hexo-theme-volantis/issues/ - name: hr - name: 公告和测试博文 url: archives/ - name: 示例博客 url: examples/ - name: 特别感谢 url: contributors/ 分割线在子菜单中，新增一个只有 name: hr 的“菜单”就会被渲染成一个分割线。 1- name: hr 小标题在子菜单中，新增一个只有 name: 小标题内容（也可以有 icon: 小标题的图标）的“菜单”就会被渲染成一个小标题。 12345678910111213...- name: 近期 icon: fas fa-clock url: / rows: - name: 热门文章 icon: fas fa-fire - name: ProHUD 开源库的设计思路 url: blog/2019-08-27-prohud/ - name: ValueX：实用的安全对象类型转换库 url: blog/2019-08-29-valuex/ - name: 心率管家 App 的设计与开发 url: blog/2019-07-23-heartmate/ 播放器在子菜单中，新增一个 icon: fas fa-compact-disc 的“菜单”就会被渲染成一个 APlayer 播放器。 12- name: 背景音乐 icon: fas fa-compact-disc 设置网站页脚您通过 layout 可以自由布局网站页脚内容 aplayer, social, license, info, copyright。 blog/_config.volantis.yml123456789101112131415site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [aplayer, social, license, info, copyright] social: - icon: fas fa-rss url: atom.xml - icon: fas fa-envelope url: mailto:me@xaoxuu.com - icon: fab fa-github url: https://github.com/xaoxuu - icon: fas fa-headphones-alt url: https://music.163.com/#/user/home?id=63035382 copyright: &#x27;[Copyright © 2017-2021 XXX](/)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; 其中，aplayer 需要在插件部分设置中启用。您可以新增文字属性，用于展示其它文字信息，例如： blog/_config.volantis.yml123456site_footer: layout: [..., br, hello, ...] ... # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; hello: &#x27;[Hello World](/)&#x27; 网站与文章封面封面高度blog/_config.volantis.yml123cover: height_scheme: full # full, half ... 目前主题提供两种首页封面高度方案，其它页面均为半屏幕高度。 封面布局方案blog/_config.volantis.yml1234cover: ... scheme: dock # search (搜索), dock (坞), featured (精选), focus (焦点) ... 布局方案 适合场景 search 注重搜索 dock 入口选项比较多 featured 选项在4个左右 focus 选项在4个左右 默认显示设置blog/_config.volantis.yml123456cover: ... display: home: true archive: false others: false # can be written in front-matter &#x27;cover: true&#x27; 由于主页、归档是 hexo 自动生成的，您需要在主题配置文件中设置是否显示封面，而其它页面则可以在 front-matter 中通过设置 cover: true/false 来决定显示封面或者不显示封面。 文章布局配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# 文章布局article: # 文章列表页面的文章卡片布局方案 preview: scheme: landscape # landscape # pin icon for post pin_icon: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # show split line or not line_style: solid # hidden, solid, dashed, dotted # show readmore button readmore: auto # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, counter] # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fas fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fas fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg # ---------------- # 版权声明组件 (for layout: post/docs) copyright: enable: true permalink: &#x27;本文永久链接是：&#x27; content: - &#x27;博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&#x27; - permalink # ---------------- # 打赏组件 (for layout: post/docs) donate: enable: false images: - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags, share] # meta library meta_library: # 默认文章作者（可在 front-matter 中覆盖） author: avatar: name: 请设置文章作者 url: / # 文章创建日期 date: icon: fas fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fas fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fas fa-folder-open # 文章浏览计数 counter: icon: fas fa-eye unit: &#x27;次浏览&#x27; # 文章评论数量：只支持 valine valinecount: icon: fas fa-comment-dots desc: &#x27;&#x27; # 条评论 # 文章字数和阅读时长 wordcount: icon_wordcount: fas fa-keyboard icon_duration: fas fa-hourglass-half # 文章标签 tags: icon: fas fa-hashtag # 分享 share: - id: qq img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png - id: qzone img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png - id: weibo img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png - id: # qrcode # 当id为qrcode时需要安装插件 npm i hexo-helper-qrcode img: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/wechat.png - id: # telegram img: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/telegram.png 其中 top_meta 和 bottom_meta 部分的取值自 meta_library 库。 侧边栏配置侧边栏小组件与 meta 库不同的是：除了现有的 widget ，您可以很轻易地创建自己的 widget ，然后放在需要的地方。此外，您还可以将 widget 写在单独的文件中。 查看所有相关配置 blog/_config.volantis.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798sidebar: # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, qrcode] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png shape: rectangle # circle, rectangle url: /about/ title: subtitle: jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: true # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fas fa-folder-open title: 文章分类 url: /blog/categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # qrcode widget donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fas fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2020/01/01&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; wordcount: enable: true text: &#x27;本站总字数：&#x27; # 需要启用 wordcount unit: &#x27;字&#x27; siteuv: enable: true text: &#x27;本站访客数：&#x27; # 需要启用 busuanzi unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; # 需要启用 busuanzi unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27; 每一个小部件都有 class 和 display，前者代表这个小部件是什么，后者代表这个小部件在什么桌面和移动平台中是否显示，如果在移动平台显示，由于屏幕宽度有限，侧边栏的小部件则会被移动到正文区域下方，因此部分侧边栏小部件便失去意义，建议设置为仅桌面端显示。 1234小部件名: class: 小部件类别 display: [小部件在桌面端是否显示, 小部件在移动设备是否显示] pjaxReload: true # 是否 pjax 重载 默认 true; 设置为 false 时 确保所有页面都含有该小部件 博主信息部件blog/_config.volantis.yml12345678blogger: class: blogger display: [desktop] # [desktop, mobile] avatar: https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png title: subtitle: jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: true 其中，今日诗词 jinrishici 如果设置为一个字符串，这个字符串会变成占位文字，加载失败时显示。如果不需要，就请设置为 jinrishici: false。social 的具体内容请在网站页脚部分设置。 文章目录部件blog/_config.volantis.yml123456789toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 这个部件只能放置在侧边栏，并且在文章中有效。在移动设备中预览时，手指向上滑动时，导航栏右边会出现 TOC 按钮，点击即可展开 TOC 部件。如果您需要显示章节序号，请设置 list_number。 min_depth 和 max_depth 代表 TOC 支持的标题层级，最大范围是2～6。 文章分类部件blog/_config.volantis.yml1234567category: class: category display: [desktop] # [desktop, mobile] header: icon: fas fa-folder-open title: 文章分类 url: /blog/categories/ 这个部件可以直接显示所有文章分类，如果您希望有一个独立的页面来展示，需要自己创建一个文件，具体操作在「页面」部分文档中。 标签云部件blog/_config.volantis.yml123456789101112tagcloud: class: tagcloud display: [desktop] # [desktop, mobile] header: icon: fas fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; 这个部件可以直接显示所有文章的标签，如果您希望有一个独立的页面来展示，需要自己创建一个文件，具体操作在「页面」部分文档中。 二维码部件blog/_config.volantis.yml1234567donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png 您可以放置在文章页脚用于展示打赏图片，也可以放置在侧边栏。 通用文本部件blog/_config.volantis.yml123456789101112repos: class: text display: [desktop] # [desktop, mobile] header: icon: fab fa-github title: 点个赞吧 url: https://github.com/xaoxuu/ content: - &#x27;您的赞对我来说很重要，如果您喜欢本主题，希望能够给下面的项目点个赞来支持一下。&#x27; - &#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/ProHUD)&#x27; - &#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/valuex/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/ValueX)&#x27; - &#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/inspire/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/Inspire)&#x27; 您可以创建用于展示任何文本内容的文本部件。 通用列表部件blog/_config.volantis.yml123456789101112wiki-hexo-theme: class: list display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-chevron-left title: Hexo Themes url: /wiki/ rows: - name: Volantis for Hexo url: /wiki/volantis/ - name: Resume for Hexo url: /wiki/resume/ 您可以创建用于展示任何链接列表的列表部件。列表的 rows 中的每一项支持的属性有： name、url、icon、img、avatar，其中 img 是方形图片的链接，avatar 是圆形图片的链接。 组索引这个部件的布局继承自 list 部件，用于展示文章所属的分组的文章列表。请将您的 Volantis 升级至 2.5 版本以上使用。 blog/_config.volantis.yml1234567group-1: class: group display: [desktop, mobile] # [desktop, mobile] header: icon: fab fa-github title: Git url: /wiki/git/ 在文章的 front-matter 中设置： front-matter123group: group-1order: 16sidebar: [group-1, toc] 「group-1」卡片将会以列表的形式显示所有设置了 group: group-1 的文章，顺序按照 order 从小到大排列。 通用网格部件blog/_config.volantis.yml123456789101112131415161718feedback: class: grid display: [desktop, mobile] header: icon: fas fa-headset title: 联系开发者 url: https://github.com/volantis-x/hexo-theme-volantis fixed: true # 固定宽度 rows: - name: 反馈BUG icon: fas fa-bug url: https://github.com/volantis-x/hexo-theme-volantis/issues/ - name: 疑问求助 icon: fas fa-question-circle url: https://github.com/volantis-x/hexo-theme-volantis/issues/ - name: 提个建议 icon: fas fa-lightbulb url: https://github.com/volantis-x/hexo-theme-volantis/issues/ 您可以创建用于展示任何链接列表的网格部件。网格默认根据文字长度自动确定每一个格子的宽度，如果文字长短不一，建议通过设置 fixed: true 来固定宽度，此时文字过长的格子中的文字会换行显示。 通用页面部件blog/_config.volantis.yml12345test: class: page display: [desktop, mobile] pid: haha content: excerpt # excerpt, more, content 您可以把整个页面的md内容作为一个小部件渲染显示出来。只需要设置小部件里的 pid 属性和文章的 front-matter 中设置一样的 pid 即可。 content 代表这个部件显示的内容，可选 excerpt，more，content 分别对应文章的摘要、摘要后面的内容、全文。 音乐部件blog/_config.volantis.yml1234music: class: music display: [desktop, mobile] # [desktop, mobile] pjaxReload: false 选择评论系统目前支持的评论系统有： giscus, beaudar, utterances, valine, twikoo, waline, minivaline, disqus, disqusjs, gitalk, vssue, livere, isso, hashover blog/_config.volantis.yml1234comments: title: &lt;i class=&#x27;fas fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: giscus # giscus, beaudar, utterances, valine, twikoo, waline, minivaline, disqus, disqusjs, gitalk, vssue, livere, isso, hashover GitHub Discussions 系列 giscus A comments system powered by GitHub Discussions. https://giscus.app/blog/_config.volantis.yml12345678910111213141516171819comments: ... service: giscus ... # giscus # https://giscus.app # https://github.com/laymonage/giscus giscus: theme: light: https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/light.css dark: https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/dark.css # 以下配置按照 yml 格式增删填写即可 # repo: xxx/xxx # repo-id: xxx # category: xxx # category-id: xxx # mapping: &quot;pathname&quot; # reactions-enabled: &quot;1&quot; # emit-metadata: &quot;0&quot; GitHub Issues 系列 beaudarutterancesVssueGitalk Beaudar 名称源于粤语“表达”的发音，是 Utterances 的中文版本。 https://beaudar.lipk.org/blog/_config.volantis.yml1234567891011121314151617comments: ... service: beaudar ... # beaudar # https://beaudar.lipk.org/ beaudar: repo: xxx/xxx issue-term: pathname issue-number: branch: main position: top order: desc theme: light: github-light dark: github-dark label: ✨💬✨ A lightweight comments widget built on GitHub issues. https://utteranc.es/blog/_config.volantis.yml1234567891011121314comments: ... service: utterances ... # utterances # https://utteranc.es/ utterances: repo: xxx/xxx issue-term: pathname issue-number: theme: light: github-light dark: github-dark label: ✨💬✨ Vue 驱动的、基于 Issue 的评论插件 https://vssue.js.org/zh/blog/_config.volantis.yml123456789comments: ... service: vssue ... vssue: owner: repo: clientId: clientSecret: A modern comment component based on Github Issue and Preact. https://gitalk.github.io/blog/_config.volantis.yml12345678910comments: ... service: gitalk ... gitalk: clientID: clientSecret: repo: owner: admin: # []clientID 和 clientSecret 的获取方法可自行搜索教程，这里仅简单描述一下步骤：点击 GitHub -&gt; Settings https://github.com/settings/profile点击 Developer settings https://github.com/settings/developers点击 New OAuth App https://github.com/settings/applications/new填写信息：Application name 随便填，我的是：xaoxuu.comHomepage URL 和 Authorization callback URL 都写你的网址，我的是：https://xaoxuu.com可以通过设置 gitalk.id 实现多个页面共用一个评论框。front-matter1234---gitalk: id: /wiki/volantis/--- Disqus 系列 DisqusDisqusJSIsso Disqus - The #1 way to build an audience on your website. https://disqus.com/blog/_config.volantis.yml123456comments: ... service: disqus ... disqus: shortname:可以通过设置 disqus.path 实现多个页面共用一个评论框。front-matter1234---disqus: path: /wiki/volantis/--- Render Disqus comments in Mainland China using Disqus API https://github.com/SukkaW/DisqusJSblog/_config.volantis.yml1234567891011121314comments: ... service: disqusjs ... # DisqusJS # https://github.com/SukkaW/DisqusJS disqusjs: path: # 全局评论地址 # 配置项按照yml格式继续填写即可 除了 [siteName url identifier] 选项 #shortname: #api: #apikey: #admin: #nesting: A commenting server similar to Disqus. https://posativ.org/isso/blog/_config.volantis.yml1234567comments: ... service: isso ... isso: url: https://example.com/(path/) src: https://example.com/(path/)js/embed.min.js valine 或 解决 valine 遗留问题同一时期产生的评论系统 ValinetwikoowalineMiniValine 一款快速、简洁且高效的无后端评论系统 https://valine.js.orgblog/_config.volantis.yml123456789101112comments: ... service: valine ... valine: # js: https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js path: # 全局评论地址 目前设置全局评论地址后visitor失效,这是valine的问题 placeholder: 快来评论吧~ # 评论占位提示 # 其他配置项按照yml格式继续填写即可 除了 [el path placeholder emojiCDN emojiMaps] 选项 appId: # your appId appKey: # your appKey ... 可选配置项详见源码其中，placeholder 支持在 front-matter 中设置。front-matter1234---valine: placeholder: 你觉得xxx怎么样呢？---也可以通过设置 valine.path 实现多个页面共用一个评论框。front-matter1234---valine: path: /--- 一个简洁、安全、免费的静态网站评论系统 | A simple, safe, free comment system. https://twikoo.js.org/blog/_config.volantis.yml123456789comments: ... service: twikoo ... twikoo: js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本 path: # 全局评论地址 # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项 envId: xxxxxxxxxxxxxxx # 腾讯云环境id其中，placeholder 支持在 front-matter 中设置。front-matter1234---twikoo: placeholder: 你觉得xxx怎么样呢？---也可以通过设置 twikoo.path 实现多个页面共用一个评论框。front-matter1234---twikoo: path: /--- 一个简洁、安全、免费的静态网站评论系统 | A simple, safe, free comment system. https://waline.js.org/blog/_config.volantis.yml1234567891011121314comments: ... service: waline ... # Waline # https://waline.js.org/ waline: js: https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js path: # 全局评论地址 目前设置全局评论地址后visitor失效,这是waline的问题 placeholder: 快来评论吧~ # 评论占位提示 imageHosting: https://7bu.top/api/upload # 图床api（默认使用去不图床） # 其他配置项按照yml格式继续填写即可 除了 [el path placeholder uploadImage] 选项 serverURL: xxxxxxxxxxxxxxx # Waline 的服务端地址（必填） 测试用地址: https://waline-ruddy.vercel.app ... 可选配置项详见源码其中，placeholder 支持在 front-matter 中设置。front-matter1234---waline: placeholder: 你觉得xxx怎么样呢？---也可以通过设置 waline.path 实现多个页面共用一个评论框。front-matter1234---waline: path: /--- 一款快速、简洁且高效的评论系统 https://github.com/MiniValine/MiniValine/blog/_config.volantis.yml12345678910111213comments: ... service: minivaline ... # MiniValine # https://github.com/MiniValine/MiniValine minivaline: js: https://cdn.jsdelivr.net/npm/minivaline@latest path: # 全局评论地址 placeholder: 快来评论吧~ # 全局评论占位提示 # 更多选项 https://minivaline.js.org/docs/cn/#/Options 按照yml格式继续填写即可 （除了 [el path placeholder] 选项） # 下面是一个例子： serverURL: https://hello.com其中，placeholder 支持在 front-matter 中设置。front-matter1234---minivaline: placeholder: 你觉得xxx怎么样呢？---也可以通过设置 minivaline.path 实现多个页面共用一个评论框。front-matter1234---minivaline: path: /--- Others LivereHashover... Communication makes better world. https://www.livere.com/blog/_config.volantis.yml123456comments: ... service: livere ... livere: uid: #你的livere的uid在这里查看你的 uid：https://livere.com/insight/myCode，在【代码管理 -&gt; 一般网站】中找到如下这段代码，其中 data-uid 中的内容就是你的 livere_uid。123&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;你的livere的uid&quot;&gt;... A free and open source PHP comment system designed to allow completely anonymous comments and easy theming. https://www.barkdull.org/software/hashoverblog/_config.volantis.yml123456comments: ... service: hashover ... hashover: src: https://example.com/(path/)comments.phpblog/themes/volantis/layout/_third-party/comments/评论系统名称/layout.ejs1这里写布局代码blog/themes/volantis/layout/_third-party/comments/评论系统名称/script.ejs1这里要写加载 js 的代码收录更多评论系统 可以通过在 front-matter 设置 config 实现在特定页面修改评论系统的相关配置。 支持的有(按字母顺序): giscus, gitalk, minivaline, twikoo, valine, waline front-matter12345---gitalk: config: id: /233/--- 站内搜索blog/_config.volantis.yml1234search: enable: true service: hexo # hexo js: https://cdn.jsdelivr.net/xxxxxxxx/js/search/hexo.js 默认配置为 Hexo 搜索，但是需要安装插件才能使用： 1npm i -S hexo-generator-json-content 原 google, algolia, azure, baidu 站内搜索 系祖传代码, 且文档丢失, 不便后续维护 在 5.0 版本移除 插件库概述Volantis 为丰富的插件提供了兼容性优化。大部分插件您只需开启和关闭，无需进行设置。 blog/_config.volantis.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289plugins: ################ required plugins ################ # jquery globalJquery: false # 全局引入 jquery jquery: https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js # fontawesome Pro 版本：https://cdn.jsdelivr.net/gh/inkss/fontawesome@5.15.3/css/all.min.css fontawesome: https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css ################ optional plugins ################ # issues api sitesjs: enable: true friendsjs: enable: true contributorsjs: enable: true ######## Plugins to improve loading speed: # 预加载 preload: enable: true service: flying_pages # instant_page, flying_pages instant_page: https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js flying_pages: https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js # 图片懒加载 # https://www.npmjs.com/package/vanilla-lazyload # tips: # 这里是主题自带的图片懒加载, 实现方案位于 /scripts/filters/z-lazyload ; srcset 属性的的优先级比 src 属性要高, 注意 srcset 存放了懒加载占位图, src 存放了原图 # 在支持 srcset 的浏览器或者 RSS 阅读器(还会有人使用老旧的阅读器?)上会优先读取 srcset 加载的图片(懒加载占位图), 对于 RSS 中图片丢失变成懒加载占位图的问题, 建议 自行使用脚本移除 srcset 属性 或 关闭图片懒加载 或 在 RSS 中插入 vanilla-lazyload lazyload: enable: true js: https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js onlypost: false loadingImg: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg # 不建议使用占位图, 建议loadingImg为空, 当前占位图会产生布局偏移, loadingImg 为空占位图是一个 1X1 像素的图片 blurIn: true # 模糊加载效果 （loadingImg为空时有效） ######## Plugins to optimize the experience: # 代码高亮 code_highlight: highlightjs # highlightjs or prismjs # highlight.js highlightjs: copy_code: true # 如果开启 js, hexo.config.highlight.enable 需要设置为 false js: #https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js # Please set hexo.config.highlight.enable = false !!! css: https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css # more: https://www.jsdelivr.com/package/npm/highlight.js?path=styles # prismjs # https://prismjs.com/ # https://hexo.io/zh-cn/docs/syntax-highlight#PrismJS prismjs: copy_code: true # Please set hexo.config.highlight.enable = false !!! set hexo.config.prismjs.enable = true !!! js: - https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js - https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js - https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js css: - https://cdn.jsdelivr.net/npm/prismjs/themes/prism-dark.css - https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.css # https://scrollrevealjs.org/api/reveal.html scrollreveal: enable: #true js: https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js distance: 32px duration: 800 # ms interval: 20 # ms scale: 1 # 0.1~1 ######## Plugins for SEO: # npm i hexo-wordcount wordcount: enable: #true ######## Plugins for ... # Button Ripple Effect nodewaves: enable: #true css: https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css js: https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js # fontawesome animation fontawesome_animation: enable: #true css: https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css # Typing Effects comment_typing: enable: #true js: https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/comment_typing.js # 视差滚动效果 Slide Background parallax: enable: #true position: cover # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 10000 # Duration (ms) fade: 1500 # fade duration (ms) (Not more than 1500) images: # For personal use only. At your own risk if used for commercial purposes !!! - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.webp - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.webp # APlayer is only available in mainland China. # APlayer config: https://github.com/metowolf/MetingJS aplayer: enable: #true js: aplayer: https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/js/APlayer.mini.js # aplayer@1.10 魔改: 将触摸和滚轮事件监听器标记为 `passive`，以提高页面的滚动性能 meting: https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 3175833810 # song id / playlist id / album id / search keyword # Optional fixed: false # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: false # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true # Pjax pjax: enable: true cover: true # 封面是否pjax处理 false：每次切换页面封面都重载，适合封面较少的情况 true：封面经过Pjax处理，适合封面较多的情况 timeout: 5000 # The timeout in milliseconds for the XHR requests. Set to 0 to disable the timeout. cacheBust: false # When set to true, Pjax appends a timestamp to skip the browser cache. animation: false # false, nprogress, circle banUrl: # 被屏蔽的 url 地址将不启用 pjax 跳转，可以在控制台下使用 window.location.pathname 获取 # - &#x27;/artitalk/&#x27; # artitalk 不支持 pjax # - &#x27;/bbtalk/&#x27; # bbtalk 不支持 pjax # 暗黑模式 darkmode # 开关按钮：在 navbar.menu 中添加： # - name: 暗黑模式 # 可自定义 # icon: fas fa-moon # 可自定义 # toggle: darkmode darkmode: enable: #true # 旧版 Internet Explorer 淘汰行动 # https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support # 本主题不支持Internet Explorer的任何版本!!! killOldVersionsOfIE: enable: true # 禁用JavaScript提示 # 本页面需要浏览器支持（启用）JavaScript # 主题中的某些插件必须启用JavaScript才能正常工作，例如开启scrollreveal如果禁用JavaScript会导致卡片消失 killNoScript: enable: true # Artitalk https://artitalk.js.org # 配置过程请参考：https://artitalk.js.org/doc.html # 使用过旧版本的请修改Leancloud shuoshuo class部分列名：https://artitalk.js.org/release.html # 除appID和appKEY外均为选填项 artitalk: # Set `plugins: [&quot;artitalk&quot;]` to enable in front-matter # 不支持 Pjax # 配置项按照yml格式继续填写即可 appId: ogP8qj3veMh0LFpFWMPOyF0X-MdYXbMMI # your appID appKey: nHXLd3N3Jgh460t2iRQKWAtr # your appKEY # serverURL: #leancloud绑定的api访问域名，使用国际版的话不需要填写 # lang: # 语言设置，zh为汉语，en为英语，es为西班牙语。默认为汉语 # pageSize: #每页说说的显示数量 # shuoPla: #在编辑说说的输入框中的占位符 # avatarPla: #自定义头像url的输入框的占位符 # motion: #加载动画的开关，1为开，0为关，默认为开 # bgImg: #说说输入框背景图片url # color1: #说说背景颜色1&amp;按钮颜色1 # color2: #说说背景颜色2&amp;按钮颜色2 # color3: #说说字体颜色 # cssUrl: #自定义css接口 # BBtalk https://bb.js.org bbtalk: # Set `plugins: [&quot;bbtalk&quot;]` to enable in front-matter # 不支持 Pjax js: https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js # BBtalk.js appId: 0KzOX4vC7Jsk6vzUGNeEiUaI-gzGzoHsz # your appID appKey: HwCiWuxfpvKiLm4teCUgTIba # your appKEY serverURLs: https://bbapi.heson10.com # Request Api 域名 # HexoPlusPlus # https://github.com/HexoPlusPlus/HexoPlusPlus # https://hexoplusplus.js.org/ # 无服务器Hexo后端,支持文章编辑,自带图床功能.目标:解决静态博客所有痛点[文章编辑、图片上传、博主活跃信息统计、博主说说、Twikoo加强版、阅读量统计等 hpp: # 说说功能 # Set `plugins: [&quot;hpptalk&quot;]` to enable in front-matter # 支持 Pjax hpp_talk: css: https://cdn.jsdelivr.net/gh/HexoPlusPlus/HexoPlusPlus@latest/talk.css # 建议锁定版本 js: https://cdn.jsdelivr.net/gh/HexoPlusPlus/HexoPlusPlus@latest/talk_user.js # 建议锁定版本 limit: 10 start: 0 # 配置项按照yml格式继续填写即可 # domain: # themecss: # HexoPlusPlus其他功能暂未集成 # 友链朋友圈 hexo-circle-of-friends # https://github.com/Rock-Candy-Tea/hexo-circle-of-friends # https://zfe.space/post/friend-link-circle.html fcircle: # Set `plugins: [&quot;fcircle&quot;]` to enable in front-matter # 支持 Pjax api: &#x27;&#x27; # api 地址 max_number: 20 # 页面展示文章数量 add_number: 10 # 每次加载增加的篇数 opentype: &#x27;_blank&#x27; # &#x27;_blank&#x27;打开新标签,&#x27;_self&#x27;本窗口打开 nofollow: true # 禁止搜索引擎抓取 # loadingCutom: # 自定义loading图 例如: &lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt; | &lt;img src=&quot;你的图片地址&quot; alt=&quot;加载中...&quot;&gt; # 消息提示 message: enable: true icon: # 默认图标，支持对图标添加颜色，可选值：see：/source/css/_style/_plugins/fontcolor.styl default: fas fa-info-circle light-blue quection: fas fa-question-circle light-blue time: # 默认持续时间 default: 5000 quection: 20000 position: &#x27;topRight&#x27; # 弹出位置 可选值：topRight, bottomRight, bottomLeft, topLeft, topCenter, bottomCenter, center transitionIn: &#x27;bounceInLeft&#x27; # 弹窗打开动画 可选值：bounceInLeft, bounceInRight, bounceInUp, bounceInDown, fadeIn, fadeInDown, fadeInUp, fadeInLeft, fadeInRight, flipInX transitionOut: &#x27;fadeOutRight&#x27; # 弹窗关闭动画 可选值：fadeOut, fadeOutUp, fadeOutDown, fadeOutLeft, fadeOutRight, flipOutX titleColor: &#x27;var(--color-text)&#x27; # 标题颜色 messageColor: &#x27;var(--color-text)&#x27; # 消息颜色 backgroundColor: &#x27;var(--color-card)&#x27; # 默认背景色 zindex: 2147483647 # 层级 copyright: # 是否在复制时弹出版权提示，影响范围：ctrl+c、代码块复制按钮、右键复制选项 enable: true title: &#x27;知识共享许可协议&#x27; message: &#x27;请遵守 CC BY-NC-SA 4.0 协议。&#x27; icon: &#x27;far fa-copyright light-blue&#x27; aplayer: # 是否开启音乐通知；播放、暂停、失败 时的图标 enable: true play: fas fa-play pause: fas fa-pause rightmenu: # 是否开启右键模块的消息通知 enable: true # 标签插件样式按需加载 # 注意这个配置是带缓存的, 如果修改标签插件样式每次调试需要刷新两次页面, 建议开发者关闭该配置 tag_plugin_load_on_demand: enable: #true # 每个页面强制加载以下标签插件样式 plugins: - note - btns - p - gallery # 聊天功能 chat_service: # tidio or gitter # Tidio # https://www.tidio.com/ tidio: id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx # Gitter # https://gitter.im gitter: room: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 幻灯片背景(视差滚动效果)jquery.backstretch 在 5.0 版本 移除, 被 parallax 替代 blog/_config.volantis.yml1234567891011plugins: ... parallax: enable: true position: cover # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 10000 # Duration (ms) fade: 1500 # fade duration (ms) (Not more than 1500) images: # For personal use only. At your own risk if used for commercial purposes !!! - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg ... 幻灯片背景图片显示的位置可以选择粘贴在封面上，跟随封面一起滑动，也可以选择固定作为网页背景图片。 highlight.jsblog/_config.volantis.yml1234567891011plugins: ... # 代码高亮 code_highlight: highlightjs # highlightjs or prismjs # highlight.js highlightjs: copy_code: true # 如果开启 js, hexo.config.highlight.enable 需要设置为 false js: #https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js # Please set hexo.config.highlight.enable = false !!! css: https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css # more: https://www.jsdelivr.com/package/npm/highlight.js?path=styles 如果需要使用 highlight.js 进行语法高亮，请将站点配置文件中的 highlight.enable 设置为 false 否则不会加载插件。您可以在 94 种 语法高亮主题 中挑选喜爱的主题，然后替换上面的 css 链接。 如果您使用 highlight.js 请确保没有使用 hexo 官方的 codeblock 标签，否则会报错。 经测试，使用 highlight.js 的情况下，部分容器内的代码可能仍然会被渲染甚至报错。 APlayer 音乐播放器blog/_config.volantis.yml12345678910111213141516171819202122plugins: ... # APlayer is only available in mainland China. # APlayer config: https://github.com/metowolf/MetingJS aplayer: enable: true js: aplayer: https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js meting: https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 3175833810 # song id / playlist id / album id / search keyword # Optional fixed: false # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: false # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true APlayer播放器只可以在中国大陆地区使用。相关文档： APlayer | MetingJS 暗黑模式blog/_config.volantis.yml123456789plugins: ... # 暗黑模式 darkmode # 开关按钮：在 navbar.menu 中添加： # - name: 暗黑模式 # 可自定义 # icon: fas fa-moon # 可自定义 # toggle: darkmode darkmode: enable: true 结束支持blog/_config.volantis.yml12345678910111213plugins: ... # 旧版 Internet Explorer 淘汰行动 # https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support # 本主题不支持Internet Explorer的任何版本!!! killOldVersionsOfIE: enable: true # 禁用JavaScript提示 # 本页面需要浏览器支持（启用）JavaScript # 主题中的某些插件必须启用JavaScript才能正常工作，例如开启scrollreveal如果禁用JavaScript会导致卡片消失 killNoScript: enable: true Artitalkblog/_config.volantis.yml1234567891011121314151617181920212223plugins: ... # Artitalk https://artitalk.js.org # 配置过程请参考：https://artitalk.js.org/doc.html # 使用过旧版本的请修改Leancloud shuoshuo class部分列名：https://artitalk.js.org/release.html # 除appID和appKEY外均为选填项 artitalk: # Set `plugins: [&quot;artitalk&quot;]` to enable in front-matter # 不支持 Pjax # 配置项按照yml格式继续填写即可 appId: ogP8qj3veMh0LFpFWMPOyF0X-MdYXbMMI # your appID appKey: nHXLd3N3Jgh460t2iRQKWAtr # your appKEY # serverURL: #leancloud绑定的api访问域名，使用国际版的话不需要填写 # lang: # 语言设置，zh为汉语，en为英语，es为西班牙语。默认为汉语 # pageSize: #每页说说的显示数量 # shuoPla: #在编辑说说的输入框中的占位符 # avatarPla: #自定义头像url的输入框的占位符 # motion: #加载动画的开关，1为开，0为关，默认为开 # bgImg: #说说输入框背景图片url # color1: #说说背景颜色1&amp;按钮颜色1 # color2: #说说背景颜色2&amp;按钮颜色2 # color3: #说说字体颜色 # cssUrl: #自定义css接口 BBtalkblog/_config.volantis.yml12345678910plugins: ... # BBtalk https://bb.js.org bbtalk: # Set `plugins: [&quot;bbtalk&quot;]` to enable in front-matter # 支持 Pjax js: https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js # BBtalk.js appId: 0KzOX4vC7Jsk6vzUGNeEiUaI-gzGzoHsz # your appID appKey: HwCiWuxfpvKiLm4teCUgTIba # your appKEY serverURLs: https://bbapi.heson10.com # Request Api 域名 Tidioblog/_config.volantis.yml123456789plugins: ... # 聊天功能 chat_service: tidio # tidio or gitter # Tidio # https://www.tidio.com/ tidio: id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx HexoPlusPlusblog/_config.volantis.yml12345678910111213141516171819plugins: ... # HexoPlusPlus # https://github.com/HexoPlusPlus/HexoPlusPlus # https://hexoplusplus.js.org/ # 无服务器Hexo后端,支持文章编辑,自带图床功能.目标:解决静态博客所有痛点[文章编辑、图片上传、博主活跃信息统计、博主说说、Twikoo加强版、阅读量统计等 hpp: # 说说功能 # Set `plugins: [&quot;hpptalk&quot;]` to enable in front-matter # 支持 Pjax hpp_talk: css: https://cdn.jsdelivr.net/gh/HexoPlusPlus/HexoPlusPlus@latest/talk.css # 建议锁定版本 js: https://cdn.jsdelivr.net/gh/HexoPlusPlus/HexoPlusPlus@latest/talk_user.js # 建议锁定版本 limit: 10 start: 0 # 配置项按照yml格式继续填写即可 # domain: # themecss: # HexoPlusPlus其他功能暂未集成 友链朋友圈blog/_config.volantis.yml1234567891011121314plugins: ... # 友链朋友圈 hexo-circle-of-friends # https://github.com/Rock-Candy-Tea/hexo-circle-of-friends # https://zfe.space/post/friend-link-circle.html fcircle: # Set `plugins: [&quot;fcircle&quot;]` to enable in front-matter # 支持 Pjax api: &#x27;&#x27; # api 地址 max_number: 20 # 页面展示文章数量 add_number: 10 # 每次加载增加的篇数 opentype: &#x27;_blank&#x27; # &#x27;_blank&#x27;打开新标签,&#x27;_self&#x27;本窗口打开 nofollow: true # 禁止搜索引擎抓取 # loadingCutom: # 自定义loading图 例如: &lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt; | &lt;img src=&quot;你的图片地址&quot; alt=&quot;加载中...&quot;&gt; 消息提示blog/_config.volantis.yml1234567891011121314151617181920212223242526272829plugins: ... # 消息提示 message: enable: true icon: # 默认图标，支持对图标添加颜色，可选值：see：/source/css/_style/_plugins/fontcolor.styl default: fas fa-info-circle light-blue quection: fas fa-question-circle light-blue time: # 默认持续时间 default: 5000 quection: 20000 position: &#x27;topRight&#x27; # 弹出位置 可选值：topRight, bottomRight, bottomLeft, topLeft, topCenter, bottomCenter, center transitionIn: &#x27;bounceInLeft&#x27; # 弹窗打开动画 可选值：bounceInLeft, bounceInRight, bounceInUp, bounceInDown, fadeIn, fadeInDown, fadeInUp, fadeInLeft, fadeInRight, flipInX transitionOut: &#x27;fadeOutRight&#x27; # 弹窗关闭动画 可选值：fadeOut, fadeOutUp, fadeOutDown, fadeOutLeft, fadeOutRight, flipOutX titleColor: &#x27;var(--color-text)&#x27; # 标题颜色 messageColor: &#x27;var(--color-text)&#x27; # 消息颜色 backgroundColor: &#x27;var(--color-card)&#x27; # 默认背景色 zindex: 2147483647 # 层级 copyright: # 是否在复制时弹出版权提示，影响范围：ctrl+c、代码块复制按钮、右键复制选项 enable: true title: &#x27;知识共享许可协议&#x27; message: &#x27;请遵守 CC BY-NC-SA 4.0 协议。&#x27; icon: &#x27;far fa-copyright light-blue&#x27; aplayer: # 是否开启音乐通知；播放、暂停、失败 时的图标 enable: true play: fas fa-play pause: fas fa-pause rightmenu: # 是否开启右键模块的消息通知 enable: true"}],"posts":[{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2021-11-06T12:08:51.000Z","updated":"2021-11-09T07:53:30.183Z","comments":true,"path":"Docker学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Docker 学习笔记笔记源自狂神说Java。 出现的问题 比如说，对于开发环境与线上环境， 即环境的部署问题。以及在开发人员与运维人员之间，有可能项目在开发人员的电脑中可用，而在运维人员的电脑中无法使用。再者，如果要将项目移植到Linux上，还要在Linux上提前配置好环境。这些都是已知问题！ 因此，我们可以让项目启动的时候，带着这些环境。这样在Linux上，我们就直接运行就好。 传统的开发模式是，开发来编写代码并且将项目打成Jar包或者War包。而让运维人员来部署环境等。 而现在是，开发人员直接将部署环境融入Jar包中。 Jar包+环境=镜像。 Docker官方文档：https://docs.docker.com/ Docker镜像仓库：https://hub.docker.com/ 安装DockerTo install Docker Engine, you need a maintained version of CentOS 7 or 8. Archived versions aren’t supported or tested. 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 所需要的安装包： 1sudo yum install -y yum-utils 设置阿里云的镜像仓库： 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum更新索引： 1yum makecache fast 安装Docker最新引擎： -ce 代表是社区（推荐） -ee 代表是企业版 1sudo yum install docker-ce docker-ce-cli containerd.io 启动Docker 1sudo systemctl start docker 检测Docker是否成功运行： 1docker run hello-world 我们可以看到，这里说的是，无法在本地找到镜像。 因此，它需要从远程拉取相应的镜像，Pulling正在拉取镜像。 同时，也在控制台上解释了这几步Docker都做了什么。 查看一下下载的hello-world镜像1docker images 这里可以看到我们本地所有的一些镜像。 我们最终的服务都需要打包成镜像。 卸载Docker123sudo yum remove docker-ce docker-ce-cli containerd.iosudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd 阿里云镜像加速解析Docker Run 首先docker会在本机寻找镜像，如果找到了，就使用，如果没有找到。就会从DockerHub上下载。 底层原理工作原理Docker是一个基于C/S结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端来访问。 DockerServer接收到DockerClient的指令，就会执行这个命令！ Docker为什么比虚拟机快 Docker有着比Linux更少的抽象层 Docker利用的是宿主机的内核，而虚拟机需要GuestOS。 所以说，新建容器时，Docker不需要加载内核的操作系统。 常用命令12345docker version #显示版本信息docker info #显示更多详细信息docker 命令 --help #某个命令的帮助手册 帮助文档的地址：https://docs.docker.com/reference/ 镜像命令1docker images # 查看所有的镜像信息 Repo 代表仓库地址 Tag 代表标签 Image Id 代表镜像的Id Created 代表创建时间 Size 代表容量大小 12345678# 显示详细信息docker images -a # 显示镜像IDdocker images -q# 搜索镜像 这个命令一般用于下载之前的步骤 先搜索是否存在docker search xxx 比如在环境配置之前，先搜索一下MySQL的镜像：1docker search mysql 这里可以看到很多MySQL的镜像。 通过帮助命令，来查看这个docker search命令的可选选项： 12# 根据过滤器 搜索属性大于3000的docker search mysql --filter=STARS=3000 12345# 拉取MySQL镜像 默认使用最新的版本docker pull mysql# 指定MySQL版本docker pull mysql:5.7 可以看到，Docker这边正在从仓库中拉取MySQL5.7，同时以分层方式下载。 存储MySQL5.7的真实地址是docker.io/library/mysql:5.7 现在可以在镜像中看到拉取的MySQL5.7。 镜像删除12# 根据image id删除镜像docker rmi -f xxxxxxx 12345#根据image id删除docker rmi -f xxx xxx# 自动批量删除docker rmi -f $(docker images -aq) 容器命令 注意，我们必须要先有镜像，才可以利用已有的镜像文件，随时创建容器。比如，现在我们拉取一个CentOS镜像。模拟Linux环境，当然这个Linux环境只有一些必需文件，很多命令也是缺乏的。 1docker pull centos 启动centos容器 注意启动的参数 1docker run -it centos /bin/bash 123456789docker run [可选参数] image--name=&quot;Name&quot; # 容器名字 mysql1 mysql2等等-d # 后台运行-i-t # 使用交互方式运行，进入容器查看内容 常与i一起使用-P # 指定容器运行的端口-p #主机端口：容器端口（将主机的端口映射到我们容器的端口）-p # 随机指定端口 查看正在运行的容器 123456789docker ps [可选参数]-a # 列出所有的信息-n=x # 显示最近创建的x个容器 -q #只显示容器的编号-aq # 查看所有的编号 退出容器123exit # 直接容器停止并且退出Ctrl + p + q # 退出但是不停止 删除容器123docker rm 容器id # 根据容器的id去删除 如果正在运行 则需要 rm -f 强制性删除docker rm -f $(docker ps -aq) # 根据所有的编号去删除 启动容器1234567docker start 容器id # 开启停止的容器docker restart 容器id # 重启容器docker stop 容器id # 停止容器docker kill 容器id # 强制停止容器 常用的其他命令后台启动容器1docker run -d XXX # 通过镜像来启动容器 这里有个问题，发现我们这个XXX会停止。也就是说，我们使用docker ps 来查看正在运行的容器时，是找不到这个XXX的。 为什么？因为缺乏前台进程，Docker 容器使用后台运行，是必须要有一个前台进程。如果没有，则Docker 会停止掉。 查看日志命令1docker logs 以上是后面跟的参数，tail 后可以加上数字，表示查看日志的条数。 1docker logs -ft --tail 10 Container_Id # 根据容器的ID来查看日志信息 比如我们可以新建一个CentOS容器，然后写一个脚本或者执行一些行为，会留下一些日志信息，然后使用docker logs命令来查看这些操作所留下的日志信息。 查看容器内部的进程信息1docker top Container_Id # 根据容器的ID来查看进程信息 查看容器的元数据信息（很重要）1docker inspect Container_Id # 根据容器的ID来查看这个容器的所有数据信息 可以看到Id信息、主机配置等信息。 进入当前正在运行的容器 通常我们都是使用后台方式来运行的，如果需要进入一个容器，修改一些配置：1docker exec -it Container_Id /bin/bash # 这里是以Bash方式进入 也可以通过sh方式 比如，如果这个容器是CentOS容器，我们就可以使用这种方式进入，而不是使用： 1docker run centos 这种方式来重新启动并进入。 通过docker attach Container_Id这种方式并不会给我们打开一个控制台，而是进入我们打开的容器中正在执行的终端。 从容器内中拷贝文件到容器外 注意，这里的操作指的是从容器内拷贝文件到容器外，我们一般使用拷贝的方式来实现；而如果是从容器外将数据文件传输到容器内，我们称之为Mount 挂载。 1docker cp 容器Id：容器路径 容器外的路径 # 根据容器Id将处于容器中路径中 如果在容器Id为001的容器中，其home路径下有一个文件叫做test.java，我们想要拷贝到使用这个容器的Linux系统的home路径下。我们可以使用命令： 1docker cp 001:/home/test.java /home Docker 安装 Nginx 搜索是否有可用的Nginx镜像？当然，建议去Docker的官网查看对应信息。 1docker search nginx 拉取最新的nginx 1docker pull nginx 根据相应参数启动这个Nginx容器 1docker run -d --name nginx01 -p 3344:80 nginx -d 是后台运行 --name 是 起一个别名 -p 是端口映射，是容器外的3344端口对应这个Nginx容器的80端口（Nginx的默认端口） 现在我们利用curl命令来访问一下容器外的3344端口，即Nginx的80默认端口是否正常启动。 1curl localhost:3344 现在可以看到，能够正常运行。 因此，我们可以通过这个命令，来启动多个Nginx实例。 通过交互模式进入这个Nginx容器： 1docker exec -it nginx01 /bin/bash 现在可以进入到终端，并输入whereis nginx来找到nginx对应的根目录： 1whereis nginx 但是，如果每次都要这样，进到某个容器内部才能修改。很麻烦，要是能够在容器外部，创建一个路径，将这个路径映射到内部的对应配置目录的路径，这样我们就可以在容器外部修改文件的同时，容器内部的文件也会同步变化。 而这样的技术，我们通过数据卷这个概念就可以解决。","categories":[{"name":"中间件","slug":"中间件","permalink":"https://github.com/Vincent990413/blog/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://github.com/Vincent990413/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"author":"vincent"},{"title":"Forest框架学习笔记","slug":"Forest框架学习笔记","date":"2021-10-27T08:55:24.000Z","updated":"2021-11-09T07:53:30.185Z","comments":true,"path":"Forest框架学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/Forest%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Forest 框架学习笔记前言 &amp; 背景 Forest 是一款Java HTTP客户端框架，通常使用在调用第三方接口的过程中，让这个过程就如同调用本地接口一样方便。当然，我们可以联想到Dubbo OpenFeign 这种类型的RPC框架，只需要定义接口，调用即可；而不必关心具体发送 HTTP 请求细节。 Forest就字面意思而言，就是森林的意思。但仔细看可以拆成For和Rest两个单词，也就是“为了Rest”（Rest为一种基于HTTP的架构风格）。 而合起来就是森林，森林由很多树木花草组成（可以理解为各种不同的服务），它们表面上看独立，实则在地下根茎交错纵横、相互连接依存，这样看就有点现代分布式服务化的味道了。 最后，这两个单词反过来读就像是Resultful。 工作原理及架构图Forest 会将定义好的接口通过动态代理的方法生成一个具体的实现类，然后组织、验证 HTTP 请求信息，绑定动态数据，然后发起请求，等待相应，失败重试等等。 Spring Boot 项目中使用导入依赖 首先导入 Forest 框架的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.dtflys.forest&lt;/groupId&gt; &lt;artifactId&gt;forest-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.11&lt;/version&gt;&lt;/dependency&gt; 导入解析 Jason 的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.48&lt;/version&gt;&lt;/dependency&gt; 使用接口请求例子1234public interface ForestClient &#123; @Request(&quot;http:localhost:8081/hello&quot;) String helloForest();&#125; 通过@Request注解，我们绑定一个请求，在这个请求中我们指定了请求接口的URL以及默认为Get方式，并最后将请求响应的数据以String的方式返回给调用者。 接下来，在欲使用的地方，将这个接口注入进来： 1234public class TestController &#123; @Resource private ForestClient forestClient;&#125; 并在方法中，直接调用这个方法即可： 12String result = forestClient.helloForest();System.out.println(&quot;响应成功，数据为：&quot; + result); 不使用接口来请求如果我们不需要接口，去完成请求： 12345678@Testpublic String forestTest()&#123; //1. 以String类型来接受 Get方法或者Post String strGetRequest = Forest.get(&quot;/hello&quot;).executeAsString(); //2. 以自定义类来接受 只要返回对象与自定义类中的属性对应 String strPostRequest = Forest.post(&quot;/hello&quot;).execute(PostResult.class);&#125; 注意，完整的参数配置如下： 123456789101112131415161718// 定义各种参数// 并以 Map 类型接受Map&lt;String, Object&gt; map = Forest.post(&quot;/&quot;) .backend(&quot;okhttp3&quot;) // 设置后端为 okhttp3 .host(&quot;127.0.0.1&quot;) // 设置地址的host为 127.0.0.1 .port(8080) // 设置地址的端口为 8080 .contentTypeJson() // 设置 Content-Type 头为 application/json .addBody(&quot;a&quot;, 1) // 添加 Body 项(键值对)： a, 1 .addBody(&quot;b&quot;, 2) // 添加 Body 项(键值对： b, 2 .maxRetryCount(3) // 设置请求最大重试次数为 3 // 设置 onSuccess 回调函数 .onSuccess((data, req, res) -&gt; &#123; log.info(&quot;success!&quot;); &#125;) // 设置 onError 回调函数 .onError((ex, req, res) -&gt; &#123; log.info(&quot;error!&quot;); &#125;) // 设置请求成功判断条件回调函数 .successWhen((req, res) -&gt; res.noException() &amp;&amp; res.statusOk()) // 执行并返回Map数据类型对象 .executeAsMap(); HTTP 方法（Get、Post等） Get方法 在这种情况下，默认情况下即为Get方法，以下几种写法等价： 12345678910public interface MyClient &#123; @Request(url = &quot;http://localhost:8001/hello&quot;, type = &quot;GET&quot;) String simpleGetRequest(); @GetRequest(url = &quot;http://localhost:8001/hello&quot;) String getRequest(); @Get(url = &quot;http://localhost:8001/hello&quot;) String get();&#125; 除了GET和POST，也可以指定成其他几种 HTTP 请求方式(PUT, HEAD, OPTIONS, DELETE)。 其中type属性的大小写不敏感，写成POST和post效果相同。 当然，为了团队开发规范，建议使用Get或者GetRequest这种写法。 Post 方法 同上 HTTP URL一般而言，请求的地址如下组成： 协议：http。 域名：localhost 或者 127.0.0.1。 端口号：Tomcat 默认端口为8080。 路径地址：/后到第一个问号为止。 查询参数：?param1=val1&amp;param2=val2。 锚点：从#开始到结束。 @Address 注解用法 为什么需要这个@Address注解呢？因为，避免重复地在@Request注解的url中，直接写上请求地址，不方便后期的维护。 首先，我们可以直接在Post或者Get注解上使用： 123@Request(&quot;/hello&quot;)@Address(host = &quot;&#123;0&#125;&quot;, port = &quot;&#123;1&#125;&quot;)ForestRequest&lt;String&gt; test(String host, int port); 1ForestRequest&lt;String&gt; test = todoForestClient.test(&quot;http://localhost&quot;, 8001); 这样的话，我们的URL地址，在使用的时候，会是：http://localhost:8001/hello 并且，序号从0开始，依次为参数属性，当然我们可以在@Request的 URL 属性中写：{0}，{1}，只要对应顺序对应即可。 但是注意到，这里返回的是ForestRequest对象，我们可以在执行网络请求之前，继续对这次请求过程添加配置：比如Headers头部属性设置，设置Body请求体，等等，然后执行execute() 或者executeAsXXX()来执行请求。 如果不想每次调用接口时设置URL，我们可以写在一个类中，然后在这个接口前使用@Address注解： 12345public class AddressInfo &#123; public final static HOST = &quot;http://localhost&quot;; public final static PORT = 8001;&#125; 123456@Address(host = AddressInfo.HOST, port = AddressInfo.port)public interface MyClient &#123; @Get(&quot;/hello&quot;) String helloRequest();&#125; 负载均衡情况下的，多个地址随机轮询： Forest 框架为我们提供了AddressSource接口，我们可以实现这个接口，并最终返回一个ForestAddress对象，而随机获取地址的算法，可以在getAddress方法实现： 12345678910111213public class MyAddressSource implements AddressSource &#123; @Override public ForestAddress getAddress(ForestRequest request) &#123; // 枚举我们所有可能用到的IP数据 String[] ipArray = new String[] &#123; &quot;192.168.0.1&quot;, &quot;192.168.0.2&quot;, &quot;192.168.0.3&quot; &#125;; //利用相应随机算法获得其中一个 Random random = new Random(); int randomIndex = random.nextInt(3); return new ForestAddress(ipArray[randomIndex], 80); &#125; &#125; 接下来在使用某个接口，可以指定这个接口实现类： 1234public interface MyClient &#123; @Get(&quot;/hello&quot;) @Address( source = MyAddressSource.class)&#125; URL 参数 以参数的顺序（下标从0开始）： 12@Request(&quot;http://localhost:8001/hello?param1=&#123;0&#125;&amp;param2=&#123;1&#125;&quot;)String hello(String first, String second); 以参数名为准： 12@Request(&quot;http://localhost:8001/hello?param1=&#123;param1&#125;&amp;param2=&#123;param2&#125;&quot;)String hello(@Var(&quot;param1&quot;)String param1, @Var(&quot;param2&quot;)String param2); 值得注意的是，使用这种方式需要声明全局变量或者使用@Var注解。 动态地将参数名与值注入URL中： 12@Request(&quot;http://localhost:8001/hello&quot;)String hello(@Query(&quot;a&quot;) String a, @Query(&quot;b&quot;) String b); 这样的URL的值为：http://localhost:8001/hello?a=xx&amp;b=xx 如果请求的值变多，这种方式显然不符合要求。我们可以传入一个Map对象，此时不需要名称： 12@Request(&quot;http://localhost:8001/hello&quot;)String hello(@Query Map&lt;String, Object&gt; map); 1234Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();String value = &quot;value&quot;;map.put(&quot;key&quot;, value);map.put(...); 如果@Query注解绑定的是单个定义值，则需要名称：@Query(&quot;name&quot;) String name。而如果是某个对象或者Map，则不需要：@Query User user。 JSON 字符串参数1234&#123; &quot;title&quot;: &quot;标题&quot;, &quot;content&quot;: &quot;内容&quot;&#125; 有时我们从前端请求的格式是 JSON 字符串，相应的，我们可以使用： 12@Request(&quot;http://localhost:8001/hello&quot;)String hello(@JSONQuery(&quot;news&quot;) News news) HTTP Header 在每次请求时，我们可以设置相应的Header信息，其中接受的是一个字符串数组，在接受多个请求头信息时，以以下形式填入请求头。 1234567@Request( url = &quot;http://localhost:8001/hello&quot;, headers = &#123; &quot;Accept-Charset: utf-8&quot;, &quot;Content-Type: text/plain&quot; &#125;)String hello(); 如果每次传入不同的请求头内容，可以通过动态绑定： 123456789public interface MyClient &#123; @Request( url=&quot;http://localhost:8001/hello&quot;, headers = &#123; &quot;Accept-Charset: $&#123;encoding&#125;&quot;, &quot;Content-Type: text/plain&quot; &#125; ) String hello(@Var(&quot;encoding&quot;)Stromg encoding);&#125; 如果需要的参数较多，我们可以使用@Header注解，并传入Map即可： 1234public interface MyClient &#123; @Request(url = &quot;http://localhost:8001/hello&quot;) String hello(@Header Map&lt;String, Object&gt; headerMap);&#125; HTTP Body 请求体我们知道，在Post方法与Put方法中，我们经常使用请求体的形式，来传输表单中的数据。 因此，我们可以使用@Body注解，将传入的参数数据绑定到HTTP请求体中。 默认body的格式为：application/x-www-form-urlencoded，即表单形式来序列化数据。 12@Post(url =&quot;http://localhost:8080/user&quot;)String sendPost(@Body(&quot;username&quot;) String username, @Body(&quot;password&quot;) String password); 其中表单格式的请求体以字符串key1=value1&amp;key2=value2...，并且value都是已经过 URL Encode 编码过的字符串。 当然，更通常情况下，我们使用Dto或者Entity对象来存储需要的表单属性。 12@Post(url = &quot;http://localhost:8080/user&quot;)String sendPostBody(@Body User user); 如果是JSON数据组成的对象的话，我们需要用@JSONBody注解： 比如前端JSON数据为： 1234&#123; &quot;username&quot; : &quot;vincent&quot;, &quot;password&quot; : &quot;asdi12bnasd1212sdsd111&quot;&#125; 那么后端，需要使用： 12@Post(url = &quot;http://localhost:8080/user&quot;)String sendPostBody(@JSONBody User user); 注意，User类中的属性要与前端JSON数据中的属性一一对应。 当然，也可以将属性拆分开来传输： 12@Post(url = &quot;http://localhost:8080/user&quot;)String sendPostBody(@JSONBody(&quot;username&quot;) String username, @JSONBody(&quot;password&quot;) String password ); @JSONBody 注解也可修饰List Map等集合对象。 注意，@JSONBody注解是可以使用：@Body注解 + contentType属性来实现。 1234@Post(url = &quot;http://localhost:8080/user&quot;,contentType = &quot;application/json&quot;)String sendPostJson(@Body User user); XML格式以及文件传输具体看官网文档http://forest.dtflyx.com/docs/basic/http_body 默认配置 @BaseRequest 注解 我们可以将@BaseRequest注解当做是每个接口的默认设置，当然每个具体方法是可以覆盖的。 @BaseRequest注解中的所有字符串属性，都可以通过模板表达式引用全局变量或者方法中的动态参数。 12@BaseRequest(baseURL = &quot;$&#123;baseUrl&#125;&quot;)String send(@Var(&quot;baseUrl&quot;) String baseUrl); Forest 请求对象 Forest 请求对象，即ForestRequest对象，是Forest框架中的核心组件之一。所有的Forest接口方法在调用后，都会转化为ForestRequest对象，然后再调用后端的底层网络框架：HttpClient 或者 OkHttp3 执行实际的请求发送过程。 我们直接通过接口中的方法返回值，返回一个ForestRequest对象。 12@Get(&quot;/test&quot;)ForestRequest&lt;?&gt; getForestRequest(); 泛型参数代表返回的响应数据所期望转换成的类型，我们可以在使用的时候，再具体指定即可。 1234567@Resourceprivate MyForestClient myForestClient;...ForestRequest&lt;?&gt; request = myForestClient.getForestRequest();String path = request.path;String result = request.execute(String.class); //这里可以看到 调用方法的时候 再指定返回响应数据的转换类型 一句话总结就是，若请求接口的方法以 ForestRequest 类作为返回值类型，调用该方法时不会直接执行发送请求的过程，而是返回 ForestRequest 类型的对象实例，以便做进一步的操作。 可以直接通过Forest类的静态方法Forest.request()来返回一个请求对象：1ForestRequest&lt;?&gt; request = Forest.request(); 当然，也可以指定请求方法，以及对应的路径，如图所示： ForestRequest 对象属性 常见的属性有：type，path，host，port，url，async等等。 执行请求方法 execute() 以自定义的类型返回响应数据 1Forest.get(&quot;/&quot;).execute(ApiResponse.class); 返回字符串类型 1(&quot;/&quot;).executeAsString(); 返回列表类型 1(&quot;/&quot;).executeAsList(); 返回Map类型 1(&quot;/&quot;).executeAsMap(); 修改后台请求框架 HttpClient或者OkHttp31request.backend(&quot;okhttp3&quot;); 重要属性这一部分内容，主要是每次请求的时候，手动设置request的相关配置。而不是通过注解来设置响应的属性，比如请求参数，头部信息，请求头。 http://forest.dtflyx.com/docs/basic/request#%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B 同步与异步执行Forest默认是同步的，可以通过request的async()方法设置为异步请求。 Forest 请求的同时，也提供了众多回调函数设置的方法。根据请求的响应状态，来进行不同的操作： 123456789101112131415Forest.post(&quot;/&quot;) // onSuccess回调函数: 请求成功时被调用 .onSuccess(((data, req, res) -&gt; &#123; // data 为响应成功后返回的反序列化过的数据 // req 为Forest请求对象，即 ForestRequest 类实例 // res 为Forest响应对象，即 ForestResponse 类实例 &#125;)) // onError回调函数: 请求失败时被调用 .onError(((ex, req, res) -&gt; &#123; // ex 为请求过程可能抛出的异常对象 // req 为Forest请求对象，即 ForestRequest 类实例 // res 为Forest响应对象，即 ForestResponse 类实例 &#125;)) // 执行请求，请求成功则执行onSuccess, 失败则执行onError .execute(); 请求重试回调函数，当请求重试时，被调用： 12345678910Forest.post(&quot;/&quot;) // 设置最大请求重试次数为 3 .maxRetryCount(3) // onRetry回调函数: 每次请求重试前被调用 .onRetry(((req, res) -&gt; &#123; // req 为Forest请求对象，即 ForestRequest 类实例 // res 为Forest响应对象，即 ForestResponse 类实例 &#125;)) // 执行请求，请求失败会触发 onRetry, 然后重发请求 .execute(); 接受数据 Forest 请求会自动将响应的数据，反序列化成我们需要的数据类型，我们只需要在指定位置，指定即可。 直接在注解的属性区域，指定text 或者 json 或者 xml：123@Request( dataType = &quot;text&quot;) 当然dataType为了用户使用，可以不填写。 如果指定返回的类型是，json 或者 xml，则会以响应的形式进行反序列化。 指定方法的返回类型，需要根据JSON中的属性，一一对应，可以是自己的实体类： 12345678/** * dataType属性指明了返回的数据类型为JSON */@Get( url = &quot;http://localhost:8080/user?id=$&#123;0&#125;&quot;, dataType = &quot;json&quot;)User getUser(Integer id) 前面提到，可以是@ForestRequest对象，好处在于，我们可以延迟请求的执行。 有Request当然也有Response： 如果有时候，不仅是需要响应的数据，还需要相关的响应状态，我们就需要ForestResponse对象，作为方法的返回值： 123456/** * ForestResponse 可以作为请求方法的返回类型 * ForestResponse 为带泛型的类，其泛型参数中填的类作为其响应反序列化的目标类型 */@Post(&quot;http://localhost:8080/user&quot;)ForestResponse&lt;String&gt; postUser(@JSONBody User user); 我们也可以根据响应的不同状态，执行不同的操作，同时自定义返回数据的返回格式： 12345678910111213141516171819202122232425262728293031// 以ForestResponse类型变量接受响应数据ForestResponse&lt;String&gt; response = client.postUser(user);// 用isError方法去判断请求是否失败if (response.isError()) &#123; ... ...&#125;// 用isSuccess方法去判断请求是否成功if (response.isSuccess()) &#123; ... ...&#125;// 以字符串方式读取请求响应内容String text = response.readAsString();// getContent方法可以获取请求响应内容文本// 和readAsString方法不同的地方在于，getContent方法不会读取二进制形式数据内容，// 而readAsString方法会将二进制数据转换成字符串读取String content = response.getContent();// 获取反序列化成对象类型的请求响应内容// 因为返回类型为ForetReponse&lt;String&gt;, 其泛型参数为String// 所以这里也用String类型获取结果 String result = response.getResult();// 以字节数组的形式获取请求响应内容byte[] byteArray = response.getByteArray();// 以输入流的形式获取请求响应内容InputStream in = response.getInputStream(); 日志管理Forest 在发送请求和接受响应数据时，都会自动打印出HTTP请求相关的日志，其中包括：请求日志、响应状态日志和响应内容日志。 请求日志请求日志会打印出所有请求发送的内容，其中包括：请求行、请求头以及请求体三部分： 响应日志响应日志包含了HTTP请求响应后接受到的状态码，以及响应时间。 响应内容默认是关闭的。 日志开关我们可以在配置文件中，负责日志功能的关闭。 application.properties 12345678#Forest 配置forest.max-connections=1000forest.timeout=5000forest.connect-timeout=5000forest.log-enabled=falseforest.log-request=falseforest.log-response-content=falseforest.log-response-status=false 当然也可以通过@LogEnabled注解，以及对应的相关属性，来决定哪些需要打开。 这个注解放在接口文件中： 123456789/** 默认开关：允许打印请求日志、响应状态日志，但不打印响应内容日志 */@Get(&quot;http://localhost:8080/send&quot;)@LogEnabledString send(@Query(&quot;msg&quot;) String message);/** 不打印响应状态日志 */@Get(&quot;http://localhost:8080/send&quot;)@LogEnabled(logResponseStatus = false)String send(@Query(&quot;msg&quot;) String message); 编写与配置自定义日志处理器 实现com.dtflys.forest.logging.ForestLogHandler接口，或者继承com.dtflys.forest.logging.DefaultLogHandler类。 这里采用继承类的方式，避免实现不需要的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 我自定义的日志处理器 */public class TestLogHandler extends DefaultLogHandler &#123; /** * 所有的请求最终会调用这个方法打印日志 */ @Override public void logContent(String content) &#123; super.logContent(&quot;[哈哈，这是我自己的日志]: &quot; + content); &#125; /** * 该方法生成Forest请求的日志内容字符串 * @param requestLogMessage 请求日志字符串 * @return 日志内容字符串 */ @Override protected String requestLoggingContent(RequestLogMessage requestLogMessage) &#123; StringBuilder builder = new StringBuilder(); builder.append(&quot;请求: \\n\\t&quot;); // 插入重试信息 builder.append(retryContent(requestLogMessage)); // 插入代理信息 builder.append(proxyContent(requestLogMessage)); // 插入请求类型变更历史信息 builder.append(requestTypeChangeHistory(requestLogMessage)); // 插入请求行信息 builder.append(requestLogMessage.getRequestLine()); // 获取并插入所有请求头内容 String headers = requestLoggingHeaders(requestLogMessage); if (StringUtils.isNotEmpty(headers)) &#123; builder.append(&quot;\\n\\t请求头: \\n&quot;); builder.append(headers); &#125; // 获取并插入所有请求体内容 String body = requestLoggingBody(requestLogMessage); if (StringUtils.isNotEmpty(body)) &#123; builder.append(&quot;\\n\\t请求体: \\n&quot;); builder.append(body); &#125; return builder.toString(); &#125; /** * 该方法生成Forest请求响应结果的日志内容字符串 * @param responseLogMessage 请求响应日志字符串 * @return 日志内容字符串 */ @Override protected String responseLoggingContent(ResponseLogMessage responseLogMessage) &#123; ForestResponse response = responseLogMessage.getResponse(); if (response != null &amp;&amp; response.getException() != null) &#123; return &quot;[网络错误]: &quot; + response.getException().getMessage(); &#125; // 获取请求响应状态码 int status = responseLogMessage.getStatus(); // 获取请求响应时间 long time = responseLogMessage.getTime(); if (status &gt;= 0) &#123; return &quot;请求响应: 状态码: &quot; + status + &quot;, 耗时: &quot; + time + &quot;ms&quot;; &#125; else &#123; return &quot;[网络错误]: 未知的网络错误!&quot;; &#125; &#125;&#125; 全局配置我们知道，全局都是在配置文件中配置问的。 1forest.log-handler=com.vincent.forest.config.MyForestLogHandler 如果需要单独为某个接口设置这个日志处理器的话，可以在接口上指定@LogHandler 123456789/** * 根据id值查询 其中为 xxxx?id=XXX的形式 * * @param id 查询的id值 * @return */@GetRequest(&quot;/todo/selectTodoById&quot;)@LogHandler(com.vincent.forest.config.MyForestLogHandler.class)Map&lt;String, Object&gt; selectTodoById(@Query(&quot;id&quot;) String id);","categories":[{"name":"中间件","slug":"中间件","permalink":"https://github.com/Vincent990413/blog/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://github.com/Vincent990413/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"author":"vincent"},{"title":"Annotation Note","slug":"Annotation-Note","date":"2021-10-25T09:06:01.000Z","updated":"2021-11-09T07:53:30.180Z","comments":true,"path":"Annotation-Note/","link":"","permalink":"https://github.com/Vincent990413/blog/Annotation-Note/","excerpt":"","text":"Annotation What&#39;s annotation? So annotation is a kind of description of codes, we could put it ahead of packages, classes, fields or methods etc, in order to explain about these elements. It&#39;s the new characteristics after JDK 1.5. Example We can use annotation to create Java Application Interface Document. 1234567891011121314151617181920/** * the class that could compute sum * * @author vincent * @version 1.0 * @since 1.5 */public class AnnotationDemo &#123; /** * the method of computing sum of two integer numbers * * @param a * @param b * @return sum */ public int add(int a, int b) &#123; return a + b; &#125;&#125; then we could enter command and type in: 1javadoc AnnotationDemo.java then you will find that it generated lots of static html files etc. Usually, we use the Reflection to analyze pieces of our codes, by doing that, we could just figure out those codes which are from other authors pretty clearly. Predefined annotations @Override: we use this annotation to override one sort of method from its superclass. @Deprecated: we use this annotation to mark those contents out of date, and maybe it&#39;s not officially maintained any more. @SuppressWarnings:we use this annotation to allow some warnings to exist in our specific codes. FormFor example, annotation @Deprecated is defined like this: 12345678910111213/** * Deprecated is one that programmers are discouraged from using, typically because it is dangerous, * or because a better alternative exists. Compilers warn when a * deprecated program element is used or overridden in non-deprecated code. * @author Neal Gafter * @since 1.5 * @jls 9.6.3.6 @Deprecated */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 1public @interface MyAnnotation So after Java Virtual Machine processes this java file, generating into corresponding class file. It goes like this: 1public interface MyAnnotation extends java.lang.annotation.Annotation &#123;&#125; So annotation is essentially a interface. PropertiesWe could define some methods or fields in the annotation file. However, there are actually some requirements in defining types that methods return. Basic type in Java String type Enumerate type Arrays above. And then, while you are using this annotation, you need to initialize the defined parameters, such as : 1234567891011121314/** * we need to initialize id and name */public @interface AnnotationDemo &#123; String id(); //if not, we could give it default value String name() default &quot;default value&quot;;&#125;@AnnotationDemo(id = &quot;DEQ221&quot;, name = &quot;defined value&quot;)public class AnnotationTest &#123;&#125; If there is only one parameter in properties, and the name of it is value. Then we don&#39;t have to type in value, just like this: 1@AnnotationDemo(&quot;vincent&quot;) If you have read most of popular frameworks like Spring Boot, Spring MVC, Mybatis etc. There are some annotations like this almost everywhere. About the initialization of Arrays, you put several values in the &#123;&#125;, just like this: 1@AnnotationDemo( arr = &#123; &quot;fir&quot;, &quot;sec&quot;&#125; ) Meta annotation What is meta annotation? It literally just means the description of this annotation. Same, it&#39;s some annotations. Like @Target @Retention etc. @Target: we use annotation @Target to describe the location of the annotation. @Retention: we use annotation @Retention to describe the period the annotation is maintained. @Documented: we use annotation @Documented to decide if the annotation is able to be extracted into the document that we use command javadoc to generate. @Inherited: we use annotation @Inherited to decide whether it could be inherited. @TargetLet us read the source code of this annotation: 123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125; As you can see, the property value does return arrays of ElementType, so we could just check out the definition of it: 12345678910111213141516171819202122232425262728293031323334353637383940public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; If we want the annotation we declared to be applied to Class or Method: 1234@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface AnnoMeta &#123;&#125; Then we could use this annotation ahead of one specified class or method: 123456@AnnoMetapublic class AnnotationTest &#123; @AnnoMeta public void test()&#123;&#125;&#125; @Retention1234567891011121314151617181920212223242526/** * Indicates how long annotations with the annotated type are to * be retained. If no Retention annotation is present on * an annotation type declaration, the retention policy defaults to * &#123;@code RetentionPolicy.CLASS&#125;. * * &lt;p&gt;A Retention meta-annotation has effect only if the * meta-annotated type is used directly for annotation. It has no * effect if the meta-annotated type is used as a member type in * another annotation type. * * @author Joshua Bloch * @since 1.5 * @jls 9.6.3.2 @Retention */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value();&#125; So it Indicates how long annotations with the annotated type are to be retained. As we can see the RetentionPolicy 12345678910111213141516171819202122232425262728293031/** * Annotation retention policy. The constants of this enumerated type * describe the various policies for retaining annotations. They are used * in conjunction with the &#123;@link Retention&#125; meta-annotation type to specify * how long annotations are to be retained. * * @author Joshua Bloch * @since 1.5 */public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; Usually we use RUNTIME to make our annotations more reflectively and flexible, in order to keep this annotation in the class file and could be read by JVM. @DocumentedSo this annotation basically just decide whether it could be useful for generating the document files, when we use command javadoc. @InheritedIf we add this annotation, then it indicates that it could be applied to its inherited class. How could we use our own annotation? How could we use one annotation? So the point is , we could use the properties we get from the declaration. Now for example, we want to define the annotation to specify the method (and its class) that we want to execute.. Like if we want to execute the method a() from class A, or method b() from class B: 1@TargetExecute(className = &quot;A&quot;, methodName = &quot;a&quot;) So first of all, we need to create a annotation: 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TargetExecute &#123; String className(); String methodName();&#125; Then we need to have one object and its following methods: 12345public class Demo &#123; public void getDemoInfo() &#123; System.out.println(&quot;Hello, this is the info from demo!&quot;); &#125;&#125; 1234567891011121314151617181920@TargetExecute(className = &quot;com.elasticsearch.demo.Demo&quot;, methodName = &quot;getDemoInfo&quot;)public class AnnotationTest &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;AnnotationTest&gt; annotationTestClass = AnnotationTest.class; TargetExecute annotation = annotationTestClass.getAnnotation(TargetExecute.class); String className = annotation.className(); String methodName = annotation.methodName(); Class&lt;?&gt; cls = Class.forName(className); Object obj = cls.newInstance(); Method method = cls.getMethod(methodName); method.invoke(obj); &#125;&#125; So the first step is to make use of the Class&lt;T&gt; to pin down where ( maybe it&#39;s a Class or a method or field etc. ) we use the annotation to take effect: 1Class&lt;AnnotationTest&gt; annotationTestClass = AnnotationTest.class; Then we need to use method getAnnotation(T.class) to get the info of annotation that we created (here we use the skill -- Reflection): 1TargetExecute annotation = annotationTestClass.getAnnotation(TargetExecute.class); And then it will help us to create one implemented class of this annotation, and by the name of abstract methods, we could get the properties&#39; value: 1String className = annotation.className(); Eventually, by using skill Reflection, we could just invoke the specified method: 1234Class&lt;?&gt; cls = Class.forName(className);Object obj = cls.newInstance();Method method = cls.getMethod(methodName);method.invoke(obj);","categories":[{"name":"注解学习","slug":"注解学习","permalink":"https://github.com/Vincent990413/blog/categories/%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"注解学习","slug":"注解学习","permalink":"https://github.com/Vincent990413/blog/tags/%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"Java技巧-深拷贝与浅拷贝","slug":"Java技巧-深拷贝与浅拷贝","date":"2021-10-04T00:44:51.000Z","updated":"2021-11-09T07:53:30.198Z","comments":true,"path":"Java技巧-深拷贝与浅拷贝/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"Java中的对象拷贝 我们知道，在Java中一切皆为对象。那么，很多时候，为了实现对象代码的复用。我们希望上下文的对象，能够具有一样的成员变量。 在这种情况下，我们则可以使用对象拷贝，在Java中，有两种对象类型： 基本数据类型（非包装类）：int、long、float、double。 引用型数据类型：Class、Interface以及Array数组。 Java中的浅拷贝 Shallow Copy：浅拷贝，对于基本数据类型的浅拷贝，会直接进行值的传递，即将该属性值复制一份给新的对象，因为是复制粘贴的，因此修改新的数据，不会影响旧的数据。而对于引用型数据类型，由于存在地址的引用问题，因此浅拷贝会将地址给新的引用对象，也就是说，新的对象与旧的对象是指向同一个地址的，那么修改任何一个，另一个肯定也会更改。 浅拷贝的实现方式通过拷贝构造函数顾名思义，就是在构造函数中，将这个类的对象作为参数。从而，在调用新的对象的构造函数时，用已有的对象作为参数。实现，指向同一个地址。 类似如下的代码： 12Student stu1 = new Student();Student stu2 = new Student(stu1); 在这里，我们需要有符合这样参数形式的构造函数。 Student对象123456789101112131415161718192021222324252627282930313233343536373839404142public class Student &#123; private String name; private Age age; public Student() &#123; &#125; public Student(String name, Age age) &#123; this.name = name; this.age = age; &#125; public Student(Student student)&#123; this.name = student.name; this.age = student.age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Age getAge() &#123; return age; &#125; public void setAge(Age age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; Age类作为Student的域1234567891011121314151617181920212223242526public class Age &#123; private int age; public Age() &#123; &#125; public Age(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Age&#123;&quot; + &quot;age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试代码1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; //第一个学生对象 jack Student jack = new Student(); Age age = new Age(18); jack.setName(&quot;Jack&quot;); jack.setAge(age); //第二个学生对象bob 但通过构造函数实现对jack对象的复用 Student bob = new Student(jack); //更改jack的属性 观察bob中属性是否随之发生变化？ jack.setName(&quot;Jacky&quot;); age.setAge(28); System.out.println(&quot;jack对象为：&quot; + jack.toString()); System.out.println(&quot;------------------------------&quot;); System.out.println(&quot;bob对象为：&quot; + bob.toString()); &#125;&#125; 代码结果： 123jack对象为：Student&#123;name=&#x27;Jacky&#x27;, age=Age&#123;age=28&#125;&#125;------------------------------bob对象为：Student&#123;name=&#x27;Jack&#x27;, age=Age&#123;age=28&#125;&#125; 结论：对于字符串常量类型，由于是非引用类型，因此修改旧的对象值不会影响新的对象。而对于是引用类型的age，由于指向同一个地址，导致更改后，新的对象也发生了改变。 通过重写clone方法（注意结合原型模式） 在设计模式中，我们也通过这样的方法完成对象的拷贝。 Student类实现接口Cloneable1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Student implements Cloneable &#123; private String name; private Age age; public Student() &#123; &#125; public Student(String name, Age age) &#123; this.name = name; this.age = age; &#125; public Student(Student student) &#123; this.name = student.name; this.age = student.age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Age getAge() &#123; return age; &#125; public void setAge(Age age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public Object clone() &#123; Object object = null; try &#123; object = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return object; &#125;&#125; 1234Student stu1 = new Student();stu1.setName(&quot;Jack&quot;);Student stu2 = (Student)stu1.clone(); Java中的深拷贝 我们知道，很多时候在Java中某个类的对象中，还有可能有对象，这样来说，深拷贝不仅要复制对象所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用变量所引用的对象。 重写clone方法来实现深拷贝注意，我们说过，一层套一层的对象引用概念，因此我们要想实现深拷贝。 必须，为每一层的每一个对象都实现Cloneable接口并重写clone方法，最终在顶层中重写clone方法即可。 Age类 12345678910111213141516171819202122232425262728293031323334public class Age implements Cloneable&#123; private int age; @Override public Object clone()&#123; Object object = null; try&#123; object = super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return object; &#125;&#125;public class Student&#123; private Age age; private String name; @Override public Object clone()&#123; Object object = null; try&#123; object = super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; //注意 这里需要将Student的成员变量Age实现拷贝 Student student = (Student)object; student.age = (Age)student.getAge().clone(); return object; &#125;&#125; 在进行深拷贝之后，不论是什么类型的属性值的修改，都不会影响另一个对象的属性值。 对象序列化 将对象进行序列化之后，会默认将该对象中的深层级的对象进行序列化。再通过反序列化即可完美地实现深拷贝。 Student类与Age类均实现Serializable接口1234public class Student implements Serializable &#123; private String name; private Age age;&#125; 1234public class Age implements Serializable &#123; private int age;&#125; 测试代码1234567891011ByteArrayOutputStream bos = new ByteArrayOutputStream();Student stu1 = new Student();stu1.setName(&quot;张三&quot;);ObjectOutputStream oos = new ObjectOutputStream(bos);oos.writeObject(stu1); oos.flush();ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois = new ObjectInputStream();Student stu2 = (Student)ois.readObject(); 这样就可以被拷贝了，但是值得注意的是： 如果某个属性被注解Transient修饰，则无法被拷贝。","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"设计模式学习笔记","slug":"设计模式学习笔记","date":"2021-09-28T03:04:09.000Z","updated":"2021-11-09T07:53:30.230Z","comments":true,"path":"设计模式学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"注意：本篇笔记非原创，转载自书籍：《软件设计模式（Java版）》 面向对象的几大原则开闭原则 什么叫开闭原则呢？所谓开闭原则，就是软件实体应该对扩展开放而对修改关闭。 也就是说，当我们想要增加功能需求时，我们不能在原有的代码上修改。否则就违反了开闭原则！ 针对这个原则，我们应该面向接口编程，抽象与封装。在后期需要增加功能时，只需要增加接口的实现类即可。 里氏替换原则 里氏替换原则说，继承必须确保超类Superclass所拥有的性质，在子类中必须仍旧成立。 举个简单的例子，有一个圆类Circle，具有半径radius这个域，以及计算面积这个方法。 现在，我们需要设计一个圆椎类，如果纯粹使用继承 让圆椎类作为圆类的子类，则是不符合里氏替换原则的，因为继承的概念就表示：圆椎是一个圆，而这个论据，是不恰当的。 并且，圆具有的计算面积的方法，在子类圆椎中，也是不符合的。圆椎只能说，计算表面积，而不是面积。 因此，恰当的方法去避免这个问题，就是使用组合来代替单一继承所带来的缺点。 让圆Class作为圆椎类的一个成员变量，这样使得整个程序更加的灵活。 再举一个例子，现在有一个鸟类Bird，Swallow燕子类，和一个鸵鸟类。 如果让燕子类和鸵鸟类去继承Bird，也是不恰当的。 因为，Bird这个类如果具有飞行fly这个方法。那么鸵鸟，在现实世界中，是不会飞行的。 因此，作为子类的鸵鸟，却不具备父类的方法，这样设计也违背了里氏替换的原则。 依赖倒置原则 高层模块不应该依赖于底层模块，两者都应该依赖其抽象模块（接口或者抽象类），同时抽象不应该依赖细节，而是细节去依赖于抽象。 其核心思想是，我们要面向接口编程，而不是面向实现编程。 这里的抽象指的是，接口或者抽象类，而细节指的是具体的实现类。使用接口或者抽象类去制定规范，而不去具体操作，真正的具体操作，我们交给这些抽象的实现类来完成。 因此，当我们某个方法的参数，可能发生变化时，或者说有多个选择时。我们就应该考虑，是不是应该把这个参数，抽象成一个接口，或者抽象类。这样，我们在增加新功能时，就可以新建一个实现类去实现这个接口。从而不需要更改现有的代码。 单一职责原则又称为单一功能原则，该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，则当我们某一时刻需要某一个对象时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码。 也就是说，我们需要刻意去控制类的粒度大小。一个类只需要负责自己该负责的功能，如果某些方法不应该由这个类完成，就用一个新的类去封装进去。 比如一个数学老师，一个是英语老师。 那么，数学老师所负责的模块，就不应该涉及到英语。反之亦然。 接口隔离原则接口隔离原则要求程序员，尽量将庞大的接口，拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 也就是说，要为各个类建立他们所需要的专用接口，而不是试图建立一个庞大的接口，去容纳所有操作。 举一个例子，现要实现一个，学生成绩管理系统。 一般情况下，我们会包含：插入成绩，删除成绩，修改成绩，查询总分以及平均分，打印成绩等等功能。 我们可以注意到，我们其实可以按照另一种方式来将这些模块划分为子接口，并且，接口与接口之间，是互相隔离的。 正确的做法是，我们将它们，分别放在：输入接口，统计接口，以及打印接口。 这样，输入接口中，就只负责输入，比如插入，删除，更改。 而统计接口中，只负责，统计总分以及统计平均分。 打印接口中就只负责打印，打印学生信息或者打印成绩信息。 迪米特原则又叫做最少知识原则，换言之，只需要与自己的朋友进行交谈，而无须跟&quot;陌生人&quot;交谈。 如果两个软件实体，不能直接进行通信，那么就不要建立直接的联系，而应该利用中介：代理模式以及适配器模式很好地遵守了这样的原则。 在这里，自己的朋友包括，当前对象本身、当前对象的成员对象等等。 举个例子，比如现在有，明星类Star，经纪人类Agent以及粉丝类Fans，媒体公司Company类。 我们知道，明星是不应该与粉丝或者媒体公司进行直接的官方通信。那么，我们就需要一定的中介类完成这样的行为。 这个中介类就是Agent经纪人。在经纪人这个类中，我们将明星、粉丝以及媒体公司对象作为经纪人的域。这样，就可以利用经纪人，直接对这些对象进行处理。 合成复用原则合成复用原则提出，软件在复用的时候，应该首先考虑复用而不是继承。以消除Java的单重继承所带来的局限性。是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，以达到复用。 举个例子，汽车按照品牌来分类，可以分为奔驰汽车，三菱汽车等等。按照颜色来分，可以分为白色汽车，黑色汽车，等等。 如果使用继承的话，我们的类结构将会非常复杂。有白色奔驰汽车类，白色三菱汽车类等等。 更好的实现方法是，我们将颜色类作为汽车的成员变量，这样就可以直接将其复用。 设计模式创建型模式创建型模式概述 创建型模式的主要关注点是，怎样才能更好地创建对象？将对象的创建与实现分离，使用者不需要关注对象的创建细节。 单例模式Singleton：某个类只能生成一个实例，该类提供一个全局访问点，供外部获取。 原型模式Prototype：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法Factory Method：定义一个用于创建产品的接口，由实现类来决定生产什么产品。 抽象工厂Abstract Method：提供一个创建一系列产品的接口，其每个子类可以生产一系列相关的产品。 建造者模式Builder，将一个复杂对象分解为多个相对简单的部分，然后根据不同需要，或者按照顺序去创建它们，最后构建成该复杂对象。 在上面所提到的各个方法中，除了工厂方法模式属于类创建型模式，其他的全是对象创建型模式。 类创建型模式一般以继承实现为主，而对象创建型是主张对象复用为主。 单例模式在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。 单例模式有 个特点 ①单例类只有一个实例对象；②该单例对象必须由单例类自行创建。③单例类对外提供一个访问该单例的全局访问点。 1. 懒汉模式该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。 123456789101112public class LazySingleton&#123; //保证instance在所有线程中同步 private static volatile LazySingleton instance = null; private LazySingleton() &#123;&#125; public static synchronized LazySingleton getInstance() &#123; if(instance == null) &#123; instance = new LazySingleton(); &#125;else&#123; return instance; &#125; &#125;&#125; 2. 饿汉式单例该模式的特点是类一旦加载就创建一个单例 保证在调用 getlnstance 方法前单例已经存在了。 1234567public class HungrySingleton&#123; private static final HungrySingleton instance = new HungrySingleton(); private HungrySingleton()&#123;&#125; private static HungrySingleton getInstance() &#123; return instance; &#125;&#125; 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变 所以是线程安全的 可以直接用于多线程而不会出现问题。 原型模式 联想一个场景，齐天大圣孙悟空，拔下猴毛后轻轻一吹就变出了很多孙悟空。原型就可以当作是一个孙悟空，通过拷贝与这个原型对象一样的对象，从而达到需求。 原型模式的定义如下：用一个已经创建的实例，作为原型，通过复制该原型对象来创建一个和原型相同或者相似的新对象，例如Windows操作系统的安装通常比较耗时间，如果使用复制，就快很多。 由于Java提供了对象的clone()方法，而这个接口其实是抽象接口Clonable的方法，因此实现浅拷贝。 这里涉及到： 抽象原型类：规定原型对象必须实现的规范接口。 具体原型类：实现抽象原型类的clone方法，是被复制的对象。 访问类：使用具体原型类中的clone方法来复制新的对象。 123456789101112131415class Realizetype implements Cloneable&#123; Realizetype() &#123; &#125; public Object clone() throws CloneNotSupportedException&#123; //注意这里向下转型 可能会发生异常 return (Realizetype)super.clone(); &#125;&#125;public class PrototypeTest &#123; public static void main(String[] args) throws CloneNotSupportedException&#123; Realizetype obj1 = new Realizetype(); Realizetype obj2 = (Realizetype)obj1.clone(); //此时obj2 != obj1 &#125;&#125; 原型模式适用于： 对象之间相同或者相似，但只是个别属性不同。 对象的创建比较麻烦，而复制比较简单。 工厂方法模式 比如我们要去买汽车，汽车有奔驰、宝马等等。但其实我们不负责创建这些汽车，而是具体的工厂提供给我们这些汽车。我们只需要说出自己想要买的汽车的名字，就可以提供给我们产品了。 这种模式定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中去，这满足“对象的创建与使用相分离”。 工厂模式主要优点在于： 用户只需要知道具体工厂的名称就可以得到想要的产品 在系统增加新的产品时，只需要添加具体产品类和对应的具体工厂类即可，满足开闭原则，不需要对原来的工厂进行修改。 12345678910111213141516171819interface Product&#123; void show(); //展示产品的方法&#125;interface Factory&#123; Product createNewProduct();&#125;public class concreteProduct implements Product&#123; public void show()&#123; //展示具体产品的内容 &#125;&#125;public class concreteFactory implements Factory&#123; public Product createNewProduct()&#123; return new concreteProduct(); &#125;&#125; 使用场景： 客户只知道创建产品的工厂名，不必知道具体的产品名。 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。 客户不关心创建产品的细节，只关心产品的品牌。 抽象工厂模式 在工厂模式的基础上，应该考虑到的是，如果一个工厂是比较综合型的，不只是生产单一的产品，比如电器厂：既生成电视机，又生产冰箱等等。 我们将同一个具体工厂下，所生产的不同类型的一组产品，称为一个产品族。 我们可以想：其实抽象工厂方法，就是说一个工厂可以生产多个产品，而工厂方法模式中的一个工厂只能生成一种产品。 123456789101112131415interface AbstractFactory&#123; Product1 createNewProduct1(); //比如这个是冰箱产品 Product2 createNewProduct2(); //比如这个是洗衣机产品&#125;public class ConcreteFactory1 implements AbstractFactory&#123; public Product1 createNewProduct1()&#123; return new ConcreteProduct1(); &#125; public Product2 createNewProduct2()&#123; return new ConcreteProduct2(); &#125;&#125; 抽象工厂模式最早的应用，是在于不同操作系统下的UI组件设计。 比如一个产品，可以用在Windows操作系统或者iOS操作系统上。因此就可以使用这个抽象工厂模式来实现。 建造者模式 开发过程中，如果有一些对象，创建的过程很复杂，并且按照一定顺序。那么我们可以，将复杂对象的构造与它的表示相分离，分解为多个简单的对象，然后一步一步构建而成。 我们可以看出建造者模式与工厂方法模式的不同： 建造者模式更注重于，对象的构建过程！ 而工厂方法模式更注重于对象的创建过程！ 比如，现在产品有A、B两个属性。我们利用建造者模式来构建： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Product&#123; private String partA; private String partB; //忽略set get方法 public void show()&#123; //显示产品 &#125;&#125;abstract class Builder &#123; protected Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); //抽象类中可以存在非抽象方法 在子类中无需重写 public Product getResult()&#123; return product; &#125;&#125;public class ConcreteBuilder extends Builder &#123; public void buildPartA() &#123; //注意 这里product是protected类型 //因此子类ConcreteBuilder中可以获取 product.setPartA(&quot;建造PartA&quot;); &#125; public void buildPartB() &#123; product.setPartB(&quot;建造PartB&quot;); &#125;&#125;//负责调用建造者中的方法完成复杂对象的创建public Director &#123; private Builder builder; public Director(Builder builder)&#123; this.builder = builder; &#125; //产品具体的构造与组装 public Product build()&#123; builder.buildPartA(); builder.buildPartB(); return builder.getResult(); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); Product product = director.build(); &#125;&#125; 建造者模式的应用场景： 创建的是一个复杂对象，各个部分可能会发生改变。 结构型模式 结构性模式描述如何将类或对象按某种布局组成更大的结构，分为类结构与对象结构模式，前者采用继承机制，后者采用组合或聚合。 代理模式Proxy：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接访问该对象，从而限制、增强或修改该对象的特性。 适配器模式Adapter：将一个类Adaptee的接口转换成客户希望的另一个接口Target，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接模式Bridge：将抽象与实现分离，使它们可以独立变化。用组合关系代替继承关系，从而降低了抽象和实现之间的耦合度。 装饰器模式Decorator：动态地给对象增加一些职责，即增加其额外的功能。 外观模式Facade：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元模式Flyweight：运用共享技术来有效地支持大量细粒度对象的复用。 组合模式Composite：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 代理模式 想想这么一个场景，我们想买一张火车票，可是由于一些原因，不能去火车站直接购买。那么如何解决呢？自然是去一个叫做 “中介” 的地方，让他们来帮我们完成下单的操作。 代理模式的定义是：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。 这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 1234567891011121314151617181920212223242526272829interface Subject &#123; void buyTicket(); //这里是购买火车票的抽象方法&#125;class Customer implements Subject&#123; public void buyTicket()&#123; //这里是购买票的业务 &#125;&#125;class Proxy implements Subject &#123; //这个代码是关键 客户作为中介的成员变量 //这样就可以替客户来办事 private Customer customer; pubcli void buyTicket()&#123; if(customer == null)&#123; customer = new Customer(); &#125; //替客户办事儿 customer.buyTicket(); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Proxy proxy = new Proxy(); proxy.buyTicket(); &#125;&#125; 但这样的方式存在一些缺点，拿上面的例子来说： 客户类与客户代理类一一对应，下一次增加其他的类时，对应的代理类也要增加，麻烦。 由于客户代理类中，有对客户类的引用，因此，设计代理类之前，对应的类还得必须存在。 采用动态代理模式，就可以解决以上这个问题。 分为静态代理与动态代理的区别点：创建代理类的时间点。 静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 而重点是动态代理，代理类在程序运行时创建的代理方式被称为动态代理。 动态代理的优势在于，可以很方便地对代理类的函数进行统一的处理，而不同修改代理类中的方法。 比如，我们想要在每个代理类所代理的方法前，加一个处理方法。 如图所示，如果直接在代码中静态地加，则不具有高可用性。 动态代理简单实现 现在有一个场景，一个叫做张三的学生上交班费，但是张三不能直接交班费，而应该交给作为代理的班长，让班长代交上去。 交班费这个方法的抽象接口 123public interface Person &#123; void giveMoney();&#125; 学生类实现这个接口 123456789101112public class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void giveMoney() &#123; System.out.println(name + &quot;上交了50元班费！&quot;); &#125;&#125; 创建InvocationHandler调用处理器，这个处理器负责具体定位到代理对象的目标对象Target里面的所有方法，对其做进一步增强操作。 这个类需要实现InvocationHandler接口，并且调用所有目标对象的方法时，都会调用这个invoke方法，我们因此在这里去增加我们想要的操作。 123456789101112131415public class StudentInvocationHandler&lt;T&gt; implements InvocationHandler &#123; T target; public StudentInvocationHandler(T target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;代理执行&quot; + method.getName() + &quot;方法&quot;); Object invoke = method.invoke(target, args); return invoke; &#125;&#125; 测试类实现代理 12345678public class ProxyTest &#123; public static void main(String[] args) &#123; Person person = new Student(&quot;张三&quot;); StudentInvocationHandler&lt;Person&gt; personStudentInvocationHandler = new StudentInvocationHandler&lt;&gt;(person); Person monitor = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, personStudentInvocationHandler); monitor.giveMoney(); &#125;&#125; 这里使用Proxy.newProxyInstace静态方法，根据参数中指定的T泛型，以及指定的InvocationHandler实现类，来动态获取，并返回一个Object类型，可以向下转型为代理对象。 然后利用这个代理对象去执行目标对象已有的方法，如果有多个方法，每执行一次，都会经过invoke方法，因此可以对目标对象的所有方法进行全局处理。 适配器模式 在业务开发中，经常会遇到两个接口因为不兼容而不能正常工作。我们需要适配器来解决这个问题。解决问题的思路有两种，第一种是利用类适配器，第二种是利用对象适配器。 我们有 Target 目标类 我们有 Adaptee 待转换类 我们有 Adapter 适配器类 其实我们的目标很简单，在适配器类中，将待转换类与目标类，联系起来。 对象适配器模式 这种其实是基于组合或聚合的思想，也就是说，在适配器类中将待转换类作为这个类的成员变量，而去实现目标类，从而通过在重写的方法中去调用待转换类的相同方法，来实现联系。 代码如下： 图中我们可以看到，有一个三孔的插口，和双插头。 定义一个目标三孔接口Socket 1234//三孔插头public interface ThreeHoleSocket &#123; void plugIn(); //接入&#125; 定义一个双插头类 123456//两条金属柱的插头public class TwoColumnPlugger &#123; public void plug() &#123; System.out.println(&quot;这里可以实现插头的功能！&quot;); &#125;&#125; 定义将这个类与目标接口联系起来的适配器 12345678910111213public class SocketAdapter implements ThreeHoleSocket &#123; private TwoColumnPlugger twoColumnPlugger; public SocketAdapter(TwoColumnPlugger twoColumnPlugger)&#123; this.twoColumnPlugger = twoColumnPlugger; &#125; @Override public void plugIn() &#123; twoColumnPlugger.plug(); &#125;&#125; 测试 123456789101112public class SocketTest &#123; public static void main(String[] args) &#123; //已经有的插头 可以工作 TwoColumnPlugger twoColumnPlugger = new TwoColumnPlugger(); //已经适配 ThreeHoleSocket threeHoleSocket = new SocketAdapter(twoColumnPlugger); //插口已被接入 threeHoleSocket.plugIn(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"vincent"},{"title":"Java技巧-String_Buffer_Reader","slug":"Java技巧-String-Buffer-Reader","date":"2021-09-26T13:14:06.000Z","updated":"2021-11-09T07:53:30.195Z","comments":true,"path":"Java技巧-String-Buffer-Reader/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-String-Buffer-Reader/","excerpt":"","text":"String 我们都知道，String是常用的存储字符串的类。但是值得注意的是，对于String类中的对象的字符串值，是不可变的，是固定的。 代码如下： 123String str = new String(&quot;Hello&quot;);str = str + &quot; World&quot;; str这个对象是存储在栈内存的，而作为常量的Hello以及 World，是存储在堆内存中的。当str = str + &quot; World&quot;，需要重新开辟内存空间，来存储Hello World，如果某一个功能需要反复地操作字符串，这样的做法就极其浪费资源。 因此就诞生了接下来要提到的两个类。 StringBuilderStringBuilder是一个比String类更好的类，每次对StringBuilder对象进行操作的时候，不会产生新的对象，是可变的对象。 12StringBuilder stringBuilder = new StringBuilder();stringBuilder.append(Object object); 但是StringBuilder对象不是线程安全的，虽然说这样去操作字符串速度很快， 但是由于不是线程安全的，因此我们不建议在多线程并发操作的情况下使用。 StringBufferStringBuffer对象仍然是可变的，对字符串对象操作时，不会开辟新的内存空间。 与StringBuilder相比，StringBuffer是线程安全的，但是StringBuffer相对较慢，同步总比异步慢。 因此，我们在使用多线程的时候，因为考虑到线程同步问题，并发问题时，可以选择使用StringBuffer。","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"Mybatis-plus学习笔记","slug":"Mybatis","date":"2021-09-26T11:37:23.000Z","updated":"2021-11-09T07:53:30.204Z","comments":true,"path":"Mybatis/","link":"","permalink":"https://github.com/Vincent990413/blog/Mybatis/","excerpt":"","text":"部分代码FROM SIKI学院 Mybatis是什么？ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code， 并且改名为MyBatis 。2013年11月迁移到Github。MyBatis是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。总而言之MyBatis是一个轻量级简化数据库操作的框架。 Mybatis架构 Mybatis的配置文件（包括数据库连接，MapperXML配置文件位置）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 读取数据库连接的配置文件 --&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;!-- 推荐使用package包的形式来配置别名 包的形式会扫描主包及子包下的所有文件 以对象类名为别名，大小写不限，推荐使用小写 --&gt; &lt;typeAliases&gt; &lt;!-- &lt;typeAlias type=&quot;com.sikiedu.bean.User&quot; alias=&quot;user&quot;/&gt; --&gt; &lt;package name=&quot;com.sikiedu.bean&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 在集成spring 不用environments这个property --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc的事务 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 使用连接池 连接数据库 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 注意下面的jdbc.driver在文件db.properties中: --&gt; &lt;!-- 写法是：jdbc.driver=com.mysql.jdbc.Driver --&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射器配置文件 XXX.xml 的位置 --&gt; &lt;mappers&gt; &lt;!-- &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; --&gt; &lt;!-- &lt;mapper url=&quot;file:\\\\\\D:\\Work\\Siki_edu\\JavaEE\\Teach\\SSM框架\\ssm_project\\ssm_mybatis\\src\\mapper\\UserMapper.xml&quot;/&gt; --&gt; &lt;!-- &lt;mapper class=&quot;com.sikiedu.mapper.UserMapper&quot;/&gt; --&gt; &lt;!-- 推荐使用包的形式配置 --&gt; &lt;package name=&quot;com.sikiedu.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 注意：当使用&lt;package/&gt;标签时 映射接口文件与映射配置文件共同应该在Mapper文件夹下 否则使用mapper标签 且用resource指定对应的配置文件所在目录 Mybatis某个映射接口文件以及对应的XML文件（比如UserMapper.java &amp; UserMapper.xml)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 注意域名namespace不要写错 相当于自己地址 --&gt;&lt;mapper namespace=&quot;com.sikiedu.mapper.UserMapper&quot;&gt; &lt;sql id=&quot;myselect&quot;&gt; SELECT * FROM user &lt;/sql&gt; &lt;!-- 根据id查询用户 --&gt; &lt;!-- 注意! 标签中的id属性值,必须与对应Mapper接口文件中的方法名一致!!! --&gt; &lt;select id=&quot;selectUserById&quot; parameterType=&quot;Integer&quot; resultType=&quot;user&quot;&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 根据名字模糊查询用户 --&gt; &lt;!-- #&#123;&#125; 占位符 尽量选用#&#123;&#125;来解决问题 &#x27;1&#x27; &#x27;王&#x27;--&gt; &lt;!-- $&#123;&#125; 字符串拼接 or 1=1 王 --&gt; &lt;!-- order by $&#123;&#125; --&gt; &lt;select id=&quot;selectUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;com.sikiedu.bean.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE u_username LIKE &#x27;%$&#123;value&#125;%&#x27; --&gt; SELECT * FROM USER WHERE u_username LIKE &quot;%&quot;#&#123;name&#125;&quot;%&quot; &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.sikiedu.bean.User&quot;&gt; insert into user values( null, #&#123;u_username&#125; , #&#123;u_password&#125;, #&#123;u_sex&#125;, #&#123;u_createTime&#125;, #&#123;u_cid&#125; ) &lt;/insert&gt; &lt;!-- 修改用户 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.sikiedu.bean.User&quot; &gt; update user set u_username = #&#123;u_username&#125; where u_id = #&#123;u_id&#125; &lt;/update&gt; &lt;!-- 根据id删除用户 --&gt; &lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;Integer&quot;&gt; delete from user Where u_id = #&#123;id&#125; &lt;/delete&gt; &lt;select id=&quot;selectUserByUserVoId&quot; parameterType=&quot;UserVo&quot; resultType=&quot;user&quot;&gt; select * from user where u_id = #&#123;user.u_id&#125; &lt;/select&gt; &lt;!-- public Integer selectUserCount(); --&gt; &lt;select id=&quot;selectUserCount&quot; resultType=&quot;Integer&quot;&gt; Select Count(*) from user &lt;/select&gt; &lt;!-- public List&lt;UserVo&gt; selectAllUserVo(); //查询所有用户包装类 --&gt; &lt;resultMap type=&quot;UserVo&quot; id=&quot;uservolist&quot;&gt; &lt;id property=&quot;u_id&quot; column=&quot;u_id&quot;/&gt; &lt;result property=&quot;u_username&quot; column=&quot;u_username&quot;/&gt; &lt;result property=&quot;u_sex&quot; column=&quot;u_sex&quot;/&gt; &lt;association property=&quot;country&quot; javaType=&quot;Country&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt; &lt;result property=&quot;c_countryname&quot; column=&quot;c_countryname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectAllUserVo&quot; resultMap=&quot;uservolist&quot;&gt; SELECT u.`u_id`, u.`u_username`, u.`u_sex`, c.`c_id`, c.`c_countryname` FROM USER u LEFT JOIN country c ON u.`u_cid`=c.`c_id` &lt;/select&gt; &lt;!-- //多条件查询 通过用户对象中的条件查询用户列表 public List&lt;User&gt; selectUserListByUser(User u); --&gt; &lt;select id=&quot;selectUserListByUser&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍ID --&gt; SELECT * FROM user &lt;where&gt; &lt;!-- where标签可以去掉开头的AND --&gt; &lt;if test=&quot;u_sex != null and u_sex != &#x27;&#x27;&quot;&gt; AND u_sex = #&#123;u_sex&#125; &lt;/if&gt; &lt;if test=&quot;u_username != null and u_username != &#x27;&#x27;&quot;&gt; AND u_username like &quot;%&quot;#&#123;u_username&#125;&quot;%&quot; &lt;/if&gt; &lt;if test=&quot;u_cid != null&quot;&gt; AND u_cid = #&#123;u_cid&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;selectUserListByUserTrim&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍ID --&gt; SELECT * FROM user &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;AND&quot;&gt; &lt;!-- where标签可以去掉开头的AND --&gt; &lt;if test=&quot;u_sex != null and u_sex != &#x27;&#x27;&quot;&gt; u_sex = #&#123;u_sex&#125; AND &lt;/if&gt; &lt;if test=&quot;u_username != null and u_username != &#x27;&#x27;&quot;&gt; u_username like &quot;%&quot;#&#123;u_username&#125;&quot;%&quot; AND &lt;/if&gt; &lt;if test=&quot;u_cid != null&quot;&gt; u_cid = #&#123;u_cid&#125; AND &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!-- public void updateSetUser(User u); --&gt; &lt;update id=&quot;updateSetUser&quot; parameterType=&quot;User&quot;&gt; &lt;!-- 用户名 用户密码 性别 用id来限制 --&gt; update user &lt;set&gt; &lt;if test=&quot;u_username != null and u_username != &#x27;&#x27;&quot;&gt; u_username = #&#123;u_username&#125;, &lt;/if&gt; &lt;if test=&quot;u_password != null and u_password != &#x27;&#x27;&quot;&gt; u_password = #&#123;u_password&#125;, &lt;/if&gt; &lt;if test=&quot;u_sex != null and u_sex != &#x27;&#x27;&quot;&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; &lt;/set&gt; Where u_id = #&#123;u_id&#125; &lt;/update&gt; &lt;!-- //使用多个id获取用户列表 public List&lt;User&gt; selectUserListByIds(); (1, 3, 5)--&gt; &lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;User&quot;&gt; SELECT * FROM USER WHERE u_id IN &lt;!-- (1,2,3) --&gt; &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;!-- //使用多个id获取用户列表 public List&lt;User&gt; selectUserListByIds(); (1, 3, 5)--&gt; &lt;select id=&quot;selectUserListByList&quot; resultType=&quot;User&quot;&gt; SELECT * FROM USER WHERE u_id IN &lt;!-- (1,2,3) --&gt; &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;!-- List&lt;User&gt; selectUserByVo(CountryVo vo); --&gt; &lt;select id=&quot;selectUserByVo&quot; parameterType=&quot;CountryVo&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;myselect&quot;/&gt; WHERE u_id IN &lt;!-- (1,2,3) --&gt; &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;!-- //使用多个id获取用户列表 by userVO public List&lt;User&gt; selectUserListByUserVo(UserVo vo); --&gt; &lt;select id=&quot;selectUserListByUserVo&quot; parameterType=&quot;UserVo&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;myselect&quot;/&gt; WHERE u_id IN &lt;!-- (1,2,3) --&gt; &lt;foreach collection=&quot;idList&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;/mapper&gt; 在Mybatis中的（XXXMapper.xml）映射文件中需要注意的事项 namespace 代表该映射文件的域名地址 不要填错 select标签中的id 必须与对应Mapper.java文件中的方法名一致！！！ parameterType 代表接口中方法的形参类型 要一致 resultType代表返回类型，以下两者均可 要一致（com.sikiedu.bean.User是全称）（user是Mybatis配置文件中配置好的 TypeAlias起的别名） 具体的SQL语句中 #{x} 的x代表UserMapper接口文件中形参名 要一致 UserMapper.java文件（映射接口文件）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.sikiedu.mapper;import java.util.List;import com.sikiedu.bean.User;import com.sikiedu.bean.UserVo;public interface UserMapper &#123; //mapper动态代理开发四大原则 + 一个注意 //1、接口方法名需要与mapper.xml的要调用的sql语句的id一致 //2、接口的形参类型需要与mapper.xml parameterType 一致 //3、接口的返回值需要与mapper.xml resultType一致 //4、mapper.xml 中namespace要与接口的全包名一致 //5、注意mapper动态代理开发中，根据返回值类型来自动选择 //通过id查询一个用户 public User selectUserById(Integer id); //通过用户名模糊查询 获取用户列表 public List&lt;User&gt; selectUserByName(String name); //通过UserVo id查询一个用户 public User selectUserByUserVoId(UserVo vo); //查询用户总条数 public Integer selectUserCount(); //查询所有用户包装类 public List&lt;UserVo&gt; selectAllUserVo(); //多条件查询 通过用户对象中的条件查询用户列表 public List&lt;User&gt; selectUserListByUser(User u); //多条件查询 通过用户对象中的条件查询用户列表Trim public List&lt;User&gt; selectUserListByUserTrim(User u); //更新用户表 public void updateSetUser(User u); //使用多个id获取用户列表 by array public List&lt;User&gt; selectUserListByIds(Integer[] ids); //使用多个id获取用户列表 by list public List&lt;User&gt; selectUserListByList(List&lt;Integer&gt; idList); //使用多个id获取用户列表 by userVO public List&lt;User&gt; selectUserListByUserVo(UserVo vo);&#125; 与数据库中相对应的实体类文件（XXX.java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.sikiedu.bean;import java.util.Date;public class User &#123; /** * CREATE TABLE `user` ( `u_id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `u_username` VARCHAR(64) NOT NULL COMMENT &#x27;用户名&#x27;, `u_password` VARCHAR(64) NOT NULL COMMENT &#x27;用户密码&#x27;, `u_sex` VARCHAR(16) DEFAULT NULL COMMENT &#x27;用户性别&#x27;, `u_createTime` DATETIME DEFAULT NULL COMMENT &#x27;用户创建时间&#x27;, `u_cid` INT(11) NOT NULL COMMENT &#x27;用户国家id&#x27;, */ private Integer u_id; private String u_username; private String u_password; private String u_sex; private Date u_createTime; private Integer u_cid; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public String getU_sex() &#123; return u_sex; &#125; public void setU_sex(String u_sex) &#123; this.u_sex = u_sex; &#125; public Date getU_createTime() &#123; return u_createTime; &#125; public void setU_createTime(Date u_createTime) &#123; this.u_createTime = u_createTime; &#125; public Integer getU_cid() &#123; return u_cid; &#125; public void setU_cid(Integer u_cid) &#123; this.u_cid = u_cid; &#125; @Override public String toString() &#123; return &quot;User [u_id=&quot; + u_id + &quot;, u_username=&quot; + u_username + &quot;, u_password=&quot; + u_password + &quot;, u_sex=&quot; + u_sex + &quot;, u_createTime=&quot; + u_createTime + &quot;, u_cid=&quot; + u_cid + &quot;]&quot;; &#125;&#125; 推荐类名的私有变量的名字完全与数据库中字段名相同 给相应Set、Get方法即可 toString方法 函数如何调用完整的Mybatis过程(增删改查)一、selectOne 函数（查询）12345678910111213141516171819202122@Test//入门程序 通过ID 查询用户public void Test1() throws IOException &#123; String resource = &quot;sqlMapConfig.xml&quot;; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionfactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1：要操作的接口方法 参数2 sql语句的参数 User user = session.selectOne(&quot;UserMapper.selectUserById&quot;, 1); System.out.println(user);&#125; 二、session的getMapper方法 找到Dao层接口类（查询）12345678910111213141516171819202122String resource = &quot;sqlMapConfig.xml&quot;;//读取配置文件InputStream in = Resources.getResourceAsStream(resource);//需要sqlSessionFactoryBuliderSqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();//创建sqlSessionfactorySqlSessionFactory ssf = ssfb.build(in);//将IUser加入工厂中 以getMapper找到sqlSessionFactory.getConfiguration().addMapper(IUser.class);SqlSession session = sqlSessionFactory.openSession(); try &#123; //通过getMapper方法 找到IUser接口类 IUser iuser = session.getMapper(IUser.class); //调用相应方法（增删改查） User user = iuser.getUserByID(1); System.out.println(&quot;名字：&quot;+user.getName()); &#125; finally &#123; session.close(); &#125; Mybatis的调用过程中： 首先需要输入流 读取配置文件sqlMapConfig.xml 需要一个工厂建造者Builder 来利用这个输入流建造 建造返回一个工厂 用这个工厂打开一次会话 在会话中Select...等等 对于更改操作（插入、更新、删除）记得session.commit() session的对应方法 第一个参数是通过XXXMapper.对应方法 第二个是传入的实参 三、session的getMapper方法 找到Dao层接口类（插入）123456789101112131415161718....忽略配置文件加载、SQLSession建造者、工厂....try &#123; //通过getMapper方法 找到IUser接口类 IUser iuser = session.getMapper(IUser.class); //假设该接口类有 void方法insertUser(User user) User user = new User(); user.setXXX(&quot;xxx&quot;); ...set方法 //插入数据 记得提交会话（包括删除操作、更新操作） iuser.insertUser(user); session.commit(); &#125; finally &#123; session.close();&#125; 四、session的getMapper方法 找到Dao层接口类（更新）1234567891011121314151617181920....忽略配置文件加载、SQLSession建造者、工厂....try &#123; //通过getMapper方法 找到IUser接口类 IUser iuser = session.getMapper(IUser.class); //首先通过相应属性找到user User user = iuser.getUserById(1); //假设该接口类有 void方法updateUser(User user) //将user的name更改为Vincent user.setName(&quot;Vincent&quot;); //更新数据 记得提交会话 iuser.updateUser(user); session.commit(); &#125; finally &#123; session.close();&#125; 五、session的getMapper方法 找到Dao层接口类（删除）123456789101112131415161718....忽略配置文件加载、SQLSession建造者、工厂....try &#123; //通过getMapper方法 找到IUser接口类 IUser iuser = session.getMapper(IUser.class); //首先通过相应属性找到user User user = iuser.getUserById(1); //假设该接口类有方法 deleteUser(User user) //记得提交会话 iuser.deleteUser(user); session.commit(); &#125; finally &#123; session.close();&#125; ResultMap：解决数据库字段与Java实体类的属性不一致问题1.Result实现JavaBean对象与数据库column名字不一样的映射12345678910&lt;!-- type表示具体的Java类 id随便取-唯一标识即可 --&gt;&lt;resultMap type=&quot;CountryVo&quot; id=&quot;countryVo&quot;&gt; &lt;!-- id标签是主键 property是Java类中的属性 column是对应Java类在数据库表中的字段 --&gt; &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt; &lt;!-- result可以是若干个其他 非主键属性的对应 --&gt; &lt;result property=&quot;c_countryname&quot; column=&quot;c_countryname&quot;/&gt; &lt;result property=&quot;c_capital&quot; column=&quot;c_capital&quot;/&gt;&lt;/resultMap&gt; 2.Result实现一对多映射 Collection比如一个用户User 有多个帖子Post现在查询对应的User 查看这个User下的所有帖子（因此帖子是集合java private List&lt;Post&gt; posts;) 1.User类 123456789101112//要实现序列化Serializablepublic class User implements Serializable&#123; private int id; private String username; private String mobile; //一个User 对应多个Post 因此用集合 private List&lt;Post&gt; posts; ...忽略set get方法以及toString方法&#125; 2.Post类 12345678public class Post implements Serializable&#123; //查询的时候 post.id 应该等于 user.id private int id; private User user; private String title; private String content; ...忽略set get方法以及toString方法&#125; 3.ResultMap配置一个用户多个帖子的映射 12345678910111213&lt;!-- 在一个User中配置 多个collection --&gt;&lt;resultMap type=&quot;User&quot; id=&quot;resultUserMap&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;user_id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt; &lt;result property=&quot;mobile&quot; column=&quot;mobile&quot; /&gt; &lt;!-- collection代表多 --&gt; &lt;!-- posts代表User类中 集合的名字！column代表post表中的那个字段 与user联系 --&gt; &lt;collection property=&quot;posts&quot; ofType=&quot;com.yiibai.pojo.Post&quot; column=&quot;userid&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;post_id&quot; javaType=&quot;int&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result property=&quot;title&quot; column=&quot;title&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;content&quot; column=&quot;content&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 4.SQL语句 12345678&lt;!-- 指定结果映射为resultUserMap 需要跟相应resultMap标签的id相同 --&gt;&lt;select id=&quot;getUser&quot; resultMap=&quot;resultUserMap&quot; parameterType=&quot;int&quot;&gt; &lt;!-- 建立映射就是为了 能够映射SELECT后面的内容:u.*, p.* --&gt; &lt;!-- 没有建立映射的property返回的值不会显示在后台里 --&gt; SELECT u.*,p.* FROM user u, post p WHERE u.id=p.userid AND id=#&#123;user_id&#125; &lt;/select&gt; 2021.4.6更新： 注意都实现Serializable接口 注意，如果两张表中的字段重复了，记得在Select字段中起别名 collection中的id标签 不会指两者映射的id 而只是指这个表的主键！ 真正映射一对多的 是collection中的column属性 起别名代码： 123456&lt;select&gt; select u.id as u_id, u.*, p.id as p_id,p.* from user u, post p where u.u_id = p.p_id AND u.u_id = #&#123;id&#125;&lt;/select&gt; Mybatis_plust新特性：代码生成器注意，这里的代码指的是： 1. DAO层的XXXMapper.java接口2. DAO层的XXXMapper.xml文件3. Model层的XXXExample.java类 方便提前处理数据 1.需要的插件（IDEA右侧 MAVEN里面的插件双击启动）12345678910&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/mybatis-generator/generatorConfig.xml &lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt;&lt;/plugin&gt; 项目结构图： 2.配置文件 generatorConfig.xml这一步很关键，要避免多次生成重复的BaseResultMap 注意对应Mapper.java/ Mapper.xml在项目结构图中的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- 连接数据库jar包的路径--&gt; &lt;classPathEntry location=&quot;C:\\Users\\Administrator\\.m2\\repository\\mysql\\mysql-connector-java\\8.0.23/mysql-connector-java-8.0.23.jar&quot;/&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接参数 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/vue_demo?serverTimezone=UTC&amp;amp;useSSL=true&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;!-- 避免生成重复的BaseResultMap --&gt; &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 实体类的包名和存放路径 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.example.demo.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件*.xml的位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mybatis&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.example.demo.repository&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- tableName：数据库中的表名或视图名；domainObjectName：生成的实体类的类名--&gt; &lt;!--&lt;table tableName=&quot;book&quot; domainObjectName=&quot;Book&quot;/&gt;--&gt; &lt;table schema=&quot;catalog&quot; tableName=&quot;user&quot; domainObjectName=&quot;User&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; Mybatis中出现的问题：1.UserMapper.xml到底应该放在那里？注意，在集成SpringBoot时 首先确保 UserMapper.java要有@Mapper注解 其次，要注意在SpringBoot配置文件application.yml中： 12mybatis: mapper-locations: classpath:mybatis/*.xml 并且项目结构图如下： UserMapper.xml中的namespace是UserMapper.java的具体位置 或者代码generator生成的配置文件中配置 12&lt;mapper namespace=&quot;com.example.demo.repository.UserMapper&quot;&gt; &lt;/mapper&gt; 配置实体类应该注意的问题1. 尽量让实体类中的各个private属性名字与数据库的字段名字相同 2. 用封装类！不要用int，而是应该用Integer 3. 如果实体类中的属性名与数据库中的字段名相同，这样mapper中参数为实体类时，才能返回 Mybatis-Plus 学习笔记 在已经学了Mybatis的基础上，我们可以学习Mybatis-Plus，这是对Mybatis的扩展，但不会修改已知的内容。 官网地址：https://mp.baomidou.com/ 依赖地址123456&lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 注意，在引用了Mybatis-Plus之后，不要再引用Mybatis或者Mybatis-Spring，以避免因版本差异导致的问题。 MP的配置SSM项目配置方式我们知道，对于SSM项目，我们一般使用xml配置来完成各种Bean对象的注入。 1234&lt;!-- Mapper扫描器配置 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;/&gt;&lt;/bean&gt; 1 SpringBoot项目配置方式使用@MapperScan注解即可。 1234567@SpringBootApplication@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)public class Application&#123; public static void main(String[] args)&#123; SpringApplication.run(Application.class, args); &#125;&#125; 注解@TableName显式指定实体类在表中，所对应的表名。 @TableId主键注解，有value与type两个属性： AUTO:数据库ID自增 @TableFieldvalue属性显式指定该属性在表中对应的字段， 代码生成器AutoGenerator引用依赖1234567891011121314151617181920 &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 注意MySQL版本是8.0版本 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 注意：MyBatis-Plus 的默认模板引擎是使用 Velocity，如果你选择了非默认引擎，需要在 AutoGenerator 中 设置模板引擎。 编写配置SpringBoot数据库配置application.properties 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/mp_auto_book_generator?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=123456 其中数据库表的结构如下图: 数据库结构对自定义数据库表字段与实体属性映射有用。 后台项目结构图如下：同理，项目结构图对配置各个自动生成的代码：包括Mapper（接口与XML），Service（以及对应实现层），Controller与Entity实体类有用。 自动配置Java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 @Test public void run() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); // 此处建议写项目/src/main/java源代码的绝对路径 //C:\\Users\\Administrator.000\\Documents\\mp_auto_generator gc.setOutputDir(&quot;C:\\\\Users\\\\Administrator.000\\\\Documents\\\\mp_auto_generator&quot; + &quot;/src/main/java&quot;); // 生成注释时的作者 gc.setAuthor(&quot;author&quot;); //生成后是否打开资源管理器 gc.setOpen(false); gc.setFileOverride(false); //重新生成时文件是否覆盖 gc.setServiceName(&quot;%sService&quot;); //去掉Service接口的首字母I gc.setIdType(IdType.ID_WORKER_STR); //主键策略 gc.setDateType(DateType.ONLY_DATE); //定义生成的实体类中日期类型 // 如果开启Swagger,要引入相应的包 // gc.setSwagger2(true); //开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/mp_auto_book_generator?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=UTF-8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123456&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); // 此处要注意：parent + moduleName 为包的名字，在这个包下，创建对应的controller... pc.setParent(&quot;com.example.mp_auto_generator&quot;);// pc.setModuleName(&quot;mp_auto_generator&quot;); //模块名 pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); // 数据库中表的名字，表示要对哪些表进行自动生成controller service、mapper... //...tables &quot;a&quot;, &quot;b&quot; strategy.setInclude(&quot;basic_book&quot;); // 数据库表映射到实体的命名策略,驼峰命名法 比如basic_book变成BasicBook strategy.setNaming(NamingStrategy.underline_to_camel); // 生成实体时去掉表前缀，比如edu_course，如果不加下面这句，生成的实体类名字就是：EduCourse strategy.setTablePrefix(&quot;basic_&quot;); //数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125; 执行代码后，会生成相应的文件，项目结构如下： XML文件地址配置1mybatis-plus.mapper-locations=com.example.mp_auto_generator.mapper.xml.*.xml 1234567891011&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; Mapper接口文件没有@mapper注解而仍需要注入Spring仓库这里要提到两个注解，一个是@Resource，另一个是@Autowired。 这两个注解，都是用来将组件注入到仓库中。 只不过，在使用@Autowired注解时，并且要求这个组件存在，则我们需要@mapper注解。 但是，由于是自动生成的mapper文件，默认没有@mapper注解。 因此，我们需要使用@Resource来标识这是一个需要注入到Spring仓库中的组件。 在服务实现层的代码中：BookServiceImpl.java 123//注意Autowired注解与Resource的联系@Resourceprivate BookMapper bookMapper; CRUD Service接口的方法插入123456//根据记录的字段 策略插入 如果是主键自增策略 //那么会在表末尾新增一条数据boolean save(T entity); //批量插入，第二个参数也可以是插入的数量boolean saveBatch(Collection&lt;T&gt; entityList); 如果TableId 注解对应的字段存在则更新记录 否插入一条记录. 1boolean saveOrUpdate(T entity); 删除12345678// 根据 entity 条件，删除记录boolean remove(Wrapper&lt;T&gt; queryWrapper);// 根据 ID 删除boolean removeById(Serializable id);// 根据 columnMap 条件，删除记录boolean removeByMap(Map&lt;String, Object&gt; columnMap);// 删除（根据ID 批量删除）boolean removeByIds(Collection&lt;? extends Serializable&gt; idList); 测试代码： 123456789101112131415161718//通过id删除bookService.removeById(1);//通过条件查询器删除bookService.remove(new QueryWrapper&lt;Book&gt;().lambda().eq(Book::getId, 2));//通过与数据库字段映射的Map删除Map&lt;String ,Object&gt; deleteMap = new HashMap&lt;&gt;();deleteMap.put(&quot;book_id&quot;, &quot;6a81c8ed-809b-4171-807f-16a14894bf17&quot;);deleteMap.put(&quot;book_desc&quot;, &quot;四大名著之首&quot;);bookService.removeByMap(deleteMap);//通过包含若干个id的列表删除List&lt;Integer&gt; idList = new ArrayList&lt;&gt;();idList.add(1);idList.add(2);bookService.removeByIds(idList); 更新12345678910// 根据 UpdateWrapper 条件，更新记录 需要设置sqlsetboolean update(Wrapper&lt;T&gt; updateWrapper);// 根据 whereWrapper 条件，更新记录boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);// 根据 ID 选择修改boolean updateById(T entity);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize); 测试代码： 1234567891011121314Book book = bookService.getById(3);book.setBookDesc(&quot;test&quot;);//前提是book对象的id属性存在bookService.updateById(book);//注意，UpdateWrapper会将表中所有涉及的字段改变Book book = bookService.getById(3);bookService.update(book, new UpdateWrapper&lt;Book&gt;().lambda().set(Book::getBookDesc, &quot;test1&quot;));//有where条件的改变字段LambdaQueryWrapper&lt;Book&gt; lambdaQueryWrapper = new QueryWrapper&lt;Book&gt;().lambda().eq(Book::getBookDesc, &quot;test2&quot;);Book book = bookService.getOne(lambdaQueryWrapper);book.setBookDesc(&quot;test1&quot;);bookService.update(book, lambdaQueryWrapper); 查询12345678// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper); 测试代码： 1bookService.getOne(new QueryWrapper&lt;Book&gt;().lambda().eq(Book::getId, 1) 分页12345678// 无条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);// 无条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper); IPage是对应T对象分页的分页对象。 Service接口查询测试代码： 12345IPage&lt;Book&gt; pageBook = new Page&lt;&gt;(1, 1);IPage&lt;Book&gt; page = bookService.page(pageBook, null);for (Book record : page.getRecords()) &#123; System.out.println(record);&#125; Mapper接口查询测试代码： 1 统计1234// 查询总记录数int count();// 根据 Wrapper 条件，查询总记录数int count(Wrapper&lt;T&gt; queryWrapper); 链式查询12345678// 链式查询 普通QueryChainWrapper&lt;T&gt; query();// 链式查询 lambda 式。注意：不支持 KotlinLambdaQueryChainWrapper&lt;T&gt; lambdaQuery(); // 示例：query().eq(&quot;column&quot;, value).one();lambdaQuery().eq(Entity::getId, value).list(); 链式更改12345678// 链式更改 普通UpdateChainWrapper&lt;T&gt; update();// 链式更改 lambda 式。注意：不支持 Kotlin LambdaUpdateChainWrapper&lt;T&gt; lambdaUpdate();// 示例：update().eq(&quot;column&quot;, value).remove();lambdaUpdate().eq(Entity::getId, value).update(entity); Mapper接口CRUD插入12//插入一条记录int insert(T entity); 测试代码： 12345Book book = new Book();book.setBookId(new Random().toString());book.setBookName(&quot;书名&quot;);book.setBookDesc(&quot;描述&quot;);bookMapper.insert(book); 删除12345678// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 更新1234// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改int updateById(@Param(Constants.ENTITY) T entity); 查询12345678910111213141516171819202122// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意：只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);","categories":[{"name":"SSM学习笔记","slug":"ssm学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/ssm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SSM学习笔记","slug":"ssm学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/ssm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"ElasticSearch学习笔记","slug":"ElasticSearch学习笔记","date":"2021-09-01T05:34:32.000Z","updated":"2021-11-09T07:53:30.183Z","comments":true,"path":"ElasticSearch学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/ElasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"ElasticSearch 简介 Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 实现原理主要分为以下几个步骤: 首先用户将数据提交到Elasticsearch数据库中。 再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据。 当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。 安装与运行在运行之前，确保项目的JDK环境至少是1.8。 安装并运行ES进入ElasticSearch官网进行下载 首先我们需要更改config目录下的JVM配置与es.yml配置： 修改这个文件是为了，让ES与ES-HEAD结合起来。由于二者处在不同的端口，因此需要解决跨域问题。 elasticsearch.yml 12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 同时修改启动参数，不然内存消耗过重：jvm.options 12-Xms128m-Xmx256m ==双击bin目录下的elasticsearch.bat== 等启动完成之后，在浏览器地址栏中输入： 1http://localhost:9200/ 如果成功，可以看到以下数据： 1234567891011121314151617&#123; &quot;name&quot; : &quot;WIN-MJ212T4U8FB&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;JflwRkJzRZGsFGnVtqPv5w&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.14.0&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;zip&quot;, &quot;build_hash&quot; : &quot;dd5a0a2acaa2045ff9624f3729fc8a6f40835aa1&quot;, &quot;build_date&quot; : &quot;2021-07-29T20:49:32.864135063Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.9.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 安装与运行ES-Head可视化进入Github下载页面 确保运行之前，有Node后台环境。 12345cd elasticsearch-headnpm installnpm run start 如果成功运行，在浏览器地址栏中输入： 1http://localhost:9100/ 查看ES配置信息与索引我们可以在ES-HEAD（9100）的主页看到有概览，索引信息。 但值得注意的是，我们一般不用HEAD来查询，而是用接下来要用到的Kibana用来数据分析。 对于初学，我们可以将索引看成是数据库。里面有若干个字段，这些是数据。 安装与运行KibanaKibana是一款真正的数据可视化分析框架，注意我们安装的版本要与ES的版本对应。 点我进入Kibana安装页面 文件大小有400多M 进入bin目录打开Kibana.bat 1http://localhost:5601 ES核心概念 ElasticSearch是面向document文档的，类似MongoDB。而MySQL是面向关系型的表。在ES中，一切都是JSON数据。 关系型数据库 ElasticSearch 数据库 databases 索引 index 表 tables 类型映射 types 行 rows 文档 documents 字段 columns 域 fields ES在后台把每个索引都划分为若干个分片，每个分片可以在不同集群中部署。默认的集群名称为elasticsearch。 Type类型是文档的逻辑器映射，如果不设置的话，ES会根据每条文档数据，自己去猜。比如age，类型会猜成int类型。 而一个集群至少有一个节点，一个节点就是一个ES进程。节点可以有多个默认的索引，如果创建索引，那么默认索引会有5个分片（又称为主分片，Primary Shard），每一个主分片会有一个副本（Repica Shard）。 倒排索引：我们将每个文档中的每条数据都放入一个集合中，这些数据都是不重复的，并且，标明这些数据可能出现的地方。建成一个索引，下次我们就可以根据对应的地方去找即可。 比如现在有两个文档，分别是： 123I love you, hello world! Hi, I love you! 就可以分为两个列表，分别为： 12345I loveyouhelloworld 1234HiIloveyou 如果我们需要搜索，Hi you 那么，我们只需要查看包含这个词条（Hi you）的列表，哪一个列表的权重（scores）更高？ 因为对于Hi，只有第二个列表有。而对于you，两个列表都有。 综合而言，Hi you，第二个列表的权重更高。 IK分词器 什么是分词概念？就是将一段中文/英文等，划分成一个个的关键字。在搜索的时候会把自己的信息进行分词，然后进行一个匹配操作。但默认的中文分词是将每个字都看成一个词。 比如，爱情公寓，会被划分为：爱，情，公，寓。 而这实际上会浪费我们搜索的时间，我们需要智能的中文IK分词器。提供以下两种算法：1、ik_max_word会将文本做最细粒度的拆分，比如会将华为手机拆分为：“华为”、“手机” 2、ik_smart会做最粗粒度的拆分，则会将华为手机拆分为“华为手机”。 安装elasticsearch-analysis-ik分词器地址 然后在ES的plugins目录下创建名为ik的文件夹。 解压分词器，并将所有文件（包括jar包）都复制粘贴到ik文件夹中。 然后启动ES，会发现之前的plugins not reload会变成plugin ik reloaded。 如果不确定，我们也可以通过：elasticsearch-plugin.bat来查看加载的插件。 Kibana测试打开Kibana控制台进行测试 GET请求 对奔跑吧兄弟这五个字分别使用ik_smart与ik_max_word两种算法，来获得对应分词结果： ik_smart结果12345GET _analyze&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;奔跑吧兄弟&quot;&#125; 结果： 12345678910111213141516171819202122232425&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;奔&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;跑吧&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 3, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;兄弟&quot;, &quot;start_offset&quot; : 3, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125; ]&#125; ik_max_word算法12345GET _analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;奔跑吧兄弟&quot;&#125; 结果： 12345678910111213141516171819202122232425&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;奔跑&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;跑吧&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 3, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;兄弟&quot;, &quot;start_offset&quot; : 3, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125; ]&#125; 现在比如我们要分解文森特，会发现两种算法的结果都为： 12345678910111213141516171819202122232425&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;文&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;森&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;特&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 3, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 2 &#125; ]&#125; 也就代表，并没有将文森特看成是一个词，但是如果在业务中，我们想要让他被解析成一个词。我们就可以自定义自己的字典。 在ik目录下的config目录。 我们可以看到很多个dic，我们可以在其中的xml文件中配置自己写好的my.dic自定义字典，首先写好字典。 并加入文森特作为一个新词。 然后在配置文件中配置： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 --&gt; &lt;entry key=&quot;ext_dict&quot;&gt;my.dic&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;&lt;/entry&gt; &lt;!--用户可以在这里配置远程扩展字典 --&gt; &lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt; &lt;!--用户可以在这里配置远程扩展停止词字典--&gt; &lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;&lt;/properties&gt; 现在我们可以重新启动elasticsearch，重新在Kibana中测试，文森特，结果为： 1234567891011&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;文森特&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 3, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 &#125; ]&#125; Restful命令操作 新建索引 PUT /索引名/类型名/文档id {JSON 请求参数} 12345PUT /test1/type1/1&#123; &quot;name&quot;: &quot;狂神说&quot;, &quot;age&quot;: 3&#125; 使用Kibana运行后，结果为： 1234567891011121314&#123; &quot;_index&quot; : &quot;test1&quot;, &quot;_type&quot; : &quot;type&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1&#125; 相当于给索引test1新增了一条数据： 1234567891011&#123;&quot;_index&quot;: &quot;test1&quot;,&quot;_type&quot;: &quot;type&quot;,&quot;_id&quot;: &quot;1&quot;,&quot;_version&quot;: 1,&quot;_score&quot;: 1,&quot;_source&quot;: &#123;&quot;name&quot;: &quot;文森特&quot;,&quot;age&quot;: 21&#125;&#125; 其实本质上就是建立了一个数据库，并且新插入了一条数据。 如果我们需要指定类型的话： 字符串类型：text与keyword（不可分割） 数值类型：integer、short、long、double、float等等 日期类型：date 布尔值类型：boolean 二进制类型：binary 不添加数据 而是指定映射规则 去指定字段的类型PUT就如同MySQL建库一样，不插入数据，而提前规定好数据的基本类型。 建立一个名为test2的索引，并规定每个字段类型： 12345678910111213141516PUT /test2&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;birthday&quot;:&#123; &quot;type&quot;: &quot;date&quot; &#125; &#125; &#125;&#125; 返回结果为： 12345&#123; &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;test2&quot;&#125; 现在我们可以去ES-HEAD中查看这个索引的结构了，会发现并没有新的数据插入进去。 获得某个索引的数据库信息GET1GET test2 得到结果为： 12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;test2&quot; : &#123; &quot;aliases&quot; : &#123; &#125;, &quot;mappings&quot; : &#123; &quot;properties&quot; : &#123; &quot;age&quot; : &#123; &quot;type&quot; : &quot;long&quot; &#125;, &quot;birthday&quot; : &#123; &quot;type&quot; : &quot;date&quot; &#125;, &quot;name&quot; : &#123; &quot;type&quot; : &quot;text&quot; &#125; &#125; &#125;, &quot;settings&quot; : &#123; &quot;index&quot; : &#123; &quot;routing&quot; : &#123; &quot;allocation&quot; : &#123; &quot;include&quot; : &#123; &quot;_tier_preference&quot; : &quot;data_content&quot; &#125; &#125; &#125;, &quot;number_of_shards&quot; : &quot;1&quot;, &quot;provided_name&quot; : &quot;test2&quot;, &quot;creation_date&quot; : &quot;1631320087224&quot;, &quot;number_of_replicas&quot; : &quot;1&quot;, &quot;uuid&quot; : &quot;ZRX2a7naRFalBZr_BWb1Nw&quot;, &quot;version&quot; : &#123; &quot;created&quot; : &quot;7140099&quot; &#125; &#125; &#125; &#125;&#125; 而如果文档没有指定类型，ES就会给我们默认配置字段的类型！ 扩展命令1GET _cat/indices?v 查看库中的各个信息 修改索引中的数据 put命令12345PUT /test3/_doc/1&#123; &quot;name&quot;:&quot;文森特123&quot;, &quot;age&quot;: 23&#125; 如果曾经的索引名为test3，那么就会发现旧数据直接被新数据所覆盖掉了。 但这样也存在一个弊端，即新数据完全覆盖掉旧数据的同时，可能会遗漏掉一些数据。如果不注意的话。 post命令加上_update即可 123456POST /test3/_doc/1/_update&#123; &quot;doc&quot;:&#123; &quot;name&quot;: &quot;文森特1234&quot; &#125;&#125; 删除索引1DELETE test3 123&#123; &quot;acknowledged&quot; : true&#125; 根据你的请求来判断是删除索引，还是精确地删除文档记录。 因此，我们推荐使用RESTful风格来使用ES。 关于文件的基本操作（重点）创建一个用户数据1234567PUT /vincent/user/1&#123; &quot;name&quot;: &quot;文森特&quot;, &quot;age&quot;: 22, &quot;desc&quot;: &quot;码农萌新&quot;, &quot;tags&quot;:[&quot;阳光&quot;, &quot;运动&quot;, &quot;IT&quot;, &quot;唱歌&quot;]&#125; 1234567891011121314&#123; &quot;_index&quot; : &quot;vincent&quot;, &quot;_type&quot; : &quot;user&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1&#125; 1234567PUT /vincent/user/2&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18, &quot;desc&quot;: &quot;法外狂徒&quot;, &quot;tags&quot;:[&quot;旅游&quot;, &quot;渣男&quot;]&#125; 1234567891011121314&#123; &quot;_index&quot; : &quot;vincent&quot;, &quot;_type&quot; : &quot;user&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 1&#125; 根据具体id值获取某个文档1get /vincent/user/2 根据put来更新数据时，version值代表所被改动的次数，result代表操作状态，比如时创建还是更新。 利用POST来更新数据在id后面加上_update并且&quot;doc&quot;{}中更新数据 123456POST vincent/user/2/_update&#123; &quot;doc&quot;:&#123; &quot;desc&quot;: &quot;不是法外狂徒&quot; &#125;&#125; 这样就只会改动，id为2的，desc这个字段的值。 条件查询 Get查询：我们可以解释为，在vincent数据库中的，user表中查找（_search?q=），姓名为vincent的数据。 包括模糊查找！！！ 1GET vincent/user/_search?q=name:文森 那么如果我们存储的name为文森特，这条数据也会被查找出来。 123456789101112131415161718192021222324252627282930313233343536&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.6407243, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;vincent&quot;, &quot;_type&quot; : &quot;user&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.6407243, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;文森特&quot;, &quot;age&quot; : 22, &quot;desc&quot; : &quot;码农萌新&quot;, &quot;tags&quot; : [ &quot;阳光&quot;, &quot;运动&quot;, &quot;IT&quot;, &quot;唱歌&quot; ] &#125; &#125; ] &#125;&#125; 复杂搜索(将查询条件写在JSON中)模糊查找 Match12345678GET vincent/user/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;文&quot; &#125; &#125;&#125; 上面的语句相当于: 1SELECT* FROM user WHERE name LIKE &#x27;%文%&#x27; 但是ES的这种查询，比传统关系型数据的MySQL查询更快，更复杂，查询的结果也更丰富。 接下来就是查询出来的信息。 其中hit中是索引和文档的信息，包括：查询的结果总数，查询出来的具体的文档数据以及文档数据中的具体字段信息。 同时数据，都是以Score权重由高到低排列出来的。Score分值越高，则代表数据的匹配度也越高。 123456789101112131415161718192021222324252627282930313233343536&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.6407243, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;vincent&quot;, &quot;_type&quot; : &quot;user&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.6407243, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;文森特&quot;, &quot;age&quot; : 22, &quot;desc&quot; : &quot;码农萌新&quot;, &quot;tags&quot; : [ &quot;阳光&quot;, &quot;运动&quot;, &quot;IT&quot;, &quot;唱歌&quot; ] &#125; &#125; ] &#125;&#125; 多条件查询1GET vincent/user/_search 指定查看若干个字段我们可以看到查询出来的Fields，默认是全部查询。我们当然可以指定，只查询几个字段，比如我们只需要查看name字段。可以通过数组 _source来指定查询的字段： 123456789GET vincent/user/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;文&quot; &#125; &#125;, &quot;_source&quot;:[&quot;name&quot;]&#125; 出现的结果，就只会留下name字段的所有符合结果的数据： 12345678910111213141516171819202122232425262728&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 1, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 0.6407243, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;vincent&quot;, &quot;_type&quot; : &quot;user&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 0.6407243, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;文森特&quot; &#125; &#125; ] &#125;&#125; 升/降序查看结果123456789101112131415GET vincent/user/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;文&quot; &#125; &#125;, &quot;sort&quot;:[ &#123; &quot;age&quot;:&#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125; ]&#125; 对若干个字段综合升序或者降序查询即可，Ascent，Descent。 分页查询12345678910GET vincent/user/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;文&quot; &#125; &#125;, &quot;from&quot;: 0, &quot;size&quot;: 1&#125; 其中from代表pageNumber，而size代表pageSize。 布尔值查询must 命令must命令相当于MySQL中的AND命令，如果有多个条件，那么多个条件都要符合。 12345678910111213141516171819GET vincent/user/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;张三&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;18&quot; &#125; &#125; ] &#125; &#125;&#125; 以上语句相当于： 1SELECT* FROM user WHERE name = &#x27;张三&#x27; AND age = 18 should 命令should命令相当于MySQL中的OR命令。 如果存在多个条件，只要满足一条即可。 12345678910111213141516171819GET vincent/user/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;: &#123; &quot;should&quot;: [ &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;张三&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;22&quot; &#125; &#125; ] &#125; &#125;&#125; must_not 命令must_not命令相当于MySQL中的NOT命令。 复杂的过滤器filterfilter一般是对于数字字段的过滤，包括gt大于，lt小于，gte大于等于，lte小于等于。 1234567891011121314151617181920212223GET vincent/user/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;张三&quot; &#125; &#125; ], &quot;filter&quot;: [ &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gt&quot;: 10 &#125; &#125; &#125; ] &#125; &#125;&#125; 精确查找term查询是直接通过倒排索引指定的词条进行精确查找的。 而match查找是使用分词器，解析的。即先分析文档，再查询。 Term精确查找12345678GET vincent/user/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;name&quot;: &quot;名字无法分割的张三&quot; &#125; &#125;&#125; 重要的两个类型Text与Keyword 注意，Keyword类型是不会被分词器解析的。 也就是说，Keyword会被看成一个词，而不会继续分开。 举个例子，现在我们规定一个索引，其中有name与desc两个域，而name域为text类型，desc为keyword类型，现在我们分别使用match与term两种不同类型的查询方式来查询这两条数据。 首先创建索引的字段映射12345678910111213PUT /dbtest&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;desc&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;&#125; 12345&#123; &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;dbtest&quot;&#125; 然后我们插入两条数据，其中类型为keyword的域，数据一定要有所区别。 1234567891011PUT dbtest/_doc/1&#123; &quot;name&quot;:&quot;张三&quot;, &quot;desc&quot;:&quot;不可分割的张三&quot;&#125;PUT dbtest/_doc/2&#123; &quot;name&quot;:&quot;李四&quot;, &quot;desc&quot;:&quot;不可分割的李四&quot;&#125; 接下来我们测试一下分别在精准查询term与match查询的情况下，字段类型为keyword的数据，是否是不可继续再分的。 就是说，如果我们查找不可分割，如果不可再分，那么我们将搜索到0条结果。 分别使用match与term查询，不可分割： 1234567891011121314151617GET dbtest/_doc/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;desc&quot;: &quot;不可分割&quot; &#125; &#125;&#125;GET dbtest/_doc/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;desc&quot;: &quot;不可分割&quot; &#125; &#125;&#125; 得到的结果都是： 123456789101112131415161718&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 0, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;&#125; 说明，如果一个字段的类型是keyword，那么查询的时候，整体会被当作是一条数据。 而不会具体被拆分！！！ 同时，我们如果查找不可分割的张三，出现的结果，就不会是不可分割的李四，如图： 精确查询多个值利用bool与should来查询满足条件的多个值。 12345678910111213141516171819GET dbtest/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;should&quot;:[ &#123; &quot;term&quot;:&#123; &quot;desc&quot;: &quot;不可分割的张三&quot; &#125; &#125;, &#123; &quot;term&quot;: &#123; &quot;desc&quot;: &quot;不可分割的李四&quot; &#125; &#125; ] &#125; &#125;&#125; 高亮查询 比如我们去某些电商项目，百度，搜索引擎搜索内容，关于这个内容会被高亮查询出来。 12345678910111213GET dbtest/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;李四&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123; &quot;name&quot;: &#123;&#125; &#125; &#125;&#125; 其中： 12345&quot;highlight&quot;:&#123; &quot;fields&quot;:&#123; &quot;name&quot;:&#123;&#125; &#125;&#125; 表示对name域进行高亮。 当然其他域，同理。 可以看到，图中的高亮都是由&lt;em&gt;标签完成，当然，我们可以通过指定自定义标签，来完成对高亮文字的样式。 123456789101112131415GET dbtest/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;李四&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;pre_tags&quot;: &quot;&lt;div class=&#x27;keyword&#x27;&gt;&quot;, &quot;post_tags&quot;: &quot;&lt;/div&gt;&quot;, &quot;fields&quot;: &#123; &quot;name&quot;: &#123;&#125; &#125; &#125;&#125; 这样，我们就可以对class为keyword的高亮文本单独设置样式。 ES集成SpringBoot打开网页查看ES各个客户端 并进入高级ES客户端。 创建SpringBoot项目并结合ES 首先利用IDEA创建一个空项目 新增模块，并选中Spring Initializer 选择以下依赖 修改依赖文件 注意，需要elasticsearch与自己的ES服务版本一致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;elasticsearch.version&gt;7.14.0&lt;/elasticsearch.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建ElasticSearchClientConfig配置文件1234567891011121314151617package com.elasticsearch.demo.config;/** * ES客户端的配置 */@Configurationpublic class ElasticSearchClientConfig &#123; @Bean public RestHighLevelClient restHighLevelClient()&#123; /** * 注意如果是集群 我们可以绑定多个ES服务器的地址 */ return new RestHighLevelClient( RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)) ); &#125;&#125; 测试基础索引的Api测试创建索引Api测试 我们需要注意，我们都是通过Request请求来完成增删改查的。因此，在Java中的Spring boot中，我们肯定有对应的对象，来充当相应的角色。 在SpringBoot中有一个类，充当客户端的对象，我们利用这个对象，来创建各个请求。 123//通过对象来执行请求@Autowiredprivate RestHighLevelClient restHighLevelClient; 12345678910111213/** * 创建索引 当然我们都是通过Request来请求的 */@Testpublic void createIndex() throws IOException &#123; //1. 创建索引请求 CreateIndexRequest createIndexRequest = new CreateIndexRequest(&quot;vincent_index&quot;); //2. 执行创建请求 使用默认参数 请求之后获得响应 CreateIndexResponse createIndexResponse = restHighLevelClient.indices().create(createIndexRequest, RequestOptions.DEFAULT); System.out.println(createIndexResponse);&#125; 执行代码后，我们可以通过ES-HEAD来查看对应的所有索引信息。 获取索引是否存在的Api测试 只能返回True或者False 123456789101112/** * 根据索引名查询某个索引是否存在 * @throws IOException */@Testpublic void queryIndex() throws IOException &#123; //1. 创建索引请求Get方法 GetIndexRequest createIndexRequest = new GetIndexRequest(&quot;vincent_index&quot;); boolean exists = restHighLevelClient.indices().exists(createIndexRequest, RequestOptions.DEFAULT); System.out.println((exists == true) ? &quot;该索引已存在！&quot; : &quot;该索引不存在！&quot;);&#125; 删除索引的Api测试123456789/** * 删除索引的Api测试 */@Testpublic void deleteIndex() throws IOException &#123; DeleteIndexRequest deleteIndexRequest = new DeleteIndexRequest(&quot;vincent_index&quot;); AcknowledgedResponse deleteAcknowledgedResponse = restHighLevelClient.indices().delete(deleteIndexRequest, RequestOptions.DEFAULT); System.out.println(( deleteAcknowledgedResponse.isAcknowledged() == true) ? &quot;该索引删除成功！&quot; : &quot;该索引删除失败！&quot;);&#125; 基础文档的基本操作通过实体类创建文档数据1. 实体类User.java 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String userName; private Integer userAge; private String userDesc;&#125; 2. 测试代码 123456789101112131415161718192021222324/** * 添加文档的Api测试 * 创建实体类User 来补充文档信息 */ @Test public void createDocument() throws IOException &#123; //插入的文档对象 User user = new User(&quot;张三&quot;, 18, &quot;这是一个很神秘的人！他并没有留下什么描述。&quot;); //指定插入的索引 IndexRequest indexRequest = new IndexRequest(&quot;vincent_index&quot;); //创建HTTP请求 PUT vincent_index/_doc/1 是Restful的写法 //高版本是不需要指定type的 默认是_doc indexRequest.id(&quot;1&quot;); indexRequest.timeout(TimeValue.timeValueSeconds(1)); //装入JSON对象数据 indexRequest.source(JSON.toJSONString(user), XContentType.JSON); //发送请求 并拿到结果 IndexResponse indexResponse = restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT); System.out.println(&quot;响应结果为：&quot; + indexResponse.toString() + &quot;,状态为：&quot; + indexResponse.status()); &#125; 我们可以得到结果： 123响应结果为：IndexResponse[index=vincent_index,type=_doc,id=1,version=1,result=created,seqNo=0,primaryTerm=1,shards=&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;]状态为：CREATED 3. 批量添加数据 新建一个BulkRequest，并添加一个IndexRequest，这个IndexRequest请求可以是添加请求、更改请求或者删除请求。1234567891011121314151617/** * 批量添加文档记录 */@Testpublic void addBatchDocument() throws IOException &#123; ArrayList&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(&quot;李易峰&quot;, 18, &quot;这是当红明星李易峰！&quot;)); userList.add(new User(&quot;王俊凯&quot;, 20, &quot;TFBOYS成员王俊凯！&quot;)); userList.add(new User(&quot;易烊千玺&quot;, 18, &quot;这是全能明星易烊千玺！&quot;)); BulkRequest bulkRequest = new BulkRequest(); for (int i = 0; i &lt; userList.size(); i++) &#123; //指定批量插入的索引 以及Id值 bulkRequest.add(new IndexRequest(&quot;vincent_index&quot;).id(&quot;&quot;+(i+1)).source(JSON.toJSONString(userList.get(i)),XContentType.JSON)); &#125; BulkResponse bulkResponse = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(&quot;批量插入状态：&quot; + bulkResponse.status());&#125; 当然，批量更改与批量删除同理。 根据索引名与ID值查询文档是否存在123456789101112/** * 根据索引名以及id 查询文档是否存在 */@Testpublic void isExistsDocument() throws IOException &#123; GetRequest getRequest = new GetRequest(&quot;vincent_index&quot;, &quot;1&quot;); //不获取返回的 _source数组的 上下文 getRequest.fetchSourceContext(new FetchSourceContext(false)); getRequest.storedFields(&quot;_none_&quot;); boolean exists = restHighLevelClient.exists(getRequest, RequestOptions.DEFAULT); System.out.println((exists == true) ? &quot;该文档已存在！&quot; : &quot;该文档不存在！&quot;);&#125; 根据索引名与ID值查询文档内容12345678910/** * 根据索引名与ID值 查询文档内容 */@Testpublic void queryDocument() throws IOException &#123; GetRequest getRequest = new GetRequest(&quot;vincent_index&quot;, &quot;1&quot;); GetResponse getResponse = restHighLevelClient.get(getRequest, RequestOptions.DEFAULT); System.out.println(getResponse.getSourceAsString());//打印文档中的内容 System.out.println(getResponse.getSource());//打印结果 包括index type version信息等等&#125; 根据索引名与ID值更新文档内容1234567891011121314/** * 根据索引名与ID值 更新文档内容 */@Testpublic void updateDocument() throws IOException &#123; UpdateRequest updateRequest = new UpdateRequest(&quot;vincent_index&quot;, &quot;1&quot;); updateRequest.timeout(TimeValue.timeValueSeconds(1)); User user = new User(); user.setUserName(&quot;李四&quot;); updateRequest.doc(JSON.toJSONString(user), XContentType.JSON); UpdateResponse updateResponse = restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT); System.out.println(updateResponse.status());&#125; 执行之后，结果为：之前的数据是：经过更新后，数据变为：可以看到，其他没有设置的属性，是不会被更改的。 删除文档的Api测试123456789/** * 删除文档记录 */@Testpublic void deleteDocument() throws IOException &#123; DeleteRequest deleteRequest = new DeleteRequest(&quot;vincent_index&quot;, &quot;1&quot;); DeleteResponse deleteResponse = restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT); System.out.println(deleteResponse.status());&#125; 复杂查询Term对中文字符串查询出现的问题利用Term来对字符串精确查找，注意！！！这里存在一个问题。 如果在索引中有这样一个文档数据： 1234&#123; &quot;userName&quot;:&quot;张三&quot;, &quot;userAge&quot; : 18&#125; 如果是对数值型数据精确查找，则不会出问题。 而如果是对中文字符串，使用精确查找，这样写的话，是有问题的！ 12345678GET vincent_index/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;userName&quot;: &quot;张三&quot; &#125; &#125;&#125; 我们想象中，可能会出现张三这条数据。但是结果却是： 123456789101112131415161718&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 0, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] &#125;&#125; 说明我们这样根本无法查找成功！ 为什么呢？因为，如果想通过term查到数据，那么term查询的字段在索引库中就必须有与term查询条件相同的索引词，否则无法查询到结果。 一句话解释： elasticsearch 里默认的IK分词器是会将每一个中文都进行了分词的切割，所以你直接想查一整个词，或者一整句话是无返回结果的。 上句话解释，引用于知乎用户Galaxyppah——巨坑！！！es之termQuery精确查询失效问题解决. 因此，如果我们利用搜索张或者三则是可以的，因为默认中文分词器，会将每句话中的每个字都作为一个单独的词来对待。 如果我们硬要查询的话，则需要加上一个.keyword在key值后面，像这样： 12345678GET vincent_index/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;userName.keyword&quot;: &quot;张三&quot; &#125; &#125;&#125; 这样会将张三整体两个字，作为词语来处理。 因此，正确的Java代码为：（这里使用到了设计模式中的建造者模式） 12345678910111213141516171819202122232425/** * 复杂查询 */@Testpublic void searchTest() throws IOException &#123; //1. 新建一个请求 确定查询哪一个索引 SearchRequest searchRequest = new SearchRequest(&quot;vincent_index&quot;); //2. 构建查询体对象 SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); //3. 构建精准查询 TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;userName.keyword&quot;, &quot;李易峰&quot;); //查询对象使用这个精确查询 searchSourceBuilder.query(termQueryBuilder); searchSourceBuilder.timeout(TimeValue.timeValueSeconds(60)); //这个请求使用这个查询体 searchRequest.source(searchSourceBuilder); //通过请求发出 返回的响应中 去取出对应的数据对象 SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT); //对应的数据对象是存储在数组中的 循环遍历即可 for (SearchHit documentFields : searchResponse.getHits().getHits()) &#123; System.out.println(documentFields.getSourceAsMap()); &#125;&#125; 京东搜索-ES项目具体请转到博客项目归档...","categories":[{"name":"中间件","slug":"中间件","permalink":"https://github.com/Vincent990413/blog/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://github.com/Vincent990413/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"author":"vincent"},{"title":"JavaScript学习笔记","slug":"JavaScript","date":"2021-08-28T09:27:23.000Z","updated":"2021-11-09T07:53:30.190Z","comments":true,"path":"JavaScript/","link":"","permalink":"https://github.com/Vincent990413/blog/JavaScript/","excerpt":"","text":"介绍前言JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。—— 百度百科 学习了HTML和CSS3后，我们可以对网页简单的静态“整容”，但是很难通过后期的需求来对网页动态的增删改查；因此，学习动态的脚本语言JavaScript（JS）是非常有必要的。 正文Java与JavaScript的关系 第一次学JS的时候，看到单词是JavaScript，总觉得是Java加上脚本script， 因此心中一直有误解；其实，虽然JS是脚本语言不错，但是编程上是与Java没有任何关系的。 JavaScript的特点 Java的特点 解释性语言，无需事先编译 编译性语言，会检查语法，不正确无法通过运行 基于对象，拥有封装的特性，但是没有继承与多态 面向对象，拥有封装、继承、多态等特性 事件源触发事件驱动 主函数入口驱动 依赖于浏览器，不同的浏览器可能导致效果不同 跨平台使用，依赖于JVM（Java Virtual Machine) 安全，依赖于浏览器但不访问硬盘 安全与否取决于通过字节码检验 弱变量，解释器自动通过变量值来判断类型 强变量，变量声明时需要通过变量检查 厂家是Netscape公司 厂家是sum公司 JavaScript 基础JavaScript 引用语法引用JavaScript的方法有三种，与CSS相似，可以在网页的头部引用，可以用script标签，也可以作为外部JS文件来引用。 值得注意的是： 使用script标签时，我们最好放在元素后方 ，否则无法获取该DOM对象（将使用实例说明）。 使用 window.alert(&quot;内容&quot;); 弹出警告框 使用 document.write(&quot;内容&quot;); 写入网页文档中 改变DOM对象的 innerHTML 属性 使用控制台 console.log(&quot;内容&quot;) 写入内容 JavaScript 语句与变量在JS中，我们用分号;隔开语句，但这也是可选的，只是建议为了编程规范用分号隔开每条语句； 浏览器将依次按顺序执行每条语句。 在JS中，我们用花括号{}隔开代码块，在代码块中区别不同的语句。 JavaScript中的变量都是弱变量，即我们不需要像Java那样声明 int a = 1; String str = &quot;hello&quot;; 只需要全部统一使用 var v = 1; var str = &quot;hello&quot;; 进行声明与赋值，甚至连 var 都可以省去。 JavaScript对大小写敏感，因此变量名为a和A是属于不同的两个变量；变量不能以数字开头，也可以 美元字符$ 和下划线_ 开头。 1234567var a = 1;var b = 2;var c = a + b;windows.alert(&quot;c的结果为:&quot; + c); JavaScript 注释在JS中，注释可分为单行与多行注释两种。 单行注释使用双斜线 // 开始注释，并在后紧跟注释内容。多行注释使用 /** 注释内容 ***/ ，中间可以跨度若干行。 JavaScript 数据类型JavaScript中的基本类型有五种： String字符串、Number数字、Boolean布尔、NULL空值 和 Undefined未定义的值； 而 引用数据类型 有:Object对象、 Array数组和Function函数。 JavaScript 字符串 String存储字符的变量，我们称之为字符串变量，我们可以用单引号‘’或者双引号“”将任意文本包裹起来， 但要求如果文本中需要引号，不与外部引号相同即可。即内单外双，内双外单。例如： 12345var pc = &quot;ASUS&quot;;var words = &quot;is the famous brand&quot;;windows.alert(pc + words); 我们可以使用 索引 来访问字符串中任何字符，使用数组的下标[x]，其中[x]从0开始（第一个字符）到n-1（最后一个字符）结束，n为字符串中字符的个数。 使用定位索引 indexOf() 来从头定位某一个指定的字符首次出现的位置，出现的位置亦是从0开始； 使用 lastIndexOf() 从末尾开始寻找第一次出现的位置。 使用 replace() 方法在字符串中替换字符，例如： 12345var str1 = &quot;Apple is pretty good!&quot;;var str2 = str1.replace(&quot;Apple&quot;, &quot;HuaWei&quot;); windows.alert(str2); 使用 toUpperCase()和toLowerCase() 分别将字符小写转换成大写和大写转换为小写； 使用 split(&quot;x&quot;) 方法将字符串转换为数组，其中引号中的内容为分隔成数组的要求。 JavaScript中String字符串的常用方法及说明： 1234567charAt(x) //返回位于x处的字符（0~length()-1) compareTo(str2) //str1使用该方法，与str2按字典序进行比较，结果为0，小于0，大于0的数，分别代表字符相等，str1小于str2与str1大于str2 matches(reg) //reg是给定的正则表达式，使用该方法匹配是否字符串能满足该表达式trim() //返回字符串忽略前部空白与尾部空白后的结果 JavaScript 数字 Number我们可以用两种方法来表示数字，一是直接书写数字值，二是利用科学计数法来表示： 123var x = 1.222;var y = 2e3; //代表2000 2*10^3 八进制与十六进制 默认情况下，JavaScript中的数字是使用十进制显示； 如果前缀是0，那么代表是八进制数，如果是0x则为十六进制数。 无穷大 Infinity 当数字运算的结果超出了JS的数字表示结果时，则会出现一个无穷大值，以infinity表示，负无穷大以-infinity表示： 123var a = 2 / 0; // a为正无穷大var b = -2 / 0; //b为负无穷大 非数字 NaN(not a number) NaN代表某值不是数字，同时我们可以使用isNaN(x)方法来判断x是不是NaN。 JavaScript 布尔 Boolean布尔只能有两个值，即true或false。 JavaScript 数组 Array使用Array来存储一系列的值，值可以是不同的类型。 创建数组 先new声明后赋值 1234567var array_name = new Array();array_name[0] = value1;array_name[1] = value2;array_name[2] = value1; 边声明边赋值 1var array_name = new Array(value1, value2, value3); 直接赋值 1var people = [value1, value2, value3]; 数组属性以及相关方法 连接两个或多个(可以任意个)数组，并返回新数组。 1234let hege = [&quot;Cecilie&quot;, &quot;Lone&quot;];let stale = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];let kai = [&quot;Robin&quot;];let children = hege.concat(stale,kai); 检查数组中是不是每个元素都满足条件 123let array = [1,2,3,4,5]let flag = array.every( (item)=&gt;&#123;return item &gt; 0&#125; ); //结果是true 返回满足条件的新数组 123let array = [1,2,3,4,5];let newArray = array.filter((item)=&gt;&#123;return item&gt;1&#125;);//结果是元素为2，3，4，5的新数组 返回满足条件的第一个元素 123let array = [1,2,3,4,5];let newArray = array.find((item)=&gt;&#123;return item&gt;1&#125;)//结果是2 返回满足条件的元素第一次出现的下标 123let array = [1,2,3,4,5];let indexOfOne = array.findIndex((item)=&gt;&#123;return item===1&#125;)//结果是0 迭代遍历数组，注意与map的区别，map会返回一个新数组，而不像forEach，直接在原数组上每个元素进行操作。 123let array = [1,2,3,4,5];let array = [1, 2, 3, 4, 5];array.forEach((item, index) =&gt; &#123; console.log(`这是第$&#123;index&#125;个,值为：$&#123;item&#125;`) &#125;) 判断一个数组是否包含某一个指定的值 123let array = [1,2,3,4,5];let flag = array.includes(3);//结果是true 将数组所有元素转换为一个字符串，且分隔符默认为逗号，可指定为空格。 123let array = [&quot;I&quot;,&quot;love&quot;, &quot;you&quot;];let string = array.join(&quot; &quot;);//结果是I love you 遍历但不更改原数组，而是返回新数组。 123let array = [1,2,3,4,5];let newArray = array.map((item)=&gt;&#123;return item+1;&#125;)//newArray的值为2，3，4，5，6 向数组的末尾添加一个或者更多元素，并返回新的长度。 123let array = [1,2,3,4,5]let newLength = array.push(6);//返回6 检测数组中是否有元素符合指定条件，其中一个满足就为true。 123let array = [1,2,3,4,5];let flag = array.some((item)=&gt;&#123;return item===2&#125;)//结果为true 删除或者添加若干个元素，从哪里开始，删多少个。第三个参数为新增元素。 并且返回被删除（如果有）的元素所构成的新数组。 如果只有一个参数n，则默认从第一个元素开始，删除n个。 123let array = [1,2,3,4,5]let deletedArray = array.splice(0, 2);//返回新数组[1,2] 且原数组变为[3,4,5] JavaScript 对象 Object由于JavaScript是基于对象的，因此所有一切皆为对象。对象拥有自己的方法和属性。 自定义对象 12345var person = new Object();person.firstname = &quot;jack&quot;;person.age = 9; 使用构造方法 1234567function person(firstname, age)&#123; this.firstname = firstname; this.age = age;&#125; var brother = new person(&quot;jack&quot;, 9); JavaScript 函数函数就是包裹在花括号中的代码块： 123function funName()&#123;&#125; Javascript 对大小写敏感 可以传入参数，在调用函数时，写的个数与声明的参数个数顺序要一致： 123function funName(par1, par2)&#123; &#125; &lt;div onclick=&quot;funName(par1, par2)&quot;&gt;&lt;/div&gt; 当你想从当前位置，使JavaScript停止往下执行代码时，可以使该函数在某个地方提前返回值 使用 return 123function funName(para1, para2)&#123; return para1 + para2&#125; 局部JavaScript变量与全局JavaScript变量在函数内部定义的变量，我们一般称为局部变量，它的作用域只限于整个函数体 相反，在函数外部定义的变量是全局的 全局的JS文件或者函数都可以访问这个变量 123456789var globalVar = 12;function fun1()&#123; var partialVar1 = 2;&#125;function fun2()&#123; var partialVar2 = 3;&#125; 可以看出，fun1与fun2都可以在任意处引用globalVar 值得注意的是，在VUE中的var变量一般会提升变量的作用域、而let变量不会（更推荐使用let变量） JavaScript中的变量一定要先声明后赋值，不同于Python编程语言 若某个变量没有x属性，强行使用或者调用该属性时，会报错No such property等错误 常见的HTML事件 点击事件：onclick 某个键盘按键被松开: onkeyup 页面完成加载 onload 元素失去焦点 onblur 表单元素中的内容发生改变时：onchange （多用于input、select、textarea) 元素获得焦点时 onfocus 表单重置时 onsubmit 运算符+运算符用于将两个或者多个字符串变量，文本值连接起来 123function funName(var1, var2)&#123; return var1 + var2&#125; 值得注意的是， 字符串与数字相加时，结果是字符串 当数字与数字相加 结果是数字 比较运算符 == 值等于 === 值以及类型都相等 ！= 不等于 当某些变量赋值时，也可以用到条件运算符 12varName = (age&gt;18)? &quot;没有成年&quot; : &quot;已经成年&quot;; 条件语句 if 条件 真语句：假语句 if-else if-else if- else switch-case12345678switch(n)&#123; case 1: //代码块1 case 2: //代码块2 default： // 默认case都不执行时 执行deault&#125; 循环for循环123for(var i=0; i&lt;5; i++)&#123; document.write(i); //输出0 1 2 3 4&#125; 1234567891011121314151617var person = &#123;fname:&quot;Bill&quot;,lname=&quot;Gates&quot;, age=56&#125;; for(var key in person)&#123; txt += person[key] key是属性 person[key]是对应的属性值&#125;#### while循环```js var i = 0;var end = 10;while(i &lt; end)&#123; document.write(&#x27;i满足一直比0小！&#x27;); i++;&#125; break与continue语句break语句指的是，后面的都不判断了，跳出整个循环体（不管是for还是while） 而continue是指，跳出当前循环，进入下一个条件值继续执行。 比如： 1234567var i;for(i=0; i&lt;20; i++)&#123; if(i % 3 == 0)&#123; continue; //在这里注意到 如果是3的倍数 那么不会输出内容 &#125; document.write(&#x27;正在执行！&#x27;)&#125; typeof 操作符在不知道对应实例是属于什么类型的变量时 我们使用typeof instance 来查看对应的变量类型： 1234567891011typeof &quot;john&quot; //string typeof 3.14 //number typeof false //boolean typeof [1,2,3] //object typeof &#123;name:&#x27;John&#x27;, age:34&#125;//object null对象在Javascript中，null表示空对象引用 var person = null //即表示该对象是空对象 undefined（赋这个值以清空某个变量）在JavaScript中 undefined是一个没有设置值的变量 JavaScript 类型转换将数字转换为字符串123String(number + number2)(number1 + number2).toString() 字符串转换为数字1Number(str) JavaScript 正则表达式正则表达式(Regular Expression) 使用若干个字符来描述：满足特定句法规则的字符串模式 使用test（）方法对于特定的正则表达式，我们可以使用test（）方法来验证某字符串变量是否满足这个特定正则表达式 123var reg = /xxx/;console.log(reg.test(strValue)) 若满足这个特定的正则表达式 则输出true 否则输出false 变量提升所谓变量提升，是指函数以及变量的生命都将被提升到函数的最顶部 也就是说，变量可以先使用再声明 但是！变量的初始化，并不会提升 12345var x = 5;elem = document.getElementById(&quot;demo&quot;);elem.innerHTML = x + &quot;,&quot; + y;var y = 7; 在以上例子中，y的值会输出undefined，而这是因为 变量y的初始化在下方，而初始化是不会提升的 因此，我们在敲代码时，要记住，最好是直接在头部声明我们的变量 块级作用域 let 与常量符 constES6 可以使用let来使用块级变量符，也就是说 let变量在当前所在的代码块中有效 而在{}外，是无法访问的！ 对比var 变量符 1234567&#123; function funName()&#123; var test = 1; &#125; console.log(test) //值仍为1 可以访问（此时不具备块级变量的概念）&#125; 123456&#123; function funName()&#123; let test = 2; &#125; console.log(test) //错误，此时具有块级变量的概念，是不能访问到的&#125; CONST 常量名称 const 定义常量的值必须初始化 因为后期是不能改变的 一旦初始化了 后期是绝对不能改变的 CONST 定义的数组或者对象 里面的属性是可以修改的 但是 我们是不能对这个对象 或者数组重新赋值的。 123const car = &#123;type=&quot;fia&quot;, model:&quot;500&quot;, color:&quot;white&quot;&#125;car.color = &quot;red&quot;; //不会报错的 JavaScript JSONJSON的全称是 JavaScript Object Notation 是一种轻量级的数据交换格式，通常用于服务端向网页传递数据 例如： 12345678910111213&#123; &quot;sites&quot;: [ &#123; &quot;name&quot;: &quot;Google&quot;, &quot;url&quot; : &quot;www.google.com&quot; &#125;, &#123; &quot;name&quot;: &quot;Baidu&quot;, &quot;url&quot;: &quot;www.baidu.com&quot; &#125; ]&#125; 数据为键:值对的集合：&quot;key&quot;:&quot;value&quot; 数据与数据之间 用逗号隔开 花括号保存对象，方括号保存数组 使用内置函数将JSON 字符串转换为JavaScript对象1234567var text = &#x27;&#123; &quot;sites&quot; : [&#x27; + &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; + &#x27;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; + &#x27;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#x27;; var obj = JSON.parse(text); **JSON.stringify(obj)**是一个相反的过程 Promise 类解决前端异步调用后台数据 小例子123456//Promise 的构造函数的参数只有一个//就是一个函数 在这个函数中，我们编写要执行的《异步函数代码块》new Promise(function (resolve, reject)&#123; console.log(&#x27;异步代码块！&#x27;)&#125;); 其中resolve代表一切正常(译为解决)，reject代表出现异常时调用（译为拒绝） 比如出现零除异常。 123456789101112new Promise(function (resolve, reject) &#123; var a = 0; var b = 1; if (b == 0) reject(&quot;Divide zero&quot;); else resolve(a / b);&#125;).then(function (value) &#123; console.log(&quot;a / b = &quot; + value);&#125;).catch(function (err) &#123; console.log(err);&#125;).finally(function () &#123; console.log(&quot;End&quot;);&#125;); 我们这样子执行的原因。 虽然执行这些代码块是异步的，但是我们利用then的先后顺序，让它看起来是相对“同步”的 Async 与 Await 代替 Promise我们知道，对于async关键字来说，指明这是一个异步函数。 当遇到Await时，则代表会在此停下来。 且执行Await之后的代码，返回出来的是一个Promise对象。我们可以从中获得，resolve出来的数据。resolve是一种可以改变Promise状态的函数。 1234567891011121314function beforeAsycCall() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;两秒后出现...&#x27;) &#125;, 2000); &#125;) &#125; async function asyncCall() &#123; const result = await beforeAsycCall(); console.log(result) //其中result就是await代码块中 resolve的值 &#125; asyncCall();","categories":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"RocketMQ 学习笔记","slug":"RocketMQ学习笔记","date":"2021-08-23T01:34:20.000Z","updated":"2021-11-09T07:53:30.207Z","comments":true,"path":"RocketMQ学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"RocketMQ 简介 MQ，Message Queue是一种先进先出的管道队列。生产者将生产好的消息放入这个管道，同时消息消费者可以从这个管道中取出这个消息。 为什么需要MQ？高度解耦，不直接将生产者与消费者耦合在一起。生产者不管消费者什么时候需要消息，需要的时候自取即可。 应用场景-注册成功消息最常见的一个场景是，用户注册后，需要发送注册邮件和短信通知，告知用户注册成功。 而传统开发流程是： 后端处理用户注册的表单，并且存储到数据库的同时；立即，发送注册成功的邮件信息，发送注册成功的短信通知。 然后，才通知用户您已登录成功，并让用户去登录页面进行登录。 而这本身就是一种同步的业务流程，后端处理，邮件发送，短信通知，这三者高度耦合。 实际上，在后端注册成功，并存储注册信息到数据库的同时。 用户就可以登录了，至于邮件通知以及短信通知，我们就可以将其放入MQ中，由消息队列来进行这些操作。 MQ的主要特点是，减少请求响应与解耦，主要应用场景是：将比较耗时而且不需要即时返回结果（同步）的操作作为消息放入消息队列。 应用场景-流量削峰 在高并发场景下，比如秒杀或者抢购活动中。由于用于的请求量巨大，流量暴增。秒杀的应用在处理如此大量的访问流量后，下游的通知系统无法承载海量的调用量，甚至会导致系统崩溃等问题。 如图所示，秒杀的处理流程： 用户发起海量秒杀请求到业务系统中。 秒杀处理系统按照处理逻辑，将满足秒杀条件的请求，作为生产者放入消息队列MQ中。 下游的通知系统订阅Subscribe消息队列MQ的秒杀消息，再将秒杀成功的消息发送到相应用户。 用户收到秒杀成功的通知。 Linux 操作系统中使用MQ首先去官网下载MQ：RocketMQ 4.4.0版本下载地址 然后启动Linux环境（包括VM虚拟机，XFTP文件共享，以及XShell命令行工具）： 并且Linux虚拟机中需要有JDK1.8+ XShell下载地址 XFtp下载地址 Xshell操作首先将MQ4.4.0的zip安装包，通过XFTP上传到目录： 1/usr/local/src/ 在src的子目录rocketmq下解压，并移动到rockmq中。 CentOS安装unzip命令： 1yum install unzip 解压压缩包： 1unzip rocketmq-all-4.4.0-bin-release.zip 然后将解压后的文件夹移动到rocketmq中 1mv rocketmq-all-4.4.0-bin-release ./rocketmq 接下来进入解压后的文件夹的根目录，开始启动RocketMQ等等.... 启动RocketMQ 注意，我们需要启动两个：1. mqnameserv 2.broker(中介)。 首先启动mqnamesrv1cd bin 1nohup ./mqnamesrv &amp; 这样就算启动成功了！ 当然，可以通过监听端口来查看是否启动成功。 1netstat -an | grep 9876 启动Broker 首先编辑配置文件runserver.sh，修改启动分配的内存。1vi runserver.sh 然后修改runbroker.sh文件。1vi runbroker.sh 启动broker即可，需要指定nameserver(-n)的套接字。1nohup ./mqbroker -n localhost:9876 &amp; 查看是否成功运行： 1tail -f ~/logs/rocketmqlogs/broker.log 测试RocketMQ 我们从一端发送，另一端看能否接收到即可。 首先在Xshell中新建会话。 然后切换到最初安装的rocketmq的bin目录下： 1cd /usr/local/.../bin/ 现在我们有两个会话，我们一个模拟发数据到MQ中，另一个会话模拟收数据。 其中一个会话发送数据到MQ 指定发送数据的MQ端口 1export NAMESRV_ADDR=localhost:9876 生产者发送数据测试 1./tools.sh org.apache.rocketmq.example.quickstart.Producer 另一个会话从MQ中接收数据 指定接收数据的MQ端口1export NAMESRV_ADDR=localhost:9876 消费者接收数据测试1./tools.sh org.apache.rocketmq.example.quickstart.Consumer 至此，测试成功。 Linux关闭NameServer与Broker12bin/mqshutdown namesrvbin/mqshutdown broker RocketMQ内部图其中MessageQueue是有多个的，根据不同的Topic来划分。 我们可以想象成邮局发送邮件的工作流程，Producer为寄件人，Consumer为收件人，NameServer为邮局，Broker为邮递员，Topic为投递地区，MessageQueue为具体的邮件。里面的Message为邮件具体内容。 RocketMQ 控制台 我们可以堪称是控制面板，通过这个控制面板，我们可以实时对RocketMQ内部组成的各个部分进行查看，管理等等。 下载点我下载RocketMQ控制面板项目 更改这个Maven项目的application.properties： 更改端口号8080为未被占用的端口 添加Linux的Namesrv的端口地址 打包这个Maven项目：1mvn clean package -Dmaven.test.skip=true 启动项目1java -jar target/rocketmq-console-ng-1.0.0.jar 在网页中打开控制台页面：http://localhost:7777/#/ 消息发送与消息接收Pom.xml123456&lt;!--RocketMQ 消息队列--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 消息发送1234567891011121314151617181920212223242526272829303132333435package com.example.telesys.test;import org.apache.rocketmq.client.exception.MQBrokerException;import org.apache.rocketmq.client.exception.MQClientException;import org.apache.rocketmq.client.producer.DefaultMQProducer;import org.apache.rocketmq.client.producer.SendResult;import org.apache.rocketmq.common.message.Message;import org.apache.rocketmq.remoting.exception.RemotingException;/** * RocketMQ 消息队列模拟发送与接收消息 */public class RocketMQSendMessageTest &#123; public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123; //1. 创建消息生产者 并且设置生产组名 DefaultMQProducer producer = new DefaultMQProducer(&quot;mq-group-producer&quot;); //2. 为生产者设置NameServer的地址 这里看具体的Linux地址与端口 producer.setNamesrvAddr(&quot;192.168.184.128:9876&quot;); //3. 启动生产者 producer.start(); //4. 构建消息对象 主要设置消息的主题 标签以及内容 //注意引入的是MQ的Message类 Message message = new Message(&quot;myTopic&quot;, &quot;myTag&quot;, (&quot;RocketMQ Message Test Content&quot;).getBytes()); //5. 发送消息 以及规定超时时间 SendResult result = producer.send(message, 10000); System.out.println(&quot;消息发送结果是：&quot; + result); //6. 关闭生产者 producer.shutdown(); &#125;&#125; 消息的接收12345678910111213141516171819202122232425262728293031323334package com.example.telesys.test;import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;import org.apache.rocketmq.client.exception.MQClientException;import org.apache.rocketmq.common.message.MessageExt;import java.util.List;/** * 模拟RocketMQ的消息接收 */public class RocketMQReceiveMessageTest &#123; public static void main(String[] args) throws MQClientException &#123; //创建消息消费者 并指定消费者所属的组名 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;consumerGroup&quot;); //指定NameServer地址 consumer.setNamesrvAddr(&quot;192.168.184.128:9876&quot;); //指定消费者订阅的主题与标签 这样可以接收生产者发送的消息 consumer.subscribe(&quot;myTopic&quot;, &quot;*&quot;); //设置回调函数 编写处理消息的方法 consumer.registerMessageListener((MessageListenerConcurrently) (list, consumeConcurrentlyContext) -&gt; &#123; //具体消费逻辑 System.out.println(&quot;接收到的消息,Message====&gt;&quot; + list); //返回成功状态 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125;); //启动消费者 consumer.start(); System.out.println(&quot;启动消费者成功...&quot;); &#125;&#125; 案例 接下来我们模拟一种场景：某种操作之后，向用户发送通知。 微服务发送与接收消息发送消息首先我们需要配置pom.xml 123456789101112&lt;!--RocketMQ 消息队列--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 然后我们需要在application.properties文件中配置 1234#RocketMQ 配置rocketmq.name-server=192.168.184.128:9876rocketmq.producer.group=producerGroup 然后在需要发送消息的地方，引入RocketMQTemplate 12345678910@Autowiredprivate RocketMQTemplate rocketMQTemplate;/** * RocketMQ demo当查看供应商数据后 向MQ队列发送消息 * 并在相应地方 订阅与接收这个消息 */ //参数1 指定topic 参数2 指定消息体 rocketMQTemplate.convertAndSend(&quot;supplier-topic&quot;, list); 通过RocketMQ给我们提供的控制台，我们就可以查看这条消息了。 也就是说，现在我们成功地将消息注册到MQ消息队列中了。 在需要的时候，我们就可以在另一个微服务那儿，监听这个消息，并消费掉这个消息。 接收消息12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 12#RocketMQ配置 消息接收者就不需要指定group了rocketmq.name-server=192.168.184.128:9876 12345678910111213141516171819202122232425package com.example.telesys.service;import com.example.telesys.pojo.Supplier;import org.apache.rocketmq.spring.annotation.RocketMQMessageListener;import org.apache.rocketmq.spring.core.RocketMQListener;import org.springframework.stereotype.Service;import java.util.List;/** * 注意topic要与 发送消息那里指定的topic一致 * 这样才能准确收到消息 * * 而且要注意泛型的类型 是自己发送的消息体 而不能任意指定 这里是list */@Service@RocketMQMessageListener(consumerGroup = &quot;tele-user&quot;, topic = &quot;supplier-topic&quot;)public class SmsService implements RocketMQListener&lt;Supplier&gt; &#123; //具体监听的函数 @Override public void onMessage(Supplier supplier) &#123; System.out.println(&quot;收到一个Supplier消息====&gt;&quot; + supplier); System.out.println(&quot;接下来发送短信！&quot;); &#125;&#125; 发送不同类型的消息普通消息RocketMQ可以提供三种方式来发送普通消息：可靠同步发送、可靠异步发送以及单项发送。 为了测试，我们引入测试类，并进行相应测试。 123456789&lt;!--测试类--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;/dependency&gt; 创建相应的测试类： 123456789101112131415161718192021package com.example.telesys.test;import com.example.telesys.MySupplierApplication;import org.apache.rocketmq.client.producer.SendResult;import org.apache.rocketmq.spring.core.RocketMQTemplate;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;/** * 这是SpringBoot工程的测试类 */@RunWith(SpringRunner.class)@SpringBootTest(classes = MySupplierApplication.class)public class MessageTypeTest &#123; @Autowired private RocketMQTemplate rocketMQTemplate;&#125; 可靠同步发送可靠指的是可以获取结果，同步指的是有严格的先后顺序，拿到这一次的结果，才能发送下一次。 可靠同步发送的测试代码： 123456789/*** 可靠同步消息测试* 参数一：topic，参数二：消息内容，参数三：超时时间*/@Testpublic void testSyncMessageSend() &#123; SendResult sendResult = rocketMQTemplate.syncSend(&quot;test-topic-1&quot;, &quot;这是一条可靠同步消息！&quot;,10000); System.out.println(&quot;可靠同步消息的返回结果====&gt;&quot; + sendResult);&#125; 如果需要指定tag，那么就写成test-topic-1:tag就可以了。 可靠异步消息同样，可以接收到消息。但是发送方，不必等待接收方传来的响应，而是接着发送下个数据包。而通过回调函数接收服务器响应，并对响应结果处理。 比如我们上传多个视频，所发送的消息。我们上传第一个视频，不管成功与否，我们肯定是接着上传第二个。 因为是异步的，所以测试的时候，我们得延缓测试的停止时间，这样才能等到发送成功的时间。 测试代码： 123456789101112131415161718192021222324252627282930/** * 可靠异步消息测试 * 参数一：topic，参数二：消息内容，参数三：回调函数 */ @Test public void testAsyncMessageSend() throws InterruptedException &#123; rocketMQTemplate.asyncSend(&quot;test-topic-1&quot;, &quot;这是一条异步消息&quot;, new SendCallback() &#123; /** * 消息发送成功的回调函数 * @param sendResult */ @Override public void onSuccess(SendResult sendResult) &#123; System.out.println(&quot;可靠异步消息的结果：&quot; + sendResult); &#125; /** * 消息发送失败的回调函数 * @param throwable */ @Override public void onException(Throwable throwable) &#123; System.out.println(&quot;可靠异步消息的结果：&quot; + throwable); &#125; &#125;); System.out.println(&quot;===========================&quot;); //为了能看到效果 我们线程睡眠 Thread.sleep(300000000); &#125; 单向消息所谓单向消息是指，发送方只负责发送消息而不必等到服务器回应，并且没有回调函数触发。适用于某些耗时较短，对可靠性要求不高的场景，比如日志。 1234567/*** 单向消息发送 */@Testpublic void sendOneWay()&#123; rocketMQTemplate.sendOneWay(&quot;test-topic-1&quot;, &quot;这是一条单向消息。&quot;);&#125; 顺序消息 顺序消息是消息队列提供的一种，严格按照顺序来发布和消费的消息类型。 MQ本来就是消息队列了，为什么我们还要规定顺序呢？ 因为，生产者发布消息的时候，确实是没办法确定消息被投递到哪一个Message Queue。 同理，消费者消费的时候，不能确切地保证消费某一个Message。 那么，怎么解决这个问题呢？ 指定MessageQueue的ID，包括生产者投递消息时与消费者消费消息时。 我们可以看看，之前普通消息发送的test-topic-1主题里面的状态。 并且，如果发送消息的时候，不指定queueId，就会发现位点会随机分布! 我们实现单向顺序发送消息的代码为： 1rocketMQTemplate.sendOneWayOrderly(&quot;test-topic-1&quot;, &quot;这是一条顺序单向消息。&quot;,&quot;hashKey&quot;); 只要第三个参数不重复，那么都会落到同一个队列中。（从第一个队列开始往后排列） 事务消息 RocketMQ提供了事务消息，通过事务消息就能达到分布式事务的最终一致。 半事务消息，对于那种暂时不能投递的消息，发送方已经成功地将消息发送到了RocketMQ服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态。 消息回查，如果生产者对某消息确实有二次确认，但是在传递过程中二次确认丢失了。那么在RocketMQ服务端通过扫描发现，某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态：Commit或Rollback，这种询问过程叫消息回查。 代码首先我们需要一个事务日志表，这样我们在执行某个操作后，可以同时记录相关日志信息。 这里我们只需要简单的两个属性： 1234567891011121314151617package com.example.telesys.RocketMQTransactionEntity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.data.annotation.Id;import javax.annotation.Generated;import java.util.Date;/** * 记录本地事务成功或者失败的日志实体 */@Data@AllArgsConstructor@NoArgsConstructorpublic class TxLog &#123; private String txId; private Date date;&#125; 以及对应的DAO层： 12345678910111213package com.example.telesys.mapper;import com.example.telesys.RocketMQTransactionEntity.TxLog;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;@Mapperpublic interface TxLogMapper &#123; @Insert(&quot;insert into txlog (txId, date) values (#&#123;txLog.txId&#125;,#&#123;txLog.date&#125;)&quot;) int insert(@Param(&quot;txLog&quot;) TxLog txLog); @Select(&quot;select* from txlog where txLogId = #&#123;txLogId&#125;&quot;) TxLog findById(@Param(&quot;txLogId&quot;) String txLogId);&#125; 实现半事务消息方法与本地事务方法： 这里需要注意一下，这二者在整个分布式事务中的位置。 首先我们在Controller层中调用半事务消息，在这个半事务消息中，我们会给RocketMQ服务端发送分布式消息。 发送消息后，我们另外的一个监听类会有一个函数，这个函数中，我们会转回头来执行本地事务方法。执行完之后，我们会给RocketMQ服务端发送成功或者回滚状态。 如果这个状态发送成功，那么整个分布式事务完成。 而如果这个状态发送失败，服务端没有收到，那么就会执行相应的消息回查函数。如果发现事务日志表中，已经有了之前的数据，就完毕。否则回滚！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.telesys.test;import com.example.telesys.RocketMQTransactionEntity.TxLog;import com.example.telesys.mapper.SupplierMapper;import com.example.telesys.mapper.TxLogMapper;import com.example.telesys.pojo.Supplier;import org.apache.rocketmq.client.producer.TransactionSendResult;import org.apache.rocketmq.spring.core.RocketMQTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.messaging.support.MessageBuilder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.Date;import java.util.UUID;@Servicepublic class SendTransactionMessage &#123; @Autowired private RocketMQTemplate rocketMQTemplate; @Autowired private SupplierMapper supplierMapper; @Autowired private TxLogMapper txLogMapper; /** * 利用RocketMQ发送半事务消息 */ public TransactionSendResult createSupplierBefore(Supplier supplier)&#123; String txLogId = UUID.randomUUID().toString(); TransactionSendResult transactionSendResult = rocketMQTemplate.sendMessageInTransaction( &quot;tx_producer_group&quot;, &quot;tx_topic&quot;, MessageBuilder.withPayload(supplier).setHeader(&quot;txLogId&quot;, txLogId).build(), supplier ); return transactionSendResult; &#125; /** * 本地事务 * @param supplier */ @Transactional public void createSupplier(String txLogId, Supplier supplier)&#123; //保存供应商数据 supplierMapper.insert(supplier); //记录事务日志 TxLog txLog = new TxLog(); txLog.setTxId(txLogId); txLog.setDate(new Date()); txLogMapper.insert(txLog); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.telesys.test;import com.example.telesys.RocketMQTransactionEntity.TxLog;import com.example.telesys.mapper.TxLogMapper;import com.example.telesys.pojo.Supplier;import org.apache.rocketmq.spring.annotation.RocketMQTransactionListener;import org.apache.rocketmq.spring.core.RocketMQLocalTransactionListener;import org.apache.rocketmq.spring.core.RocketMQLocalTransactionState;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.messaging.Message;import org.springframework.stereotype.Service;@Service@RocketMQTransactionListener(txProducerGroup = &quot;tx_producer_group&quot;)public class SendTransactionMessageListener implements RocketMQLocalTransactionListener &#123; @Autowired private SendTransactionMessage sendTransactionMessage; @Autowired private TxLogMapper txLogMapper; /** * 执行本地事务 * @param message 发送事务消息时MessageBuilder后的内容 * @param o 发送事务消息的具体消息内容 * @return */ @Override public RocketMQLocalTransactionState executeLocalTransaction(Message message, Object o) &#123; String txLogId = (String) message.getHeaders().get(&quot;txLogId&quot;); try &#123; Supplier supplier = (Supplier) o; sendTransactionMessage.createSupplier(txLogId, supplier); return RocketMQLocalTransactionState.COMMIT; &#125; catch (Exception e) &#123; return RocketMQLocalTransactionState.ROLLBACK; &#125; &#125; /** * 消息回查 * * @param message * @return */ @Override public RocketMQLocalTransactionState checkLocalTransaction(Message message) &#123; String txLogId = (String) message.getHeaders().get(&quot;txLogId&quot;); TxLog txLog = txLogMapper.findById(txLogId); //如果本地事务成功 就上报给服务端 if (txLog != null) &#123; return RocketMQLocalTransactionState.COMMIT; &#125;else&#123; return RocketMQLocalTransactionState.ROLLBACK; &#125; &#125;&#125; 事务日志表的Dao层： 12345678910111213package com.example.telesys.mapper;import com.example.telesys.RocketMQTransactionEntity.TxLog;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;@Mapperpublic interface TxLogMapper &#123; @Insert(&quot;insert into txlog (txId, date) values (#&#123;txLog.txId&#125;,#&#123;txLog.date&#125;)&quot;) int insert(@Param(&quot;txLog&quot;) TxLog txLog); @Select(&quot;select* from txlog where txLogId = #&#123;txLogId&#125;&quot;) TxLog findById(@Param(&quot;txLogId&quot;) String txLogId);&#125; 接下来只需要在Controller层中调用这个半事务消息即可。 12345@RequestMapping(&quot;/addSupplier&quot;)public ApiResponse addSupplier(@RequestBody Supplier supplier) &#123; TransactionSendResult transactionSendResult = sendTransactionMessage.createSupplierBefore(supplier); return new ApiResponse(200, &quot;添加成功&quot;, transactionSendResult); &#125;","categories":[{"name":"Spring 全家桶学习","slug":"spring-全家桶学习","permalink":"https://github.com/Vincent990413/blog/categories/spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Spring 全家桶学习","slug":"spring-全家桶学习","permalink":"https://github.com/Vincent990413/blog/tags/spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"Spring Cloud学习笔记","slug":"Spring-Cloud学习笔记","date":"2021-08-13T01:34:20.000Z","updated":"2021-11-09T07:53:30.207Z","comments":true,"path":"Spring-Cloud学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/Spring-Cloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Spring Cloud 三层架构：MVC架构——&gt;升级架构即通过框架实现。 spring的目的，是让企业开发越来越简单。 Springboot重构SSM。springboot也称为，新一代的JavaEE开发标准。 自动装配，是springboot的特点。= @Autowire 引言 比如，现在我们有多个业务：支付业务，订单业务，用户业务等等（当然，我们可以看做是不同的Service服务）。 我们现在的做法，不再是之前的，横向服务器均分负载。 而是，模块化，将服务，业务抽离出来。而不是All in One（所有都在一个里面）。 代码是没有发生变化的，而是只是拆分在可能不同的服务器上，即放不同服务的机器，通过RestAPI来通信。 说完后端的思路，那么对于处在前端的用户而言： 拆分后，这么多的服务，用户怎么访问？答：用户只访问一个前端中心，而对于后端，前端的用户是看不到的，我们依照一定的规则，后端去访问不同的服务即可。 被拆分的服务与服务之间，如何通信？答：Http或者RPC 这么多服务，我们怎么管理呢？答：服务注册中心等等。 某个服务挂掉了，怎么办？答：提前备份这些服务。体现出，相应的容灾能力。 springcloud是一种生态，是一种思想。产品 Spring Cloud Netflix（粗体字是微服务的四大核心！）被称为，一站式解决方案。能解决上面的四个问题！ zuul 组件，是最开始的api gateway网关。 Feign能做通信，也能做负载均衡。是HTTP通信方式，同步且是阻塞的。 Eureka用于做服务的注册与发现。 Hystrix用来做熔断机制。 Apache Dubbo zookeeper半自动的解决方案。需要整合其他的技术。 ApiGateway 没有这个，需要其他的组件。 Dubbo是基于RPC类似Feign的框架。 ZooKeeper是用于服务的注册与发现的框架。 熔断机制是没有的，需要整合其他的组件。 Spring Cloud Alibaba（最新）最新的一站式解决方案。(更简单。） Spring Cloud Alibaba框架服务之间的通信问题 我们使用Spring提供的一种简单便捷的模板类，用于在Java代码里访问restful服务。RestTemplate下面，我们做一个基于SpringBoot+SpringJPA+RestTemplate的一个小demo。 在这个demo中，我们有三个module，都是Maven工程： 其中，创建一个父Maven，用来装一些外部的依赖。 1. 订单服务shop-order2. 用户服务shop-user3. 产品服务shop-product4. 公共服务shop-common 其中公共服务，用来放实体类。 其他服务分模块开发，将端口号隔开，当其中一个服务欲调用另一个服务的方法时，采用RestTemplate基于http进行通信。 其中SpringJPA用来，根据创建的实体类比如User、Order以及Product来自动生成数据库的表，当然需要先创建数据库。 父工程Maven项目 建一个Maven项目，名字自己取，但是注意，如果有-号，记得将其复制一遍，以免最终的名字没有-号。 将src删除，父工程只需要写相关依赖即可。 父工程的pom文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;shop-common&lt;/module&gt; &lt;module&gt;shop-user&lt;/module&gt; &lt;module&gt;shop-product&lt;/module&gt; &lt;module&gt;shop-order&lt;/module&gt; &lt;/modules&gt; &lt;!--指定父工程--&gt; &lt;!--这样子模块有些就不需要指定版本了--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!--依赖的版本锁定 这样就可以在必要的时候引用$&#123;xxx&#125;--&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--方便子模块的相互引用--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;g&lt;/project&gt; 公共模块shop-common 一样，记得复制带-号的名字。 建立相应的包名与实体类即可： 12345678910111213141516171819202122@Entity(name = &quot;shop_order&quot;)@AllArgsConstructor@NoArgsConstructor@Datapublic class Order &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long oid; //与用户相关 private Integer uid; private String username; //与商品相关 private Integer pid; private String pname; private Double pprice; private Integer number;&#125; 值得注意的是，**@Entity注解的name是等会SpringJPA自动生成表的表名。** 公共模块的pom文件 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.57&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 产品模块 shop-product 首先写依赖 123456789101112131415 &lt;dependencies&gt; &lt;!--导入通用模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;shop-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入web starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 然后写配置类 12345678910111213package com.itheima;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ProductApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProductApplication.class, args); &#125;&#125; 写资源配置application.properties 12345678910111213server.port=8072spring.application.name=service-product# 驱动 url 用户名以及密码spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/shop?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=123456#自动根据实体类 生成表spring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect 值得注意的是，1.首先我们给不同的服务分配不同的端口port，2.我们给不同的服务不同的名字，然后每个服务就要开启SpringJPA自动根据实体类生成表。 写相应的接口啊，实现类啊，Dao层啊，等等...控制层1234567891011121314151617181920212223242526package com.itheima.controller;import com.itheima.domain.Product;import com.itheima.service.ProductService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@Slf4jpublic class ProductController &#123; @Autowired private ProductService productService; @RequestMapping(&quot;/product/&#123;pid&#125;&quot;) public Product product(@PathVariable(&quot;pid&quot;) Integer pid)&#123; log.info(&quot;接下来要进行&#123;&#125;号商品信息的查询...&quot;, pid); Product product = productService.findByPid(pid); System.out.println(product); return product; &#125;&#125; @Slf4j 是lombok提供的一款日志插件。 服务接口层 123456789package com.itheima.service;import com.itheima.domain.Product;public interface ProductService &#123; Product findByPid(Integer pid);&#125; 服务实现层 1234567891011121314151617181920package com.itheima.service.impl;import com.itheima.dao.ProductDao;import com.itheima.domain.Product;import com.itheima.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class ProductServiceImpl implements ProductService &#123; @Autowired private ProductDao productDao; @Override public Product findByPid(Integer pid) &#123; return productDao.findById(pid).get(); &#125;&#125; Dao层 123456package com.itheima.dao;import com.itheima.domain.Product;import org.springframework.data.jpa.repository.JpaRepository;public interface ProductDao extends JpaRepository&lt;Product, Integer&gt; &#123;&#125; 其他的模块照旧，但值得注意的是，我们有一个操作，就是作为消费者的模块，想要用RestTemplate去调用作为提供者的服务时，需要配置RestTemplate。 在SpringBoot的启动类上，加上Bean注解： 1234@Beanpublic RestTemplate restTemplate()&#123; return new RestTemplate();&#125; 在调用的时候，比如OrderController： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.itheima.controller;import com.alibaba.fastjson.JSON;import com.itheima.domain.Order;import com.itheima.domain.Product;import com.itheima.service.OrderService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@RestController@Slf4jpublic class OrderController &#123; @Autowired private RestTemplate restTemplate; @Autowired private OrderService orderService; //下单 @RequestMapping(&quot;/order/product/&#123;pid&#125;&quot;) public Order order(@PathVariable(&quot;pid&quot;) Integer pid) &#123; log.info(&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询信息...&quot;, pid); Product product = restTemplate.getForObject(&quot;http://localhost:8072/product/&quot; + pid, Product.class); log.info(&quot;查询到&#123;&#125;号商品的信息，内容是：&#123;&#125;&quot;, pid, JSON.toJSONString(product)); Order order = new Order(); //模拟测试用户 order.setUid(1); order.setUsername(&quot;测试用户&quot;); order.setPid(pid); order.setPname(product.getPname()); order.setPprice(product.getPprice()); order.setNumber(1); orderService.createOrder(order); log.info(&quot;创建订单成功...订单信息为：&#123;&#125;&quot;, JSON.toJSONString(order)); return order; &#125;&#125; 我们通过url，即http的方式来远程调用其他端口号的某个服务。 项目的地址： 1https://gitee.com/vincent990413/itheima-resttemplate-shop-springcloud 这种以RestTemplate来通信的方式，是有问题的。因为，我们在使用的同时，规定了HTTP地址与端口。 一旦我们的地址变化，需要手动更改。 一旦服务提供者做了集群（即多个节点），无法实现负载均衡。 服务中心伴随着服务的规模变大，我们也不得不采用一种良好的方式来管理。 这样，我们需要一个很好的服务中心，来管理这些服务的提供者与消费者。 以下是服务治理，服务注册，与服务发现的基本概念。 当服务提供者向注册中心，进行服务的登记时。注册中心，以心跳的方式来“实时监控”提供者，一旦发现提供者提供的服务不可用了。就剔除相应不可用的服务 服务消费者，可以从注册中心那里，获得一份“服务清单”，从而选择调用相应的服务。 这里我们以nacos作为注册中心： 点我下载nacos 推荐将nacos装入C盘中。 因为nacos默认是以集群的方式启动，我们需要单机启动： 因此，通过命令行来单机启动nacos： 1startup.cmd -m standalone 这样，我们就将nacos的注册中心搭建好了。 现在我们需要，在各个nacos-provider提供者上，将自己的服务注册到nacos-server中。 nacos是基于c/s的，因此我们也将这些提供者称为nacos-client。 我们以上文RestTemplate的项目为例进行继续更进... 在服务提供者的pom文件中加入依赖 123456&lt;!--nacos客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上加上注解： 1@EnableDiscoveryClient 接下来，启动，我们就可以在nacos的注册中心中看到。 现在我们通过服务中心，来获得某个服务提供者的http地址端口，从而代替RestTemplate的调用方法。 123//注入我们的client @Autowired private DiscoveryClient discoveryClient; 然后通过相应的get方法来获取： 1234List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;service-product&quot;);ServiceInstance serviceInstance = instances.get(0);String host = serviceInstance.getHost(); //取http地址int port = serviceInstance.getPort(); //取port端口 之所以List集合来装，是因为，之后可能要用到集群，同一个服务可能放在不同的地方。 这样做也是有问题的，我们有可能有多个服务名相同的服务。 正如上图展示的那样，我们如何让多个服务都能被使用呢？ 因此涉及到负载均衡的思想了。 负载均衡 什么是负载均衡呢？所谓负载均衡，就是将负载（所谓的资源、接口的请求等等）按照一定规则分摊到多个服务器或者组件上。 比如，对于商品服务端口有8081以及8082. 某个时刻，来了一个请求，此时将其分配到第一个商品端口8081，紧接着又来了一个请求，此时将其分配到第二个商品端口8082.如此反复。 而负载均衡又分为服务器端的负载均衡以及客户端的负载均衡。 服务器端所谓服务器端的负载均衡，也就是说，等消费者服务的请求到达了服务器端，服务器端自己来决定分配到哪个提供者。 典型的例子是，Nginx负载均衡。 客户端负载均衡（推荐）而客户端的负载均衡，指的是在消费者的请求发送之前，就决定好发送到服务提供者的哪个端口。 实现负载均衡自定义负载均衡首先我们再创建一个ProductApplication的启动类，并且命名为ProductApplication2. 注意，serverport的端口号，必须与之前的ProductApplication不同的，但是MainClass必须相同。 这样我们就可以在Nacos中，查看到service-product就有两个实例。 接下来，我们在controller中修改代码，实现自定义随机选择。只要改变list的get(x)中的x值即可。 创建一个随机数，产生0~list的随机数。 使用Ribbon来负载均衡Ribbon是一个springcloud的实现负载均衡的组件。只需要在RestTemplate的Bean上加一个注解： 1@LoadBalanced 现在不需要端口了，Ribbon自动帮我们分配端口。因此，我们只需要提供者的服务名称即可。比如：service-product.Ribbon默认的负载均衡方式是轮询。即轮流使用每个端口！ 以下是Ribbon的各个负载均衡：我们通过以下代码来修改，对应提供者的负载均衡策略。 123# 将对应提供者名称的服务 的负载均衡方式修改service-product.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule 目前为止，我们整合了Nacos作为注册中心，用Ribbon作为负载均衡。 唯一需要解决的问题是，服务与服务之间的通信问题。我们一直用的RestTemplate，而这不是springcloud alibaba的官方组件。我们应该使用Feign这个组件来代替： Feign 服务通信 Feign是springcloud中的声明式基于伪Http的客户端，它使得调用远程的服务就像调用本地服务一样简单。 只需要创建一个接口以及一个注释即可。 而Feign呢，自动兼容了Ribbon，因此我们不需要手动声明Ribbon，而是可以直接使用Feign。 加入依赖12345&lt;!--feign实现服务之间的通信--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 启动类加上Feign注解1@EnableFeignClients //开启Feign 接下来，我们给消费者一个Service，这个Service与欲调用的提供者的Service相同。 这个Service用来将ProductService在OrderApplication中，模拟成本地服务。 123456@FeignClient(value = &quot;service-product&quot;)public interface ProductService &#123; @RequestMapping(&quot;/product/&#123;pid&#125;&quot;) Product findByPid(@PathVariable(&quot;pid&quot;) Integer pid);&#125; 最后，我们在OrderController当中去注入这个Service，就像调用本地服务一样。 使用SpringCloud注意事项 服务提供者与服务消费者的配置信息是否正确 Nacos的端口是否打开 服务提供者与服务消费者各自的端口是否打开 调用接口的时候 RequestMapping是否对应（参数非对象使用@RequestParam 对象使用@RequestBody) 使用Feign携带token：调用Feign时指定configuration=FeignPassToken.class 其中，FeignPassToken.class的代码如下： 123456789public class FeignPassToken implements RequestInterceptor &#123; @Override public void apply(RequestTemplate requestTemplate) &#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); //添加token 这样每次都能获取到request中的token requestTemplate.header(&quot;token&quot;, request.getHeader(&quot;token&quot;)); &#125;&#125; 高并发带来的问题 在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，但是由于网络原因或者其他原因，服务不能保证100%的可用，如果某个服务出现问题，由于这个服务可能出现在“级联调用”的服务链上，则可能出现服务雪崩、瘫痪等问题。 比如，有两个服务：服务A与服务B，其中服务A中有一个方法a1，服务B有一个方法b1。如果a1需要调用b1的过程中，b1自身或者网络发生了问题，那么大量的线程会阻塞在此处，无法得到释放。因此A服务发生瘫痪，无法使用。其中Tomcat官方的最大线程数为200~400之间。 为了测试高并发，我们可以： 首先设置项目的tomcat最大并发线程数。 打开Jmeter工具，添加新的Http请求取样器。 服务雪崩 什么时服务雪崩？所谓服务雪崩，指的就是在高并发环境下，由于服务于服务之间的依赖性，发生的故障会传播，会对整个微服务系统造成灾难性的后果。 举一个很简单的例子： 现在有三个服务A，B，C，每个服务中都有若干个方法。其中A服务调用B服务，B服务调用C服务。 ==在某一个时间节点上，C服务由于自身原因，挂掉了。== ==由于B服务一直在调用C服务，则导致（像上面提到的那样）线程一直阻塞，导致服务B挂掉。== ==依次类推，导致服务A挂掉。至此，整个微服务系统崩溃。== 雪崩发生的原因 容量设计不合理 高并发某个响应速度变慢 机器的资源内存耗尽 因此，我们需要做相应的容错处理。即某一个微服务出现问题，尽可能不要影响到其他微服务。 容错思想 针对雪崩现象，我们可以有以下集中方法来避免以及处理。 隔离，超时，限流，熔断以及降级。 隔离隔离的思想是，将错误隔离在独立的服务内，从而不会传播出去。 常见的隔离方式有，线程池隔离以及信号量隔离。 超时在A服务调用B服务的过程中，设置一个最大响应时间，如果超过了这个响应时间，还没有响应结果。则断开这个请求，并释放这个线程。 限流限制流量的输入与输出，即为了保证系统的稳固运行，比如一次只接受几个请求，不能再多。 熔断在A服务调用B服务的过程中，如果B服务发生了问题，则A服务暂时断开一会对B服务的调用，局部牺牲。然后，过一会儿之后，再继续调用B服务，若仍有问题，反反复复如此执行。 而服务熔断有以下几种状态： 熔断关闭状态：即不熔断，微服务系统处于正常运行中。 熔断半打开状态：是一种试探的状态，即运行自定义的流量规则，来调用服务。如果成功率达到预期，则不熔断，如果没有达到预期，则进入熔断开启状态。 熔断打开状态：即进行熔断限制，限制流量。 降级降级可以说是一种，使用备用方案的思想。 在A服务使用B服务的过程中，如果发生问题。则不指望继续调用B服务，而是使用A服务自己准备的一套备用方案。 常见的组件有：Spring cloud netflix 的 Hystrix（不再维护）与Spring cloud Alibaba的Sentinel。 Sentinel 入门 流量控制 熔断降级 系统负载保护 组成核心库与Dashboard控制面板。其中核心库能够运行于所有Java运行时环境，同时支持Dubbo与Spring cloud。 而Dashboard控制面板基于spring boot开发，打包后即可以运行。 依赖注意，我们是A服务调用B服务，而容错主要是在A服务进行。保证自己不受到B服务的影响。 12345&lt;!--Sentinel哨兵实现服务容错--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; 控制面板jar包下载点我去Github下载 带参数运行Jar包1java -Dserver.port=8888 -Dcsp.sentinel.dashboard.server=localhost:8888 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.2.jar 现在可以去对应的控制面板网页中，查看。用户名与密码均为sentinel。 与Nacos相同。在A服务中配置文件中，配置Sentinel控制台。 12345# Sentinel服务容错配置# 跟控制台交互的端口 随意指定未被占用的端口即可# 注意与命令行Jar包启动的端口对应spring.cloud.sentinel.transport.port=8888 spring.cloud.sentinel.transport.dashboard=localhost:8888 现在，启动Nacos并启动这个服务。 会发现Sentinel中，并没有检测到这个服务。为什么？因为，我们还需要去调用一下这个服务中的某个方法。 利用Postman工具调用某个方法后，可以看到控制面板中出现了对应的服务，以及刚才我们调用方法的时间。 Demo 基于QPS限制某个接口的请求数 这里我们基于QPS来限制对请求的访问，可选择对应的集群与否，来写对应的阈值以及参数。 超过阈值之后，会返回对应的信息。 Sentinel中的基本概念资源 所谓资源，就是Java应用程序中的任何内容，可以是一个服务，也可以是一个方法。甚至，可以是一段代码。一句话说，资源就是我们使用Sentinel保护的对象。 比如，上节内容中的selectCustomerInfo方法。 规则 规则，作用于资源之上。就是对于我们如何保护资源的定义！流控规则，熔断降级规则以及系统保护规则。 总之，我们需要在Sentinel中配置各种规则，来实现各种容错的功能。 Sentinel中有五种规则，流控，降级，热点，系统与授权规则。 流控规则 流量控制，其原理是监控应用流量的QPS或者并发线程数等指标。当达到指定的阈值后，对流量进行控制，以避免被请求高峰冲垮，从而保证了应用的高可用性。 资源名，默认请求路径。 来源，是对哪一个微服务进行限流。 基于QPS或者并发数来实现限流规则，达到阈值就返回Flow Limitting信息。 高级选项 直接流控时指定只对哪一个请求本身进行流控，关联流控是当与这个资源关联的资源达到阈值时，对这个资源进行限制。如果选择关联流控，就填写对应的关联资源的请求路径。适合于做项目的应用让步行为，比如Update的优先级高于Select，那么关联流控即可。 链路流控指的是，当从某个接口过来的资源达到限流条件时，进行控制。因为有可能Service中的方法，是有多个不同的Controller进行调用的。因此，我们可以指定某个Controller的链路流控。 注意，Spring cloud alibaba 2.1.0 是没有链路流控的。我们需要用SpringCloudAlibaba的2.1.1版本。 如果选择链路流控，我们需要给对应的Service实现层中的方法，添加对应的注解。 切换SpringCloud Alibaba版本为2.1.1.RELEASE 设置filter为false 设置配置类1spring.cloud.sentinel.filter.enabled=false 123456789101112131415161718192021@Configurationpublic class FilterContextConfig &#123; @Bean public FilterRegistrationBean sentinelFilterRegistration()&#123; /* * 以下设置是为了打开Sentinel中的链路流控规则 * 为了在多个Controller调用某一个资源的情况 * 根据链路来控制某一个controller的调用阈值 * */ FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new CommonFilter()); registration.addUrlPatterns(&quot;/*&quot;); //入口资源关闭聚合 registration.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, &quot;false&quot;); registration.setName(&quot;sentinelFilter&quot;); registration.setOrder(1); return registration; &#125;&#125; 定义Service实现层中的资源 @Override1234567@SentinelResource(&quot;selectSupplierById&quot;)public Supplier selectSupplierById(String supplierid) &#123; SupplierExample supplierExample = new SupplierExample(); SupplierExample.Criteria criteria = supplierExample.createCriteria(); criteria.andSupplieridEqualTo(supplierid); return supplierMapper.selectByExample(supplierExample).get(0);&#125; 这样我们可以从Sentinel控制面板中，看到对应的资源selectSupplierById. 接下来，我们可以保护这个资源。即给他设置流控规则。 其中，我们在链路流控规则中，指定对应的controller请求路径即可。错误信息： 1234567&#123; &quot;timestamp&quot;: &quot;2021-08-05T07:43:04.130+0000&quot;, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;message&quot;: &quot;No message available&quot;, &quot;path&quot;: &quot;/supplier/selectSupplierById&quot;&#125; 流控效果 快速失败，是一种直接抛出异常页面（可自定义）的效果。 Warm up，预热。指的是，一开始的阈值是设置的阈值的1/3，缓慢增大。 排队等待，指的是，超出阈值的那部分，需要等待。 熔断降级 Sentinel根据慢调用比例，异常比例以及异常数来对服务进行降级。 慢调用比例指的是，当资源的响应时间超过最大RT（以ms为单位，最大RT即最大响应时间）之后，资源进入准降级状态。如果接下来1s内持续进入5个请求（最小请求数），它们的RT都持续超过这个阈值，那么在接下来的熔断时长之内，就会对这个方法进行服务降级。 异常比例指的是，当资源的每秒请求数大于等于最小请求数，并且异常总数占通过量的比例超过比例阈值时，资源进入降级状态。 异常数指的是，当资源近1分钟的异常数目超过异常数阈值之后会进行服务降级。注意由于统计时间窗口是分钟级别的，若熔断时长小于60s，则结束熔断状态后仍可能再次进入熔断状态。 注意Sentinel默认统计的RT上限是4900ms，超出此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项-Dcsp.sentinel.statistic.max.rt=xxx来配置。 慢调用比例 异常比例我们可以根据对应资源所发生异常所占比例，来对其进行熔断降级。 比如，我们模拟一个异常发生率为0.33的Demo。 首先定义资源的熔断降级规则： 我们可以看到，比例阈值要小于我们实际发生的可能性（即容忍度要设置更低）。 成功的话，我们可以到已经设置的响应规则。 其次，在代码中模拟异常发生的场景。 123456789int i =0;@Override@SentinelResource(&quot;selectSupplierById&quot;)public Supplier selectSupplierById(String supplierid) &#123; i++; if(i % 3 == 0)&#123; throw new RuntimeException(); &#125;&#125; 异常数异常数的原理与异常比例相同。 热点规则热点参数留流控规则，其实是一种细粒度更高的流控规则，它允许将规则作用在方法的若干个参数上。 1@SentinelResource(&quot;selectSupplierById&quot;) 并且这个资源的方法需要有至少一个参数。 然后在新增页面中，对这个方法中的某个参数，进行限流。 授权规则 通过授权规则，我们可以指定服务来源的请求放行。比如，A服务与B服务都调用了C服务，因此我们可以选择，对于C服务来说，是A服务作为来源的全部放行还是B服务作为来源的全部放行。 若配置资源请求来源的白名单，即只有白名单上的才能通过。 相反，若配置资源请求来源的黑名单，即只有黑名单上的不能通过。 首先，我们需要写一个配置类，来自定义来源标准。 1234567891011121314151617/** * 配置Sentinel的授权规则中 自定义来源处理的配置类 * 比如A服务与B服务都要调用C服务 * 假设A服务在调用C服务时 才符合白名单或者黑名单上的规则 * 因此只会对A服务生效 */@Componentpublic class RequestOriginParserDefinition implements RequestOriginParser &#123; @Override public String parseOrigin(HttpServletRequest request) &#123; String serviceName = request.getParameter(&quot;serviceName&quot;); if(StringUtil.isNullOrEmpty(serviceName)) throw new RuntimeException(); return serviceName; &#125;&#125; 这里，我们考察，request域中是否存在serviceName。 如果没有，就报错。 接下来，我们在控制面板中继续配置白名单或者黑名单。可以看到，当我们request中的参数：serviceName为pc时，才会通过。 如果不提供serviceName参数，就会报错。比如： 而如果有，但是不为pc，就不会通过。 只有为pc时，才会通过。 黑名单的道理同样如此。 系统规则 自定义规则页面 由于不管是流控规则还是授权规则等等，他们返回的页面/JSON信息都是一致的。因而，我们不能看出到底是什么规则导致的。 现在，我们实现一个接口。来自定义判断所抛出的异常信息，到底是流控规则导致的还是其他规则导致的。 总共有这些规则：现在写一个配置类，来处理对应的异常，以及返回对应的错误信息： 1234567891011121314151617181920212223242526272829/** * 用来处理到底是因为什么规则 而抛出的异常 * 是熔断降级 还是流量控制 还是授权控制呢 还是热点规则呢 */@Componentpublic class SentinelExceptionHandler implements UrlBlockHandler &#123; @Override public void blocked(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws IOException &#123; //设置写回页面的内容编码信息 httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;); ResponseData data = null; if(e instanceof FlowException)&#123; data = new ResponseData(-1, &quot;抱歉，该接口已被限流！&quot;); &#125;else if(e instanceof DegradeException)&#123; data = new ResponseData(-2, &quot;抱歉，该接口已被熔断降级！&quot;); &#125; //写回JSON字符串到前端 httpServletResponse.getWriter().write(JSON.toJSONString(data)); &#125; @Data @AllArgsConstructor @NoArgsConstructor public class ResponseData&#123; private Integer code; private String message; &#125;&#125; 现在我们在控制面板中，对某个controller中的接口进行响应的规则设置，比如流控规则。 再运行，就会给出我们自定义的信息。 SentinelResource定义异常发生的处理逻辑 前面，我们说到，@SentinelResource注解可以将某个方法定义为资源。当然这个方法可以位于Controller中也可以位于Service中，同时我们还可以指定，当内部发生异常时，我们在哪一个Handler中处理。 在定义SentinelResource的同时，我们可以将这个Handler写在与这个注解同类的另一个方法中。 如图所示： 1234567891011121314151617181920212223242526/** * 模拟Sentinel中熔断降级规则中的异常比例问题 * * @param supplierid * @return */@Override@SentinelResource(value = &quot;selectSupplierById&quot;, blockHandler = &quot;blockHandler&quot;)public Supplier selectSupplierById(String supplierid) &#123; SupplierExample supplierExample = new SupplierExample(); SupplierExample.Criteria criteria = supplierExample.createCriteria(); criteria.andSupplieridEqualTo(supplierid); return supplierMapper.selectByExample(supplierExample).get(0);&#125;/** * blockHandler要与对应的方法名，参数相同，且可以多一个参数BlockException * 来描述 所触发的对应异常：可以是限流，可以是熔断降级，可以是授权规则... * @param supplierid * @param e * @return */public Supplier blockHandler(String supplierid, BlockException e) &#123; System.out.println(&quot;捕获到异常，异常内容为：&quot; + e); return null;&#125; 同样，如果是检测到Throwable(是Exception与Error的父类)。 指定fallback，规则与blockHandler相同。 执行顺序是，发生异常先走blockHandler，如果没有blockHandler，才会走Throwable。 通俗的说，blockhandler中定义的是，触发了Sentinel中的BlockException时，才走。 如果是这些异常以外的Exception，则会走Fallback。 将处理异常逻辑写在一个异常类中新建一个异常类XXXBlockHandler.java 然后指定资源对应的blockHandlerClass 然后将对应的异常方法，即尾添BlockException对象，粘贴至该异常类中，其中方法添加static修饰符。 1234567891011/** * blockHandler要与对应的方法名，参数相同，且可以多一个参数BlockException * 来描述 所触发的对应异常：可以是限流，可以是熔断降级，可以是授权规则... * @param supplierid * @param e * @return */public static Supplier blockHandler(String supplierid, BlockException e) &#123; System.out.println(&quot;捕获到异常，异常内容为：&quot; + e); return null;&#125; Sentinel所有规则的持久化 目前为止，我们已经学会了如何设置一些微服务管理的规则。然而，不足的是，这些规则目前为止是存储在内存中的。也就是说，当我们重新启动微服务的时候，会清空这些规则。 因此，我们需要对这些规则进行持久化保存。 也就是说，我们在控制面板设置规则的同时，需要存储在文件中去。 现在我们编写一个存储到文件中的配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package com.example.telesys.config;import com.alibaba.csp.sentinel.command.handler.ModifyParamFlowRulesCommandHandler;import com.alibaba.csp.sentinel.datasource.*;import com.alibaba.csp.sentinel.init.InitFunc;import com.alibaba.csp.sentinel.slots.block.authority.AuthorityRule;import com.alibaba.csp.sentinel.slots.block.authority.AuthorityRuleManager;import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule;import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRuleManager;import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRuleManager;import com.alibaba.csp.sentinel.slots.system.SystemRule;import com.alibaba.csp.sentinel.slots.system.SystemRuleManager;import com.alibaba.csp.sentinel.transport.util.WritableDataSourceRegistry;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.TypeReference;import org.springframework.beans.factory.annotation.Value;import java.io.File;import java.io.IOException;import java.util.List;/** * 将Sentinel中的规则存储在文件中 * 这样下次加载的时候 会去文件中加载 */public class SentinelFilePersistence implements InitFunc &#123; @Value(&quot;spring.application.name&quot;) private String applicationName; @Override public void init() throws Exception &#123; // TIPS: 如果你对这个路径不喜欢，可修改为你喜欢的路径 String ruleDir = System.getProperty(&quot;user.home&quot;) + &quot;/sentinel/rules&quot; + applicationName; String flowRulePath = ruleDir + &quot;/flow-rule.json&quot;; String degradeRulePath = ruleDir + &quot;/degrade-rule.json&quot;; String systemRulePath = ruleDir + &quot;/system-rule.json&quot;; String authorityRulePath = ruleDir + &quot;/authority-rule.json&quot;; String paramFlowRulePath = ruleDir + &quot;/param-flow-rule.json&quot;; this.mkdirIfNotExits(ruleDir); this.createFileIfNotExits(flowRulePath); this.createFileIfNotExits(degradeRulePath); this.createFileIfNotExits(systemRulePath); this.createFileIfNotExits(authorityRulePath); this.createFileIfNotExits(paramFlowRulePath); // 流控规则 ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleRDS = new FileRefreshableDataSource&lt;&gt;( flowRulePath, flowRuleListParser ); // 将可读数据源注册至FlowRuleManager // 这样当规则文件发生变化时，就会更新规则到内存 FlowRuleManager.register2Property(flowRuleRDS.getProperty()); WritableDataSource&lt;List&lt;FlowRule&gt;&gt; flowRuleWDS = new FileWritableDataSource&lt;&gt;( flowRulePath, this::encodeJson ); // 将可写数据源注册至transport模块的WritableDataSourceRegistry中 // 这样收到控制台推送的规则时，Sentinel会先更新到内存，然后将规则写入到文件中 WritableDataSourceRegistry.registerFlowDataSource(flowRuleWDS); // 降级规则 ReadableDataSource&lt;String, List&lt;DegradeRule&gt;&gt; degradeRuleRDS = new FileRefreshableDataSource&lt;&gt;( degradeRulePath, degradeRuleListParser ); DegradeRuleManager.register2Property(degradeRuleRDS.getProperty()); WritableDataSource&lt;List&lt;DegradeRule&gt;&gt; degradeRuleWDS = new FileWritableDataSource&lt;&gt;( degradeRulePath, this::encodeJson ); WritableDataSourceRegistry.registerDegradeDataSource(degradeRuleWDS); // 系统规则 ReadableDataSource&lt;String, List&lt;SystemRule&gt;&gt; systemRuleRDS = new FileRefreshableDataSource&lt;&gt;( systemRulePath, systemRuleListParser ); SystemRuleManager.register2Property(systemRuleRDS.getProperty()); WritableDataSource&lt;List&lt;SystemRule&gt;&gt; systemRuleWDS = new FileWritableDataSource&lt;&gt;( systemRulePath, this::encodeJson ); WritableDataSourceRegistry.registerSystemDataSource(systemRuleWDS); // 授权规则 ReadableDataSource&lt;String, List&lt;AuthorityRule&gt;&gt; authorityRuleRDS = new FileRefreshableDataSource&lt;&gt;( authorityRulePath, authorityRuleListParser ); AuthorityRuleManager.register2Property(authorityRuleRDS.getProperty()); WritableDataSource&lt;List&lt;AuthorityRule&gt;&gt; authorityRuleWDS = new FileWritableDataSource&lt;&gt;( authorityRulePath, this::encodeJson ); WritableDataSourceRegistry.registerAuthorityDataSource(authorityRuleWDS); // 热点参数规则 ReadableDataSource&lt;String, List&lt;ParamFlowRule&gt;&gt; paramFlowRuleRDS = new FileRefreshableDataSource&lt;&gt;( paramFlowRulePath, paramFlowRuleListParser ); ParamFlowRuleManager.register2Property(paramFlowRuleRDS.getProperty()); WritableDataSource&lt;List&lt;ParamFlowRule&gt;&gt; paramFlowRuleWDS = new FileWritableDataSource&lt;&gt;( paramFlowRulePath, this::encodeJson ); ModifyParamFlowRulesCommandHandler.setWritableDataSource(paramFlowRuleWDS); &#125; private Converter&lt;String, List&lt;FlowRule&gt;&gt; flowRuleListParser = source -&gt; JSON.parseObject( source, new TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123; &#125; ); private Converter&lt;String, List&lt;DegradeRule&gt;&gt; degradeRuleListParser = source -&gt; JSON.parseObject( source, new TypeReference&lt;List&lt;DegradeRule&gt;&gt;() &#123; &#125; ); private Converter&lt;String, List&lt;SystemRule&gt;&gt; systemRuleListParser = source -&gt; JSON.parseObject( source, new TypeReference&lt;List&lt;SystemRule&gt;&gt;() &#123; &#125; ); private Converter&lt;String, List&lt;AuthorityRule&gt;&gt; authorityRuleListParser = source -&gt; JSON.parseObject( source, new TypeReference&lt;List&lt;AuthorityRule&gt;&gt;() &#123; &#125; ); private Converter&lt;String, List&lt;ParamFlowRule&gt;&gt; paramFlowRuleListParser = source -&gt; JSON.parseObject( source, new TypeReference&lt;List&lt;ParamFlowRule&gt;&gt;() &#123; &#125; ); private void mkdirIfNotExits(String filePath) throws IOException &#123; File file = new File(filePath); if (!file.exists()) &#123; file.mkdirs(); &#125; &#125; private void createFileIfNotExits(String filePath) throws IOException &#123; File file = new File(filePath); if (!file.exists()) &#123; file.createNewFile(); &#125; &#125; private &lt;T&gt; String encodeJson(T t) &#123; return JSON.toJSONString(t); &#125;&#125; 紧接着，我们需要在resources文件夹中新建META-INF文件夹，再在META-INF文件夹中创建services文件夹。 在services文件夹中创建一个File，名为： 1com.alibaba.csp.sentinel.init.InitFunc 然后在这个文件中，键入我们实现Sentinel持久化的配置类的路径。 1com.example.telesys.config.SentinelFilePersistence 现在我们就可以实现规则的持久化，对于已经设置好的规则，重启微服务后，并不会使之消失。 Feign整合Sentinel实现服务容错指定Fallback 引入Sentinel的依赖 12345&lt;!--Sentinel哨兵实现服务容错--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; 在服务调用方开启Feign对Sentinel的支持，比如A调用B，在A配置文件中 12# 开启Feign对Sentinel的支持feign.sentinel.enabled=true 注意，这里的容错类的作用是：当默认的XXXService在Feign的远程调用下不起作用时。我们使用自定义的容错类作为，备用方案。 所以我们在A服务调用B服务的过程中，在A的Service层中创建fallback目录，并写调用服务B对应的容错类即可。 创建容错类 12345678910111213141516171819202122232425262728//这里比如Customer服务调用CustomerOrder服务/** * 这个是Customer服务调用Customerorder服务过程中 出现异常的备用方案 */@Servicepublic class CustomerorderServiceFallback implements CustomerorderService &#123; @Override public int insertPhoneOrder(Customerorder customerorder) &#123; return 0; &#125; @Override public PageInfo selectMyOrders(String username, Integer currentPageNumber, Integer currentPageSize) &#123; System.out.println(&quot;检测到发生错误！目前正在使用容错方案...&quot;); return null; &#125; @Override public int insertBroadbandOrder(Customerorder order) &#123; return 0; &#125; @Override public int insertTrafficOrder(Customerorder order) &#123; return 0; &#125;&#125; 在正常方案中，指定对应的备用方案类 12345@FeignClient( value = &quot;service-customerorder&quot;, configuration = FeignPassToken.class, fallback = CustomerorderServiceFallback.class)public interface CustomerorderService &#123;&#125; 现在我们模拟出现错误，即在Customer调用Customerorder的过程中，事先将Customerorder服务关掉。这样，正常的话，就会走我们fallback的备用方案了。 正常情况下POSTMAN的数据返回情况是： 若关闭Customerorder服务后，还能返回数据而不是报500错误，则备用方案成功。 指定FallbackFactory容错工厂由于指定Fallback后，无法发现异常，则后台日志无法发现错误。 为了替代这种BUG，即如果想要在容错类中拿到对应的错误，异常，则我们使用fallbackfactory这种方式。 只需要修改容错类即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.telesys.service.fallback;import com.example.telesys.pojo.Customerorder;import com.example.telesys.service.CustomerorderService;import com.github.pagehelper.PageInfo;import feign.hystrix.FallbackFactory;import org.springframework.stereotype.Service;import java.util.ArrayList;/** * 这是一个泛型的容错类 * 在这个容错类中 发生错误的时候 * 我们可以将对应的错误也传入进来 通过Throwable 我们可以 * 根据自己的需求来处理即可 */@Servicepublic class CustomerorderServiceFallbackFactory implements FallbackFactory&lt;CustomerorderService&gt; &#123; /** * 我们可以看到Throwable可以获得 我们可以自己处理这个throwable * @param throwable * @return */ @Override public CustomerorderService create(Throwable throwable) &#123; return new CustomerorderService() &#123; @Override public int insertPhoneOrder(Customerorder customerorder) &#123; return 0; &#125; @Override public PageInfo selectMyOrders(String username, Integer currentPageNumber, Integer currentPageSize) &#123; System.out.println(throwable); PageInfo pageInfo = new PageInfo(); pageInfo.setList(new ArrayList()); return pageInfo; &#125; @Override public int insertBroadbandOrder(Customerorder order) &#123; return 0; &#125; @Override public int insertTrafficOrder(Customerorder order) &#123; return 0; &#125; &#125;; &#125;&#125; 然后我们指定对应的FallbackFactory即可。 123456@FeignClient( value = &quot;service-customerorder&quot;, configuration = FeignPassToken.class, fallbackFactory = CustomerorderServiceFallbackFactory.class)public interface CustomerorderService &#123;&#125; SpringCloud Gateway服务网关的背景 在使用SpringCloud gateway之前，其实存在着若干个问题：跨域问题，认证鉴权问题，各个微服务的IP地址与端口等等... 所谓的API网关，就是系统的统一入口，为系统提供一些必要的、非业务逻辑的公共功能：认证，鉴权，监控以及路由转发。 SpringCloud Alibaba是没有专门提供网关服务的，因此我们使用SpringCloud Gateway来完成这些功能。 Gateway 入门案例 在本次案例中，我们要实现一个功能。访问我们端口号为7000的SpringCloud Gateway，并且根据我们的请求路径，自动转发到对应的服务端口，并且这个服务端口不写死，而是从Nacos服务中心读取。 创建子模块xxx-gateway在子模块中加入依赖 注意，只能加入一个依赖，其他的不需要。 12345678910111213&lt;dependencies&gt; &lt;!--SpringCloud Gateway 服务网关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--nacos客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动子类，启动服务发现12345678910111213package com.example.telesys;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class MyGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyGatewayApplication.class, args); &#125;&#125; 配置文件，列举所有服务以及nacos端口1234567891011121314151617181920212223242526272829server.port=7000spring.application.name=service-gateway# 注册中心端口spring.cloud.nacos.discovery.server-addr=localhost:8848# 让gateway可以定位到本地的nacosspring.cloud.gateway.discovery.locator.enabled=true# 配置多个路由/路由数组# 路由也即是 对应的微服务与路径之间的关系# id是标识 需要唯一 默认是UUid 一般自定义# 格式是： xxxx_routespring.cloud.gateway.routes[0].id=supplier_route# uri是路径 注意这里没写死 而是从nacos中加载spring.cloud.gateway.routes[0].uri=lb://service-supplier# order是优先级 越小优先级越高spring.cloud.gateway.routes[0].order=1# predicates代表断言 即转发请求需要满足的条件# 每项的返回值为Boolean类型# predicates 也是一个数组spring.cloud.gateway.routes[0].predicates[0]= Path=/supplier/**# filters也是一个数组 是在请求传递过程中 对请求做一些手脚# 比如更改请求路径 增加header头部信息等等#spring.cloud.gateway.routes[0].filters[0] 而如果不配置某一项，那么地址为： 1http://localhost:7000/service-product/接口地址 Gateway详解 执行过程 断言 Predicates用于进行条件判断，只有断言返回真。即满足什么条件时，走这个路由。 Gateway的内置断言基于Datetime类型的断言 AfterRouterPredicateFactory，接收一个日期参数，判断传过来的日期是否晚于我们指定的日期。 基于远程地址远程地址路由断言工厂，它的实现类是RemoteAddrRoutePredicateFactory，它有一个List列表的参数，这些参数是CIDR-notation（IPv4和IPv6）的地址字符串，比如192.168.0.1/24. 如果请求的客户端的ip地址是192.168.1.1到192.168.1.24的范围，此断言返回true。 基于Path路径1- Path=/foo/&#123;segment&#125;,/bar/&#123;segment&#125; 如果请求的URI中的路径是/foo/1,/foo/bar或/bar/baz，这个断言将返回true。 基于请求头部Header这个Predicate工厂的实现类是HeaderRoutePredicateFactory，它有两个参数，一个是name，另一个是正则表达式。 12345678spring: cloud: gateway: routes: - id: header_route uri: http://www.xinyues.com predicates: - Header=X-Request-Id, \\d+ 如果请求的Header里面有name的值，并且它的值与配置的正则表达式匹配，则断言返回true，如果没有配置正则表达式的值，断言也是返回true（断方只检测带正则表达式的配置）,将会把请求路由到http://www.xinyues.com网站。上面的配置示例表示Header中必须有X-Request-Id,且它的值必须是数字。 基于路由权重如果多个路由都能匹配，我们希望给同一个group的不同的权重。 接收一个[组名，权重]，对于同一个组的路由进行按权重大小转发。 123predicates: - Weight = group1, 1 ... 自定义断言比如我们要限制年龄为18~60范围内的用户才能进入。 首先我们在配置文件中添加断言： 123456789# predicates代表断言 即转发请求需要满足的条件# 每项的返回值为Boolean类型# predicates 是一个数组# Path断言 当满足这样的路径形式 才能通过spring.cloud.gateway.routes[0].predicates[0] = Path=/supplier/** # 自定义断言 只允许Age在18-60范围内进入spring.cloud.gateway.routes[0].predicates[1] = Age=18,60 然后我们创建一个自定义断言工厂类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.example.telesys.predicates;import org.apache.commons.lang.StringUtils;import org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import java.util.Arrays;import java.util.List;import java.util.function.Predicate;/** * 注意这是自定义的断言工厂 * 1. 类的命名必须为 关键字+RoutePredicateFactory * 其中关键字必须对于配置文件Predicates数组中的【关键字】配置 * 2. 并且必须集成AbstractXXX&lt;配置类&gt; */@Componentpublic class AgeRoutePredicateFactory extends AbstractRoutePredicateFactory&lt;AgeRoutePredicateFactory.Config&gt; &#123; public AgeRoutePredicateFactory() &#123; super(AgeRoutePredicateFactory.Config.class); &#125; // 将配置文件中的值按返回集合的顺序，赋值给配置类的属性上 @Override public List&lt;String&gt; shortcutFieldOrder() &#123; return Arrays.asList(new String[]&#123;&quot;minAge&quot;, &quot;maxAge&quot;&#125;); &#125; // 具体的断言逻辑 @Override public Predicate&lt;ServerWebExchange&gt; apply(AgeRoutePredicateFactory.Config config) &#123; //Lambda表达式 return (ServerWebExchange serverWebExchange) -&gt; &#123; // TODO 获取URL中的请求参数age，判断是否满足[18, 60) String age = serverWebExchange.getRequest().getQueryParams().getFirst(&quot;age&quot;); if (StringUtils.isEmpty(age)) &#123; return false; &#125; if (!age.matches(&quot;[0-9]+&quot;)) &#123; return false; &#125; int iAge = Integer.parseInt(age); if (iAge &gt;= config.minAge &amp;&amp; iAge &lt; config.maxAge) &#123; return true; &#125; else &#123; return false; &#125; &#125;; &#125; // 配置类，属性用于接收配置文件中的值 public static class Config &#123; private int minAge; private int maxAge; public Config(int minAge, int maxAge) &#123; this.minAge = minAge; this.maxAge = maxAge; &#125; public Config() &#123; &#125; public int getMinAge() &#123; return minAge; &#125; public void setMinAge(int minAge) &#123; this.minAge = minAge; &#125; public int getMaxAge() &#123; return maxAge; &#125; public void setMaxAge(int maxAge) &#123; this.maxAge = maxAge; &#125; &#125;&#125; 然后我们在Postman工具中测试： 过滤器 在SpringCloud中的Gateway中，我们的过滤器大致有两种。第一种是请求到达后端接口之前，第二种是从后端返回给前端过程中的。 Pre 过滤器这种过滤器在请求被路由之前调用，我们可以用这种过滤器来做，反向代理，负载均衡以及身份验证。 Post 过滤器这种过滤器，我们可以在返回给前端之前，统一对Header进行处理， 或者收集统计一些信息等等。 生命周期 分为局部过滤器与全局过滤器，所谓局部过滤器，作用于某一个路由上。而全局过滤器，作用在全部路由上，从而不需要为某一个路由进行配置。 Tips：每个过滤器工厂都对应一个实现类，并且这些类的名称必须以GatewayFilterFactory结尾，这是Spring Cloud Gateway的一个约定，例如AddRequestHeader对应的实现类为AddRequestHeaderGatewayFilterFactory。 自定义局部过滤器模拟日志依照上节Age断言的写法，首先我们在配置文件中，加上filters相关的配置。 123# filters也是一个数组 是在请求传递过程中 对请求做一些手脚# 比如更改请求路径 增加header头部信息等等spring.cloud.gateway.routes[0].filters[0] = Log=true 然后创建响应的局部过滤器，注意命名与配置文件对应： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.example.telesys.filters;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;import org.springframework.stereotype.Component;import java.util.Arrays;import java.util.List;/** * 注意这是自定义的断言工厂 * 1. 类的命名必须为 关键字+GatewayFilterFactory * 其中关键字必须对于配置文件Predicates数组中的【关键字】配置 * 2. 并且必须集成AbstractXXX&lt;配置类&gt; */@Componentpublic class LogGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;LogGatewayFilterFactory.Config&gt; &#123; public LogGatewayFilterFactory() &#123; super(LogGatewayFilterFactory.Config.class); &#125; //具体的过滤逻辑 @Override public GatewayFilter apply(LogGatewayFilterFactory.Config config) &#123; return (exchange, chain) -&gt; &#123; if (config.isLog()) &#123; System.out.println(&quot;进入局部过滤器中...&quot;); System.out.println(&quot;检测到日志开启状态....&quot;); &#125; return chain.filter(exchange); &#125;; &#125; //赋值到Config配置类中的属性上 @Override public List&lt;String&gt; shortcutFieldOrder() &#123; return Arrays.asList(&quot;log&quot;); &#125; public static class Config &#123; private boolean log; public Config(boolean log) &#123; this.log = log; &#125; public Config() &#123; &#125; public boolean isLog() &#123; return log; &#125; public void setLog(boolean log) &#123; this.log = log; &#125; &#125;&#125; 然后就可以测试了. Gateway 全局过滤器 与局部过滤器相比，全局过滤器对于企业开发的一些业务功能处理，特别是鉴权等，还是具有很大的优点的。 利用全局过滤器实现鉴权所谓实现鉴权，就是在访问时，在Gateway处，检测Request中是否存在token作为Parameter。 自定义全局过滤器需要实现GlobalFilter以及Ordered接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.example.telesys.filters;import io.netty.util.internal.StringUtil;import org.apache.commons.lang.StringUtils;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;/** * 利用全局过滤器来实现 对所有路由 所有微服务 统一鉴权的功能 * 即每次查看Request中是否有Token这个Param * 如果有则通过 否则给出错误信息 */@Componentpublic class AuthTokenGlobalFilter implements GlobalFilter, Ordered &#123; /** * 过滤器逻辑编写 首先判断是否携带Token并且Token信息正确 * 如果没有 或者Token信息不正确 则返回错误信息 * * @param exchange * @param chain * @return */ @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; String tokenFromURL = exchange.getRequest().getQueryParams().getFirst(&quot;token&quot;); String tokenFromHeader = exchange.getRequest().getHeaders().getFirst(&quot;token&quot;); //如果URL以及Header中的Token为空 或不为指定值 视为失败（具体判定逻辑可以根据自己项目） if (!StringUtils.equals(&quot;token&quot;, tokenFromURL) &amp;&amp; !StringUtils.equals(&quot;token&quot;, tokenFromHeader)) &#123; //认证失败 返回状态码为UNAUTHORIZED exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); return exchange.getResponse().setComplete(); &#125; //否则通行 return chain.filter(exchange); &#125; /** * 标识当前过滤器的优先级 值越小其优先级越高 * * @return */ @Override public int getOrder() &#123; return 0; &#125;&#125; 启动项目并且用Postman工具测试，如果请求的URL或者Header不添加Token信息：","categories":[{"name":"Spring 全家桶学习","slug":"spring-全家桶学习","permalink":"https://github.com/Vincent990413/blog/categories/spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Spring 全家桶学习","slug":"spring-全家桶学习","permalink":"https://github.com/Vincent990413/blog/tags/spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"Mock.js学习","slug":"Mockjs学习","date":"2021-08-05T02:54:08.000Z","updated":"2021-11-09T07:53:30.203Z","comments":true,"path":"Mockjs学习/","link":"","permalink":"https://github.com/Vincent990413/blog/Mockjs%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Mock.js 一般而言，Mock.js可以负责，前端生成随机数据，以及拦截Ajax请求来返回自己的随机数据。 安装Mock1npm install mockjs 在项目中新建mock/index.js引入mock模块 1import Mock from &#x27;mockjs&#x27;; 将Mock文件在Main.js中导入这个index.js 1import &#x27;./mock/index.js&#x27;; 使用Mock模拟数据点我进入Mock官方网站 生成字符串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//生成min~max的字符串Mock.mock(&#123; &quot;string|1-10&quot;: &quot;★&quot;&#125;)//生成指定出现次数的string 3次Mock.mock(&#123; &quot;string|3&quot;: &quot;★★★&quot;&#125;)//以c开头代表 生成的都是中文Chinese//指定中文文本 长度为3~10之间的范围string: &#x27;@cword(3, 10)&#x27;;//生成标题与句子&#123; title: &quot;@ctitle(5)&quot;, sentence: &quot;@csentence(3,10)&quot;&#125;//生成段落&#123; content: &quot;@cparagraph()&quot;&#125;//生成数字&#123; &#x27;number|1-100&#x27;: 10&#125;//生成自增id&#123; id: &quot;@increment&quot;&#125;//生成姓名 地址加上true代表同时给出省份 身份证号&#123; name : &#x27;@cname()&#x27;, address: &#x27;@city(true)&#x27;, idCard: &#x27;@id()&#x27;&#125;//生成图片 //参数一，图片大小。参数二，背景色。参数三，文字颜色。参数四，图片格式。参数五，文字。&#123; imageUrl: &quot;@image(&#x27;250x250&#x27;,&#x27;#FFA07A&#x27;,&#x27;#FFBBFF&#x27;,&#x27;png&#x27;,&#x27;困困&#x27;)&quot;&#125;//生成时间 xxxx-xx-xx为默认 同时也可以指定格式&#123; date: &#x27;@date(yyyy-MM-dd hh:mm:ss)&#x27;&#125;//生成数组&#123; &#x27;list|8&#x27;:[ &#123; name: &#x27;@cname()&#x27;, address: &#x27;@city(true)&#x27; &#125; ]&#125; 使用Mock拦截请求Get与Post 请求的接口地址 请求方式 回调函数12345678910111213Mock.mock(&#x27;/api/news&#x27;, &#x27;get&#x27;,&#123; code: 200, message: &quot;获取数据成功！&quot;&#125;);//或者Mock.mock(&#x27;/api/news&#x27;, &#x27;get&#x27;,()=&gt;&#123; return&#123; code: 200, message: &quot;获取数据成功！&quot; &#125;&#125;); 然后我们就可以用axios来请求。","categories":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"Nginx实现前端Vue的反向代理","slug":"Java技巧-Nginx实现前端Vue的反向代理","date":"2021-07-26T00:52:28.000Z","updated":"2021-11-09T07:53:30.192Z","comments":true,"path":"Java技巧-Nginx实现前端Vue的反向代理/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-Nginx%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AFVue%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/","excerpt":"","text":"前端的request.js的请求配置request.js 123456// 创建axios实例 baseURL不变 一直是Vue的默认端口8080const service = axios.create(&#123; withCredentials: false, timeout: 10000, // 请求超时10秒 baseURL: process.env.BASE_API&#125;) 注意，我们请求的时候是 /user/showData 这种形式，这样Nginx才能根据不同的服务，监听到不同的服务端口。 Vue项目打包利用命令将项目打包 1npm run build 并将DIST目录下的所有资源，复制到Nginx的html目录下。 Nginx手动指定服务以及对应端口 注意对应微服务项目中，application.properties中自己指定的端口号。 nginx.conf 123456789101112131415161718192021222324server &#123; listen 8080; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; location /admin &#123; proxy_pass http://127.0.0.1:8181; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location /broadband&#123; proxy_pass http://127.0.0.1:8182; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"微服务Nacos集群部署以及Nginx负载均衡","slug":"Java技巧-微服务Nacos集群部署以及Nginx负载均衡","date":"2021-07-25T09:30:41.000Z","updated":"2021-11-09T07:53:30.195Z","comments":true,"path":"Java技巧-微服务Nacos集群部署以及Nginx负载均衡/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-%E5%BE%AE%E6%9C%8D%E5%8A%A1Nacos%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8ANginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"前提 在已经搭建好微服务项目后，我们从之前的单机模式，转为集群模式。 我们之前启动Nacos的命令是： 1startup.cmd -m standalone 更改Nacos内置的数据库 并配置MySQL数据库信息(版本5.7+)以及集群信息 创建数据库nacos_config.db，并初始化数据库中的表信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219/* * Copyright 1999-2018 Alibaba Group Holding Ltd. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info *//******************************************/CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(255) DEFAULT NULL, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;, `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_aggr *//******************************************/CREATE TABLE `config_info_aggr` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(255) NOT NULL COMMENT &#x27;group_id&#x27;, `datum_id` varchar(255) NOT NULL COMMENT &#x27;datum_id&#x27;, `content` longtext NOT NULL COMMENT &#x27;内容&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;, `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_beta *//******************************************/CREATE TABLE `config_info_beta` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `beta_ips` varchar(1024) DEFAULT NULL COMMENT &#x27;betaIps&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_tag *//******************************************/CREATE TABLE `config_info_tag` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tag_id` varchar(128) NOT NULL COMMENT &#x27;tag_id&#x27;, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_tags_relation *//******************************************/CREATE TABLE `config_tags_relation` ( `id` bigint(20) NOT NULL COMMENT &#x27;id&#x27;, `tag_name` varchar(128) NOT NULL COMMENT &#x27;tag_name&#x27;, `tag_type` varchar(64) DEFAULT NULL COMMENT &#x27;tag_type&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `nid` bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = group_capacity *//******************************************/CREATE TABLE `group_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `group_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;, `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;, `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = his_config_info *//******************************************/CREATE TABLE `his_config_info` ( `id` bigint(64) unsigned NOT NULL, `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) NOT NULL, `group_id` varchar(128) NOT NULL, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL, `md5` varchar(32) DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `src_user` text, `src_ip` varchar(50) DEFAULT NULL, `op_type` char(10) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = tenant_capacity *//******************************************/CREATE TABLE `tenant_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `tenant_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;, `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;, `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;CREATE TABLE `tenant_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `kp` varchar(128) NOT NULL COMMENT &#x27;kp&#x27;, `tenant_id` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tenant_name` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;, `tenant_desc` varchar(256) DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;, `create_source` varchar(32) DEFAULT NULL COMMENT &#x27;create_source&#x27;, `gmt_create` bigint(20) NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` bigint(20) NOT NULL COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;CREATE TABLE `users` ( `username` varchar(50) NOT NULL PRIMARY KEY, `password` varchar(500) NOT NULL, `enabled` boolean NOT NULL);CREATE TABLE `roles` ( `username` varchar(50) NOT NULL, `role` varchar(50) NOT NULL, UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE);CREATE TABLE `permissions` ( `role` varchar(50) NOT NULL, `resource` varchar(255) NOT NULL, `action` varchar(8) NOT NULL, UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE);INSERT INTO users (username, password, enabled) VALUES (&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, TRUE);INSERT INTO roles (username, role) VALUES (&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;); 默认用户名和密码均为nacos 添加Nacos的数据库信息&amp;集群信息 这里注意，一般设置的端口信息要跨度大一些。可以是：3333，4444，5555，6666等等！ 注意，每个集群中的Nacos都要更改端口，避免占用。 在application.properties中： 12345678910#*************** Spring Boot Related Configurations ***************#### Default web context path:server.servlet.contextPath=/nacos### Default web server port:server.port=3333db.num=1db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCdb.user.0=rootdb.password.0=123456 在其他集群中只更改自己的端口即可： 1server.port=3333/4444/5555 复制粘贴三份文件夹，除了修改自己的端口，其他配置信息保持一致。 将cluster.conf.exmaple改为cluster.conf 在集群配置中，都保持一致。 这个文件中，填写所有加入集群的ip地址:端口，尽量避免填写localhost或者127.0.0.1 而是直接写自己的IP地址。 1234# 所有集群的主机地址192.168.1.105:3333192.168.1.105:4444192.168.1.105:5555 以集群的方式启动Nacos在Nacos的bin目录下，直接双击startup.cmd，即可以集群的方式启动。 正常情况下，确保能以IP地址的形式访问Nacos。 1http://192.168.1.105:3333/nacos 配置Nginx以负载均衡 Loadbanlancing我们在http节点下，去配置我们的各个集群主机，以及对应的Weight权重。 以实现用户访问量大的情况下，自动根据权重承载请求。 123456789101112131415161718192021222324252627282930http &#123; # 设置nacos集群的各个端口设置（以及权重） upstream nacos-server &#123; server 127.0.0.1:3333 weight=3; server 127.0.0.1:4444 weight=2; server 127.0.0.1:5555 weight=1; &#125; # Nginx默认端口是80 这个监听是为了 直接访问nacos的注册中心Dashboard server &#123; listen 80; server_name nacos-test.cluster.com; location /&#123; # 以前是localhost:8848/nacos 现在更改了域名以及端口 而后面的/nacos不变 proxy_pass http://nacos-server/nacos/; &#125; &#125; # 这里是监听到 微服务项目中配置的Nacos地址 # 而最终8848走的proxy_pass 即我们在upstream中配置的服务器端口（根据权重） server &#123; listen 8848; server_name nacos-test.cluster.com; location /&#123; # 以前是localhost:8848/nacos 现在更改了域名以及端口 而后面的/nacos不变 proxy_pass http://nacos-server/; &#125; &#125;&#125; 启动Nginx.exe即可1nginx -c conf/nginx.conf 记得任务管理器中，若有需要，关掉Nginx.exe的全部进程。","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"微服务项目打包","slug":"Java技巧-微服务项目打包","date":"2021-07-25T04:35:16.000Z","updated":"2021-11-09T07:53:30.197Z","comments":true,"path":"Java技巧-微服务项目打包/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/","excerpt":"","text":"项目打包前期准备 首先在含有启动主类MyApplication.java模块的Pom.xml中 加入相应的打包插件，以及指定主类位置！ 其他模块如此照写。 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.telesys.MyUserApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在没有主类的通用模块xxx-common等等 注释掉相应的插件 即将build那一块注释掉即可。 如果是单体项目，直接点项目的Lifecycle中的Clean，然后点Package打包即可。 如果是微服务项目，点击Root根项目的Clean，然后点Install为各个子项目打包即可。 Jar包的位置在对应模块的Target目录下。 最后，将所有的jar包放在电脑中的某一个位置，新建一个startup.bat，来一键启动多个Jar包。 12345678910@echo offc: //jar包所在盘符 C盘cd C:\\Users\\Administrator.000\\Desktop\\jar //jar包所在文件夹 默认放在桌面start cmd /c &quot;title xxx &amp;&amp; java -jar tele-xxx-1.0-SNAPSHOT.jar&quot; //title 后面是命令行窗口的名称//重复即可...pause // 防止运行完毕后直接关闭界面 完毕","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"CentOS7.x精致使用","slug":"CentOS7-x精致使用","date":"2021-07-08T00:51:33.000Z","updated":"2021-11-09T07:53:30.181Z","comments":true,"path":"CentOS7-x精致使用/","link":"","permalink":"https://github.com/Vincent990413/blog/CentOS7-x%E7%B2%BE%E8%87%B4%E4%BD%BF%E7%94%A8/","excerpt":"","text":"CentOS7.x 安装JDK8首先下载后缀为.tar.gz格式的压缩包。 链接: https://pan.baidu.com/s/1ONYjAbN69wyM3YNF9zx_lw 提取码: iitz 复制这段内容后打开百度网盘手机App，操作更方便哦 其次，我们可以将这个压缩包，移动到路径/usr/下。 处于该压缩包的当前目录，键入此命令： 1mv ./jdk-8u221-linux-x64.tar.gz /usr 即移动到/usr 路径下。 接下来，进入/usr目录，创建一个子目录java并移动到里面，随后解压到里面。 1234567mkdir javamv ./jdk-8u221-linux-x64.tar.gz ./javacd javatar -zxvf jdk-8u221-linux-x64.tar.gz 然后我们需要全局进行配置： 1vim /etc/profile 并在最后一行中，键入以下命令： 12345#java environmentexport JAVA_HOME=/usr/java/这里填解压完成的文件名(jdk1.8xxx)export CLASSPATH=.:$&#123;JAVA_HOME&#125;/jre/lib/rt.jar:$&#123;JAVA_HOME&#125;/lib/dt.jar:$&#123;JAVA_HOME&#125;/lib/tools.jarexport PATH=$PATH:$&#123;JAVA_HOME&#125;/bin` 然后:wq保存。 1source /etc/profile 就可以生效了。输入代码查看版本号： 1java -version CentOS7.x 安装MySQL首先安装wget命令（若有则忽略这一步）： 1yum -y install wget 然后开始一次安装MySQL环境（若询问则键入y即可）： 123wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-community-server 若顺利完成，则可以重启MySQL服务： 1service mysqld restart 启动MySQL的命令： 1mysql -u root 第一次启动默认是没有密码的，通过以下命令设置初始密码： 1set password for &#x27;root&#x27;@&#x27;localhost&#x27; =password(&#x27;初始密码&#x27;); 设置MySQL可远程连接（必须是Root用户）： 1grant all privileges on *.* to root@&#x27;%&#x27;identified by &#x27;password&#x27;;","categories":[{"name":"Linux 学习","slug":"linux-学习","permalink":"https://github.com/Vincent990413/blog/categories/linux-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux 学习","slug":"linux-学习","permalink":"https://github.com/Vincent990413/blog/tags/linux-%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"项目_筋斗云商城","slug":"项目-筋斗云商城","date":"2021-06-28T08:11:03.000Z","updated":"2021-11-09T07:53:30.230Z","comments":true,"path":"项目-筋斗云商城/","link":"","permalink":"https://github.com/Vincent990413/blog/%E9%A1%B9%E7%9B%AE-%E7%AD%8B%E6%96%97%E4%BA%91%E5%95%86%E5%9F%8E/","excerpt":"","text":"仿黑马商城的APP下载链接：安卓_点我下载 H5手机网页端（推荐手机访问）：筋斗云商城","categories":[{"name":"项目","slug":"项目","permalink":"https://github.com/Vincent990413/blog/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://github.com/Vincent990413/blog/tags/%E9%A1%B9%E7%9B%AE/"}],"author":"vincent"},{"title":"uniapp学习笔记01-基本语法","slug":"uniapp学习笔记01-基本语法","date":"2021-06-20T14:20:47.000Z","updated":"2021-11-09T07:53:30.210Z","comments":true,"path":"uniapp学习笔记01-基本语法/","link":"","permalink":"https://github.com/Vincent990413/blog/uniapp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Uni-App 教程截图，笔记均转自哔哩哔哩黑马程序员。 Uniapp 介绍uniapp是一个使用Vue.js开发所有前端应用的框架，可发布到IOS、Android、微信小程序等平台。 官网文档： 点我进入uniapp官网文档 1. Vue以及微信小程序开发经验。 第一次用微信小程序预览时需要注意： 而且需要将微信开发工具的安全端口打开。 介绍项目目录其中： pages 存放页面相关.vue。 static 存放静态资源（图片、音频或者视频等）。 unpackage 存放打包后的资源，比如H5原生或者微信小程序等等。 pages.json对uni-app进行全局配置，决定页面文件的路径、窗口样式、原生导航栏以及底部的原生Tabbar等。 manifest.json时应用的配置文件，用于指定应用的名称、图标以及权限等。 App.vue时项目入口组件，main.js时用于初始化可能需要的插件。 component用于存放需要的组件。 uniapp需要遵守的一些重要规范： 全局样式配置 Global Style以上的全局配置，会对所有页面都生效。 注意，pages.json中的pages中的style是属于页面级的样式。这里的样式，会覆盖掉全局样式。 配置页面在pages.json中的page去配置所有页面，而第一个页面是启动页面。 1234567891011&#123; // &quot;path&quot;: &quot;pages/index/index&quot; &quot;path&quot;: &quot;pages/message/message&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;信息页&quot; //这里面的样式 会覆盖掉全局的样式 &#125; &quot;h5&quot;:&#123; //这里是h5的独有样式 见uniapp官网 &#125;&#125; 配置Tabbar选项栏如果应用是一个多tab应用，那么就可以配置相应的选项栏以及对应跳转的页面。 tabbar与pages、globalstyle同级。 如果选项卡在顶部（position:top），那么不会显示图标icon。（只对微信小程序起作用。） 装所有选项卡的tabBar中的list是一个数组（长度在2~5之间）。 其他关于tabbar的重要属性： color属于tabbar下的，16进制数，属于未选中时的颜色。selectedColor属于选中的颜色。borderStyle是边框颜色，只能是黑色或者白色。 而其中的list数组中，每一项都是一个对象，其具有的属性如下：2. 注意，pagePath是必须在pages数组中定义的页面路径。 实例代码： 12345678910111213&quot;tabBar&quot;: &#123; &quot;list&quot;: [&#123; &quot;text&quot;: &quot;首页&quot;, &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;static/icons/homeNotSelected.png&quot;, &quot;selectedIconPath&quot;: &quot;static/icons/homeSelected.png&quot; &#125;, &#123; &quot;text&quot;: &quot;信息&quot;, &quot;pagePath&quot;: &quot;pages/message/message&quot; &#125; ] &#125; 其中iconPath代表未选择时的图标，而selectedIconPath代表选中时的图标。 图标可以去这个网站（需要科学上网）找： 点我搜索图标 condition 是启动模式配置，它主要用于模拟直达某一个页面的常见，以方便进行开发调试。该模式还在开发期间生效。转，如何配置condition开发的直达页面 uniapp 中的组件组件，就像HTML中的标签（div、p等等）。 text文本组件用于显示文本。是行内元素，Text组件相当于Span标签，而View组件相当于Div。 重要属性如下：其中space属性中的值说明如下： 123&lt;view&gt; &lt;text selectable&gt;这是可选中的文本&lt;/text&gt;&lt;/view&gt; 有时，我们在text组件内手动写了连续的空格，但默认只会显示一个空格。想要显示多个空格，我们就可以，使用space属性，并按照要求写对应的值。 decode我们用于&amp;amp;解码成&amp;等转义字符（例如大于、小于等）。 View组件View相当于一个div的容器，盒子。且是独占一行的！ 重要属性如下： hover-class是指定手动按下去的样式类。 hover-stop-propagation表示可以阻止因手动按下去而导致的样式传播。（比如现在有一个父组件和子组件，如果我们只按父组件中的子组件区域，会触发父组件的样式变化， 如果父组件写了hover-class，如果想要阻止则使用这个属性。） hover-start-time代表多久才出现这个点击态。需要绑定:，数字才是Number类型，否则是string类型。stay是松开手后，保留多长时间。 Button 组件重要属性如下： Image 组件Image组件用于显示图片。 组件默认宽度 300px、高度 225px；app-nvue平台，暂时默认为屏幕宽度src 仅支持相对路径、绝对路径，支持 base64 码； 页面结构复杂，css样式太多的情况，使用 image 可能导致样式生效较慢，出现 “闪一下” 的情况，此时设置 image{will-change: transform} ,可优化此问题。 自定义组件里面使用 时，若 src 使用相对路径可能出现路径查找失败的情况，故建议使用绝对路径。 其中mode模式属性值为： uniapp 中的样式关于uniapp中重要的样式知识点如下： 宽度占满屏幕，则设置width:750rpx;代表100%因此若设置375rpx，则代表设置宽度占设备的一半，自适应，根据设备宽度自动调整。rpx也适用于文字。 @import可以导入外联样式表： 1@import url(&quot;../../static/css/global.css&quot;); page 就相当于body节点。 跟pages.json中的样式覆盖原理一样，App.vue中写的样式是全局样式，而每一个vue文件中写的，是局部样式。局部样式会覆盖全局样式！ uniapp 的插值表达式 见Vue的插值表达式。 123456789101112131415&lt;template&gt; &lt;view&gt; &#123;&#123; info &#125;&#125; &#123;&#123; 1 + 2 &#125;&#125; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export....data()&#123; return&#123; info: &quot;Hello, World!&quot; &#125;&#125;&lt;/script&gt; uniapp 的数据绑定见Vue的数据绑定。 123456789101112131415&lt;template&gt; &lt;view&gt; &#123;&#123; info &#125;&#125; &#123;&#123; 1 + 2 &#125;&#125; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export....data()&#123; return&#123; info: &quot;Hello, World!&quot; &#125;&#125;&lt;/script&gt; uniapp 的for遍历见Vue的for循环遍历 可以在需要引用的地方外部，写一个span，来写for. uniapp 的事件绑定以及传递参数见Vue的事件绑定。 uniapp 的生命周期应用的生命周期App.vue中存放应用的各个生命周期。 onLaunch只会触发一次，onShow和onHide会被多次触发。 123onError:function(err)&#123; console.log(&#x27;出现异常了：&#x27; + err);&#125; 页面的生命周期 注意，onLoad与onReady只会出现一次。而onShow和onHide会出现多次！ 当切换tabBar时，会触发对应的onHide以及对应的onHide。 常见函数事件下拉事件： 在pages.json中的pages中的某一个页面，来配置style: 1234567&#123; &quot;path&quot;: &quot;pages/index/index&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;首页&quot;, &quot;enablePullDownRefresh&quot;: true &#125;&#125;, 调用下拉的回调函数 1234onPullDownRefresh()&#123; console.log(&#x27;检测到下拉事件&#x27;); uni.stopPullDownRefresh(); //关闭下拉事件&#125; 在某事件中，指定下拉刷新（并延迟关闭下拉）： 123456refreshPage() &#123; uni.startPullDownRefresh(); setTimeout(() =&gt; &#123; uni.stopPullDownRefresh(); &#125;, 2000)&#125; 到达底部事件12345678onReachBottom()&#123;console.log(&#x27;在满足于pages.json中配置的距底部多少距离触发的距离后，触发！&#x27;);&#125;其中pages.json中配置如下：&quot;style&quot;:&#123; &quot;onReachBottomDistance&quot;: 10&#125; Get 网络请求 注意method如果不填，默认get方法。dataType是返回数据的类型，如果设置为JSON，那么会对数据做一次JSON.parse。 data中写get方法的请求参数。header中写请求携带的头信息，比如token等等。 实例代码：123456789uni.request(&#123; url: &quot;http://localhost:8181/api/getInfo&quot;, success(res) &#123; console.log(res); &#125;, fail(err) &#123; console.log(&quot;遇到了错误：&quot; + err); &#125;&#125;) Post请求 我们通过指定uni.request中的method来指定&quot;post&quot;即可以使用。 并且我们，直接将一个json对象作为data。 12345678910111213let _this = thisuni.request(&#123; url: &quot;http://api.apishop.net/common/joke/getJokesByRandom&quot;, data: this.jokeForm, method:&quot;POST&quot;, //sucess为成功回调函数 并且注意使用_this success(res) &#123; console.log(res) &#125;, fail(err) &#123; console.log(err) &#125;&#125;) 其他的属性以及参数，见官方文档。 uniapp 的缓存存储 12345678910//异步存储let key = &quot;info&quot;let value = this.infouni.setStorage(&#123; key: key, data: JSON.stringify(value), success: function() &#123; console.log(&#x27;存储成功！&#x27;) &#125;&#125;) 异步获取数据： 12345678let key = &quot;info&quot;uni.setStorage(&#123; key: key, success: function(res) &#123; console.log(&#x27;获取成功，数据为：&#x27;) console.log(res.data) &#125;&#125;) 异步移出数据： 1234567let key = &quot;info&quot;uni.removeStorage(&#123; key:key, success: function()&#123; alert(&quot;移除成功！&quot;); &#125;&#125;) 注意，以上均为异步操作。若想要同步操作，则使用setStorageSync(Object)即可。 uniapp 的图片上传与预览上传并显示在前端uni.chooseImage方法从本地相册选择图片或者使用相机拍照。 123456789uni.chooseImage(&#123; count: 5, success: res =&gt; &#123; // 上传图片的路径是res.tempFilePaths let path = res.tempFilePaths this.filePathArrays = path //可以选择存在数据库中 或者存储storage中 &#125;&#125;) 从路径中动态绑定图片的路径，从而直接显示出来。 1&lt;image v-for=&quot;item in filePathArrays&quot; :src=&quot;item&quot;&gt;&lt;/image&gt; 预览图片1234567//src 为图片的地址uni.previewImage(&#123; current: src, urls: this.imageArray, loop: true, indicator: &quot;number&quot;&#125;) uniapp 的条件注释条件注释用于实现跨端兼容，比如有些时候在微信小程序能运行但是H5端不行，等等.. 如何在前端页面中实现条件编译： 123&lt;!-- #ifdef MP-WEIXIN --&gt; &lt;view&gt;我希望只在微信小程序中可见！&lt;/view&gt;&lt;!-- #endif --&gt; 如何在JS中实现条件编译： 12345onLoad() &#123; //#ifdef MP-WEIXIN console.log(&#x27;我希望微信小程序中打印这句话！&#x27;); //#endif&#125;, 那么，如何在style中实现条件编译： 12345/* #ifdef H5 */ view&#123; color: blue; &#125;/* #endif */ uniapp 中的导航跳转1. 利用navigator组件进行声明式跳转： 1&lt;navigator url=&quot;/pages/message/message&quot;&gt;点我跳转&lt;/navigator&gt; 注意，这种情况下，是不能跳转到选项卡页面。而是普通页面！ 如果要跳转到选项卡页面。要设置open-type的值为switchTab： 如果open-type是redirect，那么会首先关闭当前页面而重定向到对应的页面。 2.编程式跳转 1234//跳转普通页面uni.navigateTo(&#123; url:&#x27;/pages/message/message&#x27;&#125;) 如果是选项卡切换，就是switchTab()。会关闭其他所有非选项卡的页面。 注意，如果直接navigateTo那么就不会关闭页面而是可以通过navigateBack来返回。而如果是redirect那么就会关闭当前页面，再导航到对应页面。 导航并传参 如果是navigator声明式跳转：123&lt;navigator style=&quot;background-color: #8F8F94;border: #007AFF 1rpx solid;&quot; url=&quot;/pages/message/message?id=1&quot;&gt;声明式跳转&lt;/navigator&gt; 那么我们需要在对应的目标页面的onload生命周期函数中： 123onLoad(options)&#123; console.log(options);&#125; uniapp 的组件以下方法完成组件的注册与使用。 12345import test from &quot;@/components/test.vue&quot;components: &#123;test&#125;&lt;test&gt; &lt;/test&gt; 组件的生命周期见Vue的生命周期。 uniapp 组件之间的传递见Vue的父子组件等等内容。 uniapp 中自定义全局事件绑定一个事件，来打印传过来的值： 123uni.$on(&#x27;fun&#x27;, data =&gt; &#123; console.log(data);&#125;); 1uni.emit(&#x27;fun&#x27;, 10); //传数据10过去","categories":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"Vue3.0学习笔记","slug":"vue3-0学习笔记","date":"2021-06-14T06:11:02.000Z","updated":"2021-11-09T07:53:30.211Z","comments":true,"path":"vue3-0学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/vue3-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Vue3.0+TypeScript 学习笔记Composition API 也称组合式API，是Vue3.x的新特性。通过创建Vue组件，我们可以将接口的可重复部分以及功能提取到可重用的代码段中。提高系统的可重用性。 常用函数 setup（所有CompAPI代码都写在这里） ref（字符串等类型） reactive（2、3用于定义响应式数据）（对象数据） watchEffect watch（监听数据） computed（负责复杂数据渲染） toRefs 生命周期的hooks 创建Vue3.x项目 请注意！以后的Vue3.x代码，最好使用TypeScript作为编程语言来编写。1vue create vue3_typescript 选择手动选择： 选择Vue3.0进入项目：项目结构图如下： 在setup中写自适应数据123setup() &#123; //ref以及reactive 用于定义响应式数据&#125; ref 定义string、number、boolean以及数组等基本类型 而reactive一般用于定义对象等组合型数据 声明响应式数据： 定义字符串等基本类型12// ref 定义string、number、boolean以及数组等基本类型 var title:any = ref(&quot;我是一个标题&quot;); 定义对象12345 //而reactive一般用于定义对象等组合型数据var userInfo:any = reactive(&#123; username: &quot;vincent&quot;, age: 20,&#125;); 我们需要将他们作为setup()函数的返回值！让前端页面能引用到。Vue3.0 + TypeScript 完整demo代码是： Home.vue 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;div&gt; &#123;&#123; userInfo &#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent, reactive, ref &#125; from &quot;vue&quot;;export default defineComponent(&#123; name: &quot;Home&quot;, components: &#123;&#125;, setup() &#123; //ref以及reactive 用于定义响应式数据 // ref 定义string、number、boolean以及数组等基本类型 var title:any = ref(&quot;我是一个标题&quot;); //而reactive一般用于定义对象等组合型数据 var userInfo:any = reactive(&#123; username: &quot;vincent&quot;, age: 20, &#125;); let getUserInfo = function (userInfo: any): any &#123; return userInfo; &#125;; return &#123; title, userInfo, getUserInfo, &#125;; &#125;,&#125;);&lt;/script&gt; 定义方法（箭头函数）# 当不知道要不要返回值的时候，可以使用箭头函数，该写参数写参数，该返回就返回。 123let getUserInfoArrow = () =&gt; &#123; return userInfo;&#125;; 我们在定义了ref数据后，如果想要在setup()函数中的任意一个地方更改这个ref数据，必须通过：user.value，才能获得值。 响应式数据的双向绑定注意，如果不用ref或者reactive响应式数据。 普通的数据，普通的对象，是不能完成双向绑定即应用于实时刷新的。 比如： let num:number = 0; let obj:any = { username: &quot;Vincent&quot;, age: 19} 而响应式数据的双向绑定代码是： 1234567&lt;input type=&quot;text&quot; v-model=&quot;title&quot; /&gt;setup() &#123; let title = ref(&quot;这是H1的标题~&quot;); return &#123; title, &#125;; ...toRefs(obj) 解构响应式对象默认情况下，我们定义了reactive对象并且return之后。在前端页面，是不能直接引用的，比如： title was accessed but is not defined 提示，我们想要获取这个title，但是他认为我们并没有去定义这个title，说明我们不能直接用reactive对象里面的某个属性，而应该首先让某个属性 变成ref自适应数据，即： Reactive对象的数据 -&gt; Ref 自适应数据 -&gt; 前端页面引用 因此，我们需要在return中加入: 12345678910setup() &#123; let news = reactive(&#123; title: &quot;新闻标题&quot;, content: &quot;这是新闻内容！&quot;, &#125;); return &#123; ...toRefs(news), &#125;; &#125;, 这样我们前端页面，可以使用： 1&#123;&#123; title &#125;&#125; 进行直接引用。 computed 属性我们可以利用computed属性来自动检测某些数据。并根据这些数据，满足我们的需求来处理。（官方说，任何复杂逻辑处理的代码都写在computed中） 现在我们有一个输入框，我们输入自适应对象user的成绩score 然后，通过computed来实时检测成绩，大于或者等于60分就算及格，否则不及格，要求及时弹出信息。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;获取用户信息&lt;/h1&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;score&quot; /&gt; &lt;div&gt; &#123;&#123; isPassedInfo &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent, reactive, ref, toRefs, computed &#125; from &quot;vue&quot;;export default defineComponent(&#123; name: &quot;Home&quot;, components: &#123;&#125;, setup() &#123; let user = reactive(&#123; score: 0, &#125;); let isPassedInfo = computed(():string =&gt; &#123; if (user.score &gt;= 60) &#123; return &quot;及格！&quot;; &#125; else &#123; return &quot;不及格！&quot;; &#125; &#125;); return &#123; ...toRefs(user), isPassedInfo, &#125;; &#125;,&#125;);&lt;/script&gt; watch与watchEffectwatchEffect 监听 响应式地跟踪其依赖项时，立即运行一个箭头函数，并在更改依赖项时，重新运行它。（这个依赖项是什么，具体要看箭头函数中所涉及到的变量。） 比如我们现在用控制台，在实时监视某输入框中内容的变化。 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent, reactive, ref, toRefs, watchEffect,&#125; from &quot;vue&quot;;export default defineComponent(&#123; name: &quot;Home&quot;, components: &#123;&#125;, setup() &#123; let data = reactive(&#123; num: 0, &#125;); //看箭头函数体中 所出现的就是依赖项！ watchEffect(() =&gt; &#123; //当data.num发生改变时 就会运行该方法 console.log(`num...为$&#123;data.num&#125;`); &#125;); return &#123; ...toRefs(data), &#125;; &#125;,&#125;);&lt;/script&gt; 可以看到的是，如果我们页面刷新几次，尽管依赖项没有发生改变，还是0，但仍然会执行这个方法。打印num...为0这句话多次。 watch其实watchEffect与watch都具有监听的作用。 watch可以指定监听的某一个对象，并且当这个对象里边的变量发生变化（从而引起这个对象发生变化），才会执行方法体。 12345678let data = reactive(&#123; num: 0, &#125;); //当data对象发生变化时 会执行方法体 watch(data, () =&gt; &#123; console.log(data.num); &#125;); 通过watch我们还可以获取到，变化前以及变化后的值。 1234567891011let data = ref(1); //注意current与prev都是对象 //等同于你监听的这个对象 里面的属性都与其相同 watch(data, (current, prev) =&gt; &#123; console.log(data + &quot;:当前值&quot; + current + &quot;,之前的值：&quot; + prev); &#125;); return &#123; data &#125;; 生命周期函数值得注意的是，setup()比beforeCreate以及created更先执行。因此，这两个我们不需要显式地去调用。 以下为所有生命周期函数调用的方法：我们来写一个onMounted（首先要引入）： 12345678910111213&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent, onMounted &#125; from &quot;vue&quot;;export default defineComponent(&#123; name: &quot;Home&quot;, components: &#123;&#125;, setup() &#123; onMounted(() =&gt; &#123; console.log(&#x27;这里是onMounted!!!&#x27;) &#125;); &#125;,&#125;);&lt;/script&gt; Vue3.0 子组件接收父组件首先，我们需要父组件传过来值。注意，利用TypeScript强类型引用的原则，一定要注意，传过去的类型与子组件声明接收的类型要一致。 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;div&gt; &lt;my-component-hello :msg=&quot;msg&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &quot;vue&quot;;import HelloWorldVue from &quot;../components/HelloWorld.vue&quot;;export default defineComponent(&#123; name: &quot;Home&quot;, components: &#123; &quot;my-component-hello&quot;: HelloWorldVue, &#125;, setup() &#123; //传过去的值的类型是string类型 let msg: string = &quot;你好，Hello World！&quot;; return &#123; msg, &#125;; &#125;,&#125;);&lt;/script&gt; 父组件传过去后，子组件要接收并且声明这个数据的类型 12345678910111213141516&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &quot;vue&quot;;export default defineComponent(&#123; name: &quot;HelloWorld&quot;, props: &#123; msg: String, &#125;,&#125;);&lt;/script&gt; Provider 与Inject （用于多层次组件）见博客: 爷孙级别组件数据传递 Vue3.0全面集成TypeScriptVue3.0_CompositionAPI +TypeScriptDemo.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &quot;vue&quot;;export default defineComponent(&#123; name: &quot;Demo&quot;, setup() &#123; let title: string = &quot;这是字符串类型的标题！&quot;; return &#123; title, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style scoped&gt;/* 该style只能被本组件使用 */&lt;/style&gt; 定义一个接口我们定义一个News用于规范化对象（规范其属性类型。）： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &#123;&#123; newsInstance &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &quot;vue&quot;;export default defineComponent(&#123; name: &quot;Demo&quot;, setup() &#123; //定义一个新闻接口 其中满足这些属性类型 interface News &#123; title: string; content: string; count: number; &#125; //实现接口的第一种方法 let newsInstance: News = &#123; title: &quot;这是字符串类型的新闻标题&quot;, content: &quot;这是字符串类型的新闻内容&quot;, count: 10, &#125;; return &#123; newsInstance, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style scoped&gt;/* 该style只能被本组件使用 */&lt;/style&gt; 实现接口的第二种方法：（推荐） 12345let newsInstance = reactive&lt;News&gt;(&#123; title: &quot;泛型标题&quot;, content: &quot;泛型内容&quot;, count: 100, &#125;); ref泛型指定数据类型1let count = ref&lt;number&gt;(100); 挂载路由1234567891011121314151617181920212223242526import &#123; createRouter, createWebHashHistory, RouteRecordRaw &#125; from &#x27;vue-router&#x27;import Home from &#x27;../views/Home.vue&#x27;const routes: Array&lt;RouteRecordRaw&gt; = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, // 访问路由时 懒加载 component: () =&gt; import(&#x27;../views/About.vue&#x27;) &#125;]const router = createRouter(&#123; history: createWebHashHistory(), routes&#125;)export default router 动态路由传值 我们可以再进入某个路由的同时，动态地传入URL某个index值。 路由配置12345&#123; path: &#x27;/demo/:id&#x27;, name: &#x27;Demo&#x27;, component: () =&gt; import(&#x27;../components/Demo.vue&#x27;)&#125; 当然了，对应的Demo组件必须存在。 现在，我们想要：跳转到Demo组件的同时，传入动态的id值。 （可以联想SpringMVC的@PathVariable注解） 并且，我们还可以获取到，这个传入过来的值。 在相应位置配置导航栏，利用模板字符串取script中的自适应数据，利用:to给标签绑定属性。 123456789101112131415161718192021&lt;template&gt;&lt;router-link :to=&quot; `/demo/$&#123;username&#125;` &quot;&gt; 进入Demo，传入字符串username过去 &lt;/router-link&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &quot;vue&quot;;export default defineComponent(&#123; name: &quot;Home&quot;, setup() &#123; let username = ref&lt;string&gt;(&quot;vincent&quot;) return &#123; username, &#125;; &#125;,&#125;);&lt;/script&gt; 在demo组件中获取到这个值！ 由于Vue3.x CompositionAPI中没有this的概念。因此我们只有通过Vue2.x的方式来获取这个参数。 本文中任何出现this的地方，都不能写在Setup中！ 1234567891011121314&lt;template&gt; &lt;div&gt; 欢迎通过URL动态路由进入本Demo组件， 您传过来的参数是：&#123;&#123; routerUrlParam.id &#125;&#125; &lt;/div&gt;&lt;/templte&gt; data() &#123; return &#123; routerUrlParam: &#123;&#125;, &#125;; &#125;, mounted() &#123; this.routerUrlParam = this.$route.params; &#125;, get方法传值我们可以通过类似get方法传值。 比如: xxx/getUsername?username=test 配置路由没有PathVariable 12345&#123; path: &#x27;/demo&#x27;, name: &#x27;Demo&#x27;, component: () =&gt; import(&#x27;../components/Demo.vue&#x27;)&#125; 传值 12345678&lt;router-link :to=&quot;`/demo?username=$&#123;username&#125;`&quot;&gt;进入Demo，传入字符串username过去&lt;/router-link&gt; setup() &#123; let username = ref&lt;string&gt;(&quot;vincent&quot;) return &#123; username, &#125;; &#125;, 接收 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; 欢迎通过URL动态路由进入本Demo组件，您传过来的参数是：&#123;&#123; routerUrlParam.username &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent, onMounted, reactive, ref &#125; from &quot;vue&quot;;export default defineComponent(&#123; setup() &#123; return &#123; &#125;; &#125;, data() &#123; return &#123; routerUrlParam: &#123;&#125;, &#125;; &#125;, mounted() &#123; this.routerUrlParam = this.$route.query; &#125;,&#125;);&lt;/script&gt; 路由跳转12//用JS来实现编程跳转this.$router.push(&#123;path:&#x27;/xxx&#x27;&#125;); 如果要用get方法传值的话，我们要在push中写第二个参数。 12345678910//编程式跳转 并get传值 this.$router.push(&#123; path: &quot;/demo&quot;, query: &#123; username: &quot;vincent&quot;, &#125;, &#125;);//接收时用来接收这个对象this.$route.query Vuex状态管理Vuex 主要解决组件与组件之间的数据共享，状态共享。 此外，还能实现组件里边数据的持久化。 比如，我们有一个新闻news组件还有一个新闻详情组件，点击每一条新闻，都能查看对应的新闻详情，而点进新闻详情可以看到的同时，退到新闻组价时，由于页面重新渲染，因此会重新向后台查询。 （避免这种情况，我们要么可以使用Localstorage要么就可以使用Vuex） 注意，使用Vuex，当刷新页面后，数据都会变成初始数据。 不结合TypeScript核心概念 State 相当于所有数据集合。 Getters 相当于计算属性computed Mutations 相当于methods方法集合 Actions 触发Mutations中的方法，可以写一些异步操作。 Modules 指的是模块。 初始化如下： 123456789101112131415import &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123; state: &#123; return&#123; val:1 &#125; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, modules: &#123; &#125;&#125;) state存储数据 那么如何获取到state中存储的数据呢？ 有两种方法： 第一种： 1this.$store.state.val //适用于Vue2.x 第二种：（推荐） 123state: &#123; users: [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;] &#125;, 123computed:&#123; ...mapState([&#x27;users&#x27;])&#125; 这样就可以直接在页面中使用： 1&#123;&#123; users &#125;&#125; mutations可以改变数据12345mutations: &#123; setVal(state, newVal) &#123; state.val = newVal; &#125; &#125;, 那么如何调用这个方法呢？ commit方法若有两个参数。 第一个参数是字符串，与对应的方法名字对应。第二个参数是传入的值！就会进入相应的方法体。 12let newVal = 14this.$store.commit(&#x27;setVal&#x27;, newVal); getters实时获取数据，同时根据业务逻辑来处理。 比如state中有一个变量msg代表字符串消息。msg: &#39;Hello World!&#39; 我们现使其字符串颠倒。 123456getters: &#123; reverseMsg(state) &#123; //比如根据业务逻辑来翻转字符串 return state.msg.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125; &#125;, 如何使用getters中的方法呢？ 与获取state中的数据一样，推荐两种方法： 直接通过getters.XXX 1this.$store.getters.reversMsg; 通过mapGetters 1234import &#123; mapGetters &#125; from &quot;vuex&quot;;computed: &#123; ...mapGetters([&quot;reverseMsg&quot;]), &#125;, 在页面中直接使用 &#123;&#123;reversMsg&#125;&#125; Actions 写异步操作比如我们去后台请求一个api接口，成功了我们执行mutations中的某一个方法，失败了我们去执行另一个方法。这样的操作，我们可以写在actions中。 actions 负责异步执行位于Mutations中的方法。 首先在mutations中写一个方法showMessage 123showMessage() &#123; console.log(&#x27;这是异步消息！&#x27;); &#125; 然后在actions中定义异步操作： 12345//异步执行mutations里边的方法 showMessageAsync(context) &#123; context.commit(&quot;showMessage&quot;); //可以多次执行 &#125; 然后在组件中调用： 12this.$store.dispatch(&quot;showMessageAsync&quot;); Module每一个模块中都包含state,getters以及action以及mutation. 我们可以分多个模块，每个模块中的数据不同。 比如在vuex文件中，我们分模块： userStore.js adminStore.js XXXStore有自己的state, getters, mutations以及actions。 然后我们在同目录下的store.js中引入这两个模块。 store.js 12345678import &#123; createStore &#125; from &#x27;vuex&#x27;import userStore from &quot;./userStore&quot;const store = createStore(&#123; modules:&#123; &quot;user&quot;: userStore &#125;&#125;)export default store 同目录下的userStore.js 123456789101112131415import &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123; state: &#123; name: &quot;用户&quot; &#125;, mutations: &#123; &#125;, getters: &#123; &#125;, actions: &#123; &#125;, modules: &#123; &#125;&#125;) 然后我们在页面中去引用 1&lt;div&gt;获取到userStore模块中的数据：&#123;&#123; $store.state.user.name &#125;&#125;&lt;/div&gt; Vuex 加 CompositionAPI因为CompositionAPI中没有this，因此我们要从vuex中引用useStore来获取数据。 直接获取state中的数据 123456789101112import &#123; computed &#125; from &quot;vue&quot;;import &#123; useStore &#125; from &quot;vuex&quot;;setup()&#123;const store = useStore();return &#123; data: computed(() =&gt; &#123; return store.state.name; &#125;), &#125;;&#125;//然后前端引用 &#123;&#123;data&#125;&#125; 访问mutations中的方法 123456789101112mutations: &#123; showMessage() &#123; console.log(&#x27;这是消息！&#x27;); &#125; &#125;,//setup中定义方法并return出去let showMessage = () =&gt; &#123; store.commit(&quot;showMessage&quot;); &#125;;//前端调用 &#123;&#123; showMessage() &#125;&#125; 调用getters中的方法（类似于computed） 1234567891011121314state: &#123; name: &quot;用户&quot; &#125;,getters: &#123; returnMessage(state) &#123; return state.name; &#125;&#125;,const store = useStore();returnMessage: computed(() =&gt; &#123; return store.getters.returnMessage; &#125;),//前端使用 &#123;&#123; returnMessage &#125;&#125; 触发actions中的方法 12345678910111213141516171819 getters: &#123; returnMessage(state) &#123; return state.name; &#125; &#125;, actions: &#123; asyncShowMessage(context) &#123; context.commit(&quot;showMessage&quot;) &#125; &#125;, let asyncShow = () =&gt; &#123; store.dispatch(&quot;asyncShowMessage&quot;);&#125;;return &#123; asyncShow,&#125;;//前端使用 &#123;&#123; asynShow() &#125;&#125;","categories":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"TypeScript学习笔记","slug":"TypeScript学习笔记","date":"2021-06-11T06:01:35.000Z","updated":"2021-11-09T07:53:30.210Z","comments":true,"path":"TypeScript学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"TypeScriptTypeScript是微软开发的一款开源编程语言。 TypeScript的安装1npm install -g typescript 验证是否安装完毕： 1tsc -v TypeScript的编译过程 编写TypeScript的.ts文件 通过TypeScript Compiler编译器 转化成JavaScript文件 VS Code 编译 创建.ts文件 typeScriptDemo.ts 123let message: string = &quot;Hello World!&quot;;console.log(message); 利用tsc编译这个.ts文件，因为浏览器不支持。 1tsc typeScriptDemo.ts 会发现，在相同目录下，会生成对应的.js文件。 4. 然后使用node命令来执行.js文件 1node typeScriptDemo.js 每次都要在控制台中敲tsc来手动编译，如何热部署呢？ 在当前目录创建tsconfig.json 1tsc --init 在tsconfig.json中更改生成js的目标位置 可以看到，将对应的js文件输出到当前的js这个目录下： 现在创建一个新的.ts文件，然后点击VS Code菜单栏中的Terminal 点击Run Task 点击typescript 再点击tsc:watch 现在我们可以直接保存之后用node .\\js\\demo.js就可以运行js文件了。 现在，我们写一个.html网页文件，来引用这个热部署的js文件。现在运行ts文件并实时刷新，浏览器控制台即可得到结果。 TypeScript的数据类型boolean类型TypeScript是强类型规范的，要求我们定义变量的同时，必须指定类型。 1let flag:boolean = true; 如果现在我们将flag赋值为字符串或者数值类型，会报错的。 number类型1let num:number = 123; 注意，TypeScript没有对整型或者浮点型做一个区分。 同理，赋其他类型的值也会报错。 string类型12let str:number = &quot;Hello World!&quot;;console.log(str); array类型数组类型，在TypeScript中，我们建议指定类型的数组。 123456//1. 第一种方式let arr:number[] = [1, 2, 3, 4, 5]; //指定类型为number的数组console.log(arr);//2. 第二种方式 泛型的方式let arr:Array&lt;number&gt; = [1, 2, 3]; tuple元组元组是数组的其中一种，我们可以指定多个不同类型的值。 1let arr:[string, number] = [&quot;张三&quot;, 98]; 枚举类型枚举类型是用来解释说明某些符号的意义。 比如：pay_status状态码。0 代表未支付1 代表支付成功2 代表交易中 如果不赋值的话，如果上一个赋值了，就是上个值+1，否则为其在元组中的索引。 123enum Flag &#123;success=1, error=-1&#125;let f:Flag = Flag.success;console.log(f) //结果是1 这样下次我们看到相应的数字 就知道对应的含义！ any类型any代表任意一个类型，不指定类型，我们可以多次更改不同类型的值（类型不同也可以）。 123let num:any = 123;//执行这句后 当前num变量的类型是numbernum = true; //指定这句后，当前num变量的类型是boolean 那么，any类型是什么应用呢？ 我们在js文件中定位DOM对象，由于ts中不存在对应的Object类型 因此我们可以赋为any 12let head:any = document.getElementById(&#x27;h1&#x27;);head.style.color = &quot;red&quot;; null与undefined类型在JS中我们知道，当我们对变量进行了定义但没有赋值，默认为undefined。 根据TypeScript的强类型引用，我们必须赋值（我们也可以赋值number或者undefined）。 1234let val:undefined; //我们可以直接输出 结果为undefined//如果要赋值 要赋值为number类型 如果直接输出 就是undefinedlet val:number | undefined; 当一个元素可能是多个类型的时候，我们可以在定义的时候，指定。 1let num:number|null|undefined; void类型如果方法没有返回值，我们就这么写： 12345function test(): void &#123; console.log(&#x27;这个方法没有任何返回值！&#x27;);&#125;test(); 否则，该方法返回什么，就写什么类型。 12345function getSum(x: number, y: number): number &#123; return x + y;&#125;console.log(getSum(1, 2)); never类型never类型就代表undefined或者null，或者从不会出现的值。 基本不会用到： 12345let n: never;n = (() =&gt; &#123; throw new Error(&#x27;error!&#x27;);&#125;)(); TypeScript的函数 函数声明法 123function getStringType(): string &#123; return &quot;Hello, World!&quot;;&#125; 匿名函数法 123let fun = function (): number &#123; return 100;&#125; 定义函数传参 12345function introduce(name: string): string &#123; return &quot;Hello, My name is: &quot; + name;&#125;console.log(introduce(&quot;Vincent&quot;)); 另外，我们可以通过`而不是字符串的拼接来引用我们的变量。这种方法更常用！ 12345function introduce(name: string): string &#123; return `Hello, My name is $&#123;name&#125;`;&#125;console.log(introduce(&quot;Vincent&quot;)); 可选参数（放在非可选参数的后面）对于，实参与形参如果不一样，必须指定可选参数。 也就是说，如果传某个可选参数，和如果不传分别都要做处理。 我们在对应的参数后面紧跟一个问号即可。 1234567891011function introduce(name:string, age?:number):string&#123; //如果调用的时候 提供age参数 if(age)&#123; return `Hello, my name is: $&#123;name&#125;, and my age is : $&#123;age&#125;!`; &#125;else&#123; return `Hello, my name is: $&#123;name&#125;!`; &#125; &#125;console.log(introduce(&#x27;Vincent&#x27;))console.log(introduce(&#x27;Vincent&#x27;,20)) 注意，可选参数必须配置到所有参数的最后面！ 默认参数12345678function introduce(name: string, age: number = 18): string &#123; //如果调用的时候 提供age参数 return `Hello, my name is: $&#123;name&#125;, and my age is : $&#123;age&#125;!`;&#125;console.log(introduce(&#x27;Vincent&#x27;)) //这里我们age 会打印出18console.log(introduce(&#x27;Vincent&#x27;, 20)) 三点运算符 三点运算符，用于接收传过来的不确定的值。 有些时候，我们传过来的参数可能是三个数也可能是四个数，我们利用三点运算符，可以将不确定个数的这些数全部装进一个相同类型的数组中。从而进行相应的处理！ 1234567891011function sum(...result: number[]): number &#123; let sum = 0; for (let i = 0; i &lt; result.length; i++) &#123; sum += result[i]; &#125; return sum;&#125;console.log(sum(1, 2, 3)) //我们将1,2,3都装进result中console.log(sum(1, 2, 3, 4)) //我们将1,2,3,4都装进result中 函数重载重载是指，两个或者以上个同名函数，但是他们的参数不一样（包括参数个数相同但类型不同，或者参数个数不同）。 TypeScript中的重载，与ES5或者Java中的重载不太相同。 参数个数相同，只是类型不同时 我们首先定义所有的情况（包括列出不同的参数情况） 实现一个方法，但是要写出根据不同参数来实现不同的情况。 关键代码是 if( typeof param === &quot;&quot; ) 1234567891011121314151617//声明第一种情况function getInfo(myName: string): string;//声明第二种情况function getInfo(myAge: number): number;//写函数 写出重载结果function getInfo(param: any): any &#123; if (typeof param === &quot;string&quot;) &#123; return `我的名字是：$&#123;param&#125;`; &#125; else &#123; return `我的年龄是：$&#123;param&#125;`; &#125;&#125;console.log(getInfo(&#x27;Vincent&#x27;));console.log(getInfo(22)); 当参数个数不同时同样，也是首先声明所有情况。然后涉及到可选参数！ 123456789101112131415function getInfo(myName: string): string;function getInfo(myName: string, age: number): string;//因为参数个数不同 所以需要声明可选参数function getInfo(param1: any, param2?: any): any &#123; //如果提供了可选参数 if (param2) &#123; return `Hello, my name is $&#123;param1&#125;, and my age is $&#123;param2&#125;`; &#125; else &#123; return `Hello, my name is $&#123;param1&#125;`; &#125;&#125;console.log(getInfo(&#x27;Vincent&#x27;));console.log(getInfo(&#x27;Vincent&#x27;, 22)); 箭头函数 注意，箭头函数里面的this不是外面的this。 12345678let num: number = 10;let _this: any = this;setTimeout(() =&gt; &#123; // alert(`$&#123;num&#125;`); alert(_this.num) //这两种方法都能打印出setTimeout方法外的变量&#125;, 1000) TypeScript的类（回顾）ES5 中的类与对象1234567891011121314151617181920212223//es5 中的类与对象以及方法function Person() &#123; this.name = &quot;张三&quot;; this.age = 20;&#125;//原型链创造属性+方法Person.prototype.info = &quot;信息&quot;;Person.prototype.work = function () &#123; console.log(&quot;我是&quot; + this.name + &quot;,&quot; + &quot;我在工作！&quot;);&#125;//静态方法Person.getInfo = function () &#123; console.log(this.name);&#125;//创造对象let obj = new Person();console.log(obj.name + &quot;:&quot; + obj.age);//静态方法Person.getInfo(); TypeScript中类以及对象的实例化123456789101112131415161718192021222324252627class Person &#123; //属性 myName: string; //前面省略了public关键词 //构造函数 constructor(myName: string) &#123; this.myName = myName; &#125; setMyName(myName: string): void &#123; this.myName = myName; &#125; getMyName() &#123; return this.myName; &#125; getInfo(): void &#123; console.log(`您好，我是$&#123;this.myName&#125;`) &#125;&#125;//实例化对象let p = new Person(&quot;张三&quot;);p.getInfo();p.setMyName(&quot;李四&quot;);p.getInfo(); 继承123456789class Student extends Person &#123; constructor(name: string) &#123; super(name); //调用父类的构造函数 从而继承父类的属性与方法 &#125;&#125;let stu = new Student(&quot;学生&quot;);stu.getInfo(); 注意，当子类中的方法名与其父类相同，那么会执行子类的方法。 类里面的修饰符 public 公有：表示任何地方都能访问（类里外、子类） private 私有：表示类里面可以访问，而子类与类外部无法访问。 protected 保护：表示在类里面以及子类里面才能访问，类外无法访问。 注意，如果属性不加修饰符，默认为公有public。 静态属性与方法 注意，静态方法中，是不能调用静态属性的。 12345678910111213141516171819class Person &#123; //属性 myName: string; //前面省略了public关键词 myAge: number; static mySex: string = &quot;男&quot;; //静态方法 //构造函数 constructor(myName: string, myAge: number) &#123; this.myName = myName; this.myAge = myAge; &#125; //静态方法 static getInfo(): void &#123; console.log(`$&#123;Person.mySex&#125;`); &#125;&#125;Person.getInfo(); 多态 多态指的是，父类声明一个方法但不实现，让子类来实现，并且每个子类都有不同的实现方法。 12345678910111213141516171819202122232425class Person &#123; //属性 myName: string; constructor(myName: string) &#123; this.myName = myName; &#125; work() &#123;&#125;&#125;class Student extends Person &#123; constructor(name: string) &#123; super(name); &#125; work() &#123; console.log(&quot;我去上学！&quot;); &#125;&#125;let p = new Person(&quot;张三&quot;);p.work();let stu = new Student(&quot;李四&quot;);stu.work(); 抽象类 抽象类以及抽象函数，一般用于定义标准。其子类必须包含这些含有abstract的函数。 抽象类是不能直接实例化的。 当然，抽象类可以具有构造函数以及非抽象函数的。但是对于那些抽象函数，其子类是必须要实现的。 12345678910111213141516171819202122//定义一个抽象类以及一个抽象方法abstract class Animal &#123; abstract eat(): void;&#125;class Dog extends Animal &#123; eat(): void &#123; console.log(&quot;这是狗，实现eat方法。&quot;) &#125;&#125;class Cat extends Animal &#123; eat(): void &#123; console.log(&quot;这是猫，实现eat方法。&quot;) &#125;&#125;let dog= new Dog();let cat= new Cat();dog.eat();cat.eat(); 接口函数型接口： 1234567891011121314//定义一个接口 以及相应的规范interface encrypt &#123; (key: string, value: string): string;&#125; //实现这个接口 必须要符合规范var md5: encrypt = function (key: string, value: string): string &#123; return key + value;&#125;//使用这个接口console.log(md5(&#x27;name&#x27;, &#x27;zhangsan&#x27;)) TypeScript中的泛型 泛型，即泛指的值，不具体固定的值，你传入什么类型，我就用什么类型来处理。 如果简单的话，可以使用any类型来处理。但是也存在一个隐患，就是any代表任意类型，它不强制类型。 123456function getData&lt;T&gt;(value: T): T &#123; return value;&#125;console.log(getData&lt;string&gt;(&#x27;Hello, World!&#x27;))console.log(getData&lt;number&gt;(100)); 泛型类1234567891011121314151617181920212223class ClassGetFirstItem&lt;T&gt;&#123; public list: T[] = []; add(value: T): void &#123; this.list.push(value); &#125; getFirstItem(): T &#123; return this.list[0]; &#125; getList(): string &#123; return `数组是$&#123;this.list&#125;`; &#125;&#125;let cla = new ClassGetFirstItem&lt;number&gt;();cla.add(1);cla.add(1);cla.add(1);console.log(cla.getList());console.log(cla.getFirstItem()); 当然，我们也可以let cla = new ClassGetFirstItem&lt;string&gt;();从而声明类型为string类型。 TypeScript中的模块 也就是说，我们首先export导出某些变量、函数甚至类，然后在想用的地方去import这个模块，从而能够获取到想要的变量、函数甚至类。 由于浏览器不能直接获取Js文件中的export。我们用node来看看。 demo.ts中export导出数据 12345678910export function getDataInfo(): any[] &#123; return [ &#123; username: &quot;root&quot; &#125;, &#123; password: &quot;123456&quot; &#125; ];&#125; main.ts中import这个function以及数据 123import &#123; getDataInfo &#125; from &#x27;./demo&#x27;console.log(getDataInfo()); 使用node来运行对应的main.js文件查看 123cd js node main.js export default 指的是默认导出，只能有一个默认导出。 比如 12345//文件末尾export default getData;//另一个想要引入getData的文件import getData from &#x27;.../&#x27;; 装饰器 装饰器就是一个方法，可以为某个类动态注入。 类装饰器类装饰器应用于类的构造函数，可以用来监视，修改或者替换类的定义，传入一个参数。 普通装饰器不修改类的前提下，动态修改类的属性与方法： 1234567891011121314151617181920//装饰器function logClass(params: any) &#123; //params 就是当前类（我们就可以扩展这个类了） console.log(params); params.prototype.apiUrl = &quot;xxx&quot;; params.prototype.run = function () &#123; console.log(&#x27;我是run方法！&#x27;); &#125;&#125;@logClassclass HttpClient &#123; constructor() &#123; &#125;&#125;let http: any = new HttpClient();console.log(http.apiUrl); //打印动态扩展的属性 装饰器工厂 装饰器工厂，可以在使用某个装饰器的同时，传入参数进去。123456789101112131415161718//装饰器//工厂装饰器 可以接收传过来的参数function logClass(params: string) &#123; return function (target: any) &#123; console.log(&quot;target:&quot; + target); console.log(&quot;params:&quot; + params); &#125;&#125;//这个地方 把string类型的hello变量赋给了params //而target则代表当前的类@logClass(&#x27;hello&#x27;)class HttpClient &#123; constructor() &#123; &#125;&#125;//我们实例化的同时 就会执行装饰器中的return中的方法体let http: any = new HttpClient(); 属性装饰器12345678910111213141516171819202122232425function logProperty(params: any) &#123; return function (target: any, attr: any) &#123; console.log(attr); //target相当于this 修改attr为传过来的参数 target[attr] = params; &#125;&#125;class HttpClient &#123; @logProperty(&quot;new Attr&quot;) public url: any | undefined; constructor() &#123; &#125; getData(): void &#123; console.log(this.url); &#125;&#125;let http = new HttpClient();http.getData(); 方法装饰器12345678910111213141516171819202122232425function logMethod(params: any) &#123; //target代表当前实例对象 methodName代表方法名 //desc 代表方法的描述 return function (target: any, methodName: any, desc: any) &#123; console.log(target); console.log(methodName); console.log(desc); target.getData = function () &#123; console.log(&#x27;修改！&#x27;); &#125; target.getData(); &#125;&#125;class HttpClient &#123; constructor() &#123; &#125; @logMethod(&quot;www.baidu.com&quot;) //传入参数 getData(): void &#123; console.log(&#x27;getData&#x27;); &#125;&#125;let http = new HttpClient();","categories":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"设计模式学习_抽象工厂","slug":"设计模式学习-抽象工厂","date":"2021-06-10T10:55:34.000Z","updated":"2021-11-09T07:53:30.225Z","comments":true,"path":"设计模式学习-抽象工厂/","link":"","permalink":"https://github.com/Vincent990413/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","excerpt":"","text":"抽象工厂设计模式 抽象工厂模式是与工厂模式相联系的。 前面提到，工厂模式提供了一种更好创造某个对象的方式，让子类来决定创造哪一个对象以及怎样创造这些对象。 而本章的抽象工厂设计模式是指，在工厂模式的基础上，提供的是：更好地创造多个对象。 业务场景比如，现在我们要设计两套不同操作系统（Windows操作系统与MacOS操作系统）的UI组件，分别是：表单（Form）与按钮（Button），规则是：所有的UI组件都不能跨操作系统展示。 也就是说，当使用Windows操作系统时，使用的是WindowsForm与WindowsButton（MacOS同理）。 图解如下： 还是那个逻辑：工厂负责创造对象。 也就是说，我们现在想要更好地创造Form与Button对象（条件是同处于同一个操作系统下）。 我们可以通过指定在对应的操作系统下，只return对应操作系统下的UI组件。 当然，依照不同的业务场景，如果你需要若干个对象捆绑在同一个工厂中，也可以通过这种方式。 下面，我们以代码的形式，来实现。 项目结构图如下： 代码实现工厂抽象类 操作系统 OperatingSystem.java12345public abstract class OperatingSystem &#123; public abstract Form getForm(); public abstract Button getButton() ;&#125; WindowsFactory.java123456789101112public class WindowsFactory extends OperatingSystem &#123; @Override public Form getForm() &#123; return new WindowsForm(); &#125; @Override public Button getButton() &#123; return new WindowsButton(); &#125;&#125; MacOSFactory.java123456789101112public class MacOSFactory extends OperatingSystem &#123; @Override public Form getForm() &#123; return new MacOSForm(); &#125; @Override public Button getButton() &#123; return new MacOSButton(); &#125;&#125; 产品接口 按钮 Button.java123public interface Button &#123; void desc();&#125; 接口 表单 Form.java123public interface Form &#123; void desc();&#125; 实现类 WindowsForm.java12345678public class WindowsForm implements Form &#123; @Override public void desc() &#123; System.out.println(&quot;当前正使用Windows操作系统下的表单Form！&quot;); &#125;&#125; 实现类 WindowsButton.java123456789public class WindowsButton implements Button &#123; @Override public void desc() &#123; System.out.println(&quot;当前正使用Windows操作系统下的按钮Button！&quot;); &#125;&#125; 实现类 MacOSForm.java12345678public class MacOSForm implements Form &#123; @Override public void desc() &#123; System.out.println(&quot;当前正使用MacOS操作系统下的表单Form！&quot;); &#125;&#125; 实现类 MacOSButton.java12345678public class MacOSButton implements Button &#123; @Override public void desc() &#123; System.out.println(&quot;当前正使用MacOS操作系统下的按钮Button！&quot;); &#125;&#125; 主函数 AbstractFactoryPatternDemo.java12345678910111213141516public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //以下是以Windows与MacOS为例 创造多个（Form与Button）存在依赖式的对象 WindowsFactory windowsFactory = new WindowsFactory(); System.out.println(&quot;Windows下的一套UI组件信息为：&quot;); windowsFactory.getForm().desc(); windowsFactory.getButton().desc(); MacOSFactory macOSFactory = new MacOSFactory(); System.out.println(&quot;MacOS下的一套UI组件信息为：&quot;); macOSFactory.getForm().desc(); macOSFactory.getButton().desc(); &#125;&#125; 效果图 当然，也可以像《工厂模式》那样，不细分多个操作系统，而是直接新建一个FormFactory以及ButtonFactory。然后，将Windows与MacOS作为参数传递进去，从而来判断return WindowsForm还是 return MacOSForm。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"vincent"},{"title":"VUE2.0学习笔记-基础语法及其应用-4-VUE小技巧","slug":"VUE学习笔记-基础语法及相应应用-4","date":"2021-06-04T03:18:03.000Z","updated":"2021-11-09T07:53:30.213Z","comments":true,"path":"VUE学习笔记-基础语法及相应应用-4/","link":"","permalink":"https://github.com/Vincent990413/blog/VUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%BA%94%E7%94%A8-4/","excerpt":"","text":"微服务下的vue axios(已用request.js封装)根据不同的服务来配置对应访问API接口地址 比如，我们的user模块对应的端口是8181，product模块对应的端口是8182..等等 我们根据请求的路径来判断，对应的ip地址：端口。 比如对于user服务，我们的请求路径@RequestMapping则以/user开头，等等... 配置所有的服务以及对应的URL requestAddress.js 12345678910// 导出 对应的不同接口的URL地址const BASE_URL = &#x27;http://10.17.81.18:&#x27;const configUrl = &#123; //微服务多模块接口地址中心 USER_URL: BASE_URL + &#x27;8181&#x27;, TEACHER_URL: BASE_URL + &#x27;8182&#x27;, LOGIN_COUNT_URL: BASE_URL + &#x27;8183&#x27;, MESSAGE_URL: BASE_URL + &#x27;8184&#x27;,&#125;export default configUrl 在request.js中引入并于每次请求时判断axios具体的baseUrl12345678910111213141516171819import baseUrl from &#x27;../assets/js/requestAddress&#x27;...config=&gt;&#123; const user = &quot;/user&quot;; const teacher = &quot;/teacher&quot;; const loginCount = &quot;/loginCount&quot;; const message = &quot;/message&quot;; //根据不同的调用名 去到不同的服务端口 if (config.url.indexOf(user) === 0) &#123; config.url = baseUrl.USER_URL + config.url; &#125; else if (config.url.indexOf(teacher) === 0) &#123; config.url = baseUrl.TEACHER_URL + config.url; &#125; else if (config.url.indexOf(loginCount) === 0) &#123; config.url = baseUrl.LOGIN_COUNT_URL + config.url; &#125;else if(config.url.indexOf(message) === 0)&#123; config.url = baseUrl.MESSAGE_URL + config.url; &#125;&#125; Vue 打开局域网调试在vue.config.js中： 1234567module.exports = &#123; publicPath: &#x27;./&#x27;, devServer: &#123; host: &#x27;0.0.0.0&#x27;, disableHostCheck: true &#125;,&#125; 其中host:0.0.0.0表示，我们当前可以用localhost的对应IP地址。（如果有微服务，多个端口开发） disableHostCheck:true，则表示我们可以在局域网环境下访问该vue。 uniapp 封装uni.request 类似Vue对axios的request封装. 新建一个request.js123456789101112131415161718192021222324252627const BASE_URL = &#x27;http://192.168.1.102:8181&#x27;export const request = (options) =&gt; &#123; //对于异步的封装 使用Promise return new Promise((resolve, reject) =&gt; &#123; uni.request(&#123; url: BASE_URL + options.url, method: options.method || &#x27;GET&#x27;, data: options.data || &#123;&#125;, success: res =&gt; &#123; //如果后台传回来的值是错误的 if (res.data.code === 0) &#123; return uni.showToast(&#123; title: &#x27;操作失败！&#x27; &#125;) &#125; //否则通过 resolve(res) &#125;, error: error =&gt; &#123; uni.showToast(&#123; title: &#x27;请求接口失败！&#x27; &#125;) reject(error) &#125; &#125;) &#125;);&#125; 注意后台是否有JWT拦截，注意是否配置跨域。 在vue中定义异步方法，并传入可选参数1234567async init() &#123; const res = await this.$request(&#123; url: &#x27;/sel_sys_msg&#x27; &#125;) this.data = res.data;//等等操作...&#125; Vue table数据满足条件才显示按钮 比如，当某一个数据项中的“状态”列为“已审核”时，才显示下架按钮！ 图解为： 当然，首先需要查看每一行有哪些数据： 代码：1234567&lt;el-table-column label=&quot;操作&quot; width=&quot;150&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button v-if=&quot;(scope.row.checkflag === &#x27;已审核&#x27;)&quot; type=&quot;success&quot;&gt; 下架&lt;/el-button &gt; &lt;/template&gt;&lt;/el-table-column&gt; # 注意若有多个Button，写在一个template中即可。 Vue中ElementUI中el-table当某列元素prop为数组 比如有个玩家el-table，我们每个玩家有多个擅长英雄而如果我们从后台传到前台的是一个List数据，我们就要想办法解析出多条数据prop。（如果直接赋值会显示Undefined） 玩家名 擅长英雄 张三 李元芳，后羿 李四 赵信，李白 控制台图解如下：也就是说，el-table中的某一列，仍然是一个List数组。 后台图解 从上图中，我们可以看到，List中套了一个List。* 前端重要代码1. 展示所有的数据（不做任何处理） 12345678910111213141516takeMeeting(row) &#123; let meetingid = row.meetingid; let teacherId = this.user.userId; let _this = this; takeMeeting(meetingid, teacherId) .then((res) =&gt; &#123; let msgType = &quot;success&quot;; if (res.data === 2) &#123; msgType = &quot;warning&quot;; &#125; else if (res.data == 0) &#123; msgType = &quot;error&quot;; &#125; _this.$sendMessage(res.message, msgType); &#125;) .catch((error) =&gt; &#123;&#125;);&#125;, 2. 对具体含数组的prop做处理 123456&lt;el-table-column :formatter=&quot;takeMeetingListFormatter&quot; prop=&quot;takeMeetingList&quot; label=&quot;参加人员&quot;&gt; &lt;/el-table-column&gt; 核心就是，给对应的el-table-column绑定:formatter 3. 对应的处理方法（放在methods中） 12345678takeMeetingListFormatter(row) &#123; let arr = [] row.takeMeetingList.forEach((item, index) =&gt; &#123; arr.push(item.teacherId) &#125;); //将每个需要的（这里是teacherId）放入新数组中，并用逗号隔开。 return arr.join(&#x27;,&#x27;) &#125;, 效果图 axios封装后的request.js请求. (注意导入时的路径问题)request.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import axios from &#x27;axios&#x27;import &#123; Message, MessageBox &#125; from &#x27;element-ui&#x27;import &#123; getToken, setToken &#125; from &#x27;../assets/js/utils&#x27; //从localstorage中const debug = process.env.NODE_ENV !== &#x27;production&#x27;// create an axios instanceconst service = axios.create(&#123; baseURL: &quot;http://192.168.1.106:8181&quot;, //请求的基础根路径 withCredentials: false,//如果遇到网络问题 就置为false timeout: 10000 // 请求超时10秒&#125;)// request interceptorservice.interceptors.request.use( config =&gt; &#123; //如果token为空 说明第一次登录本系统 则不管 //如果token不为空 则带着这个给header if (getToken() !== null) &#123; config.headers[&#x27;token&#x27;] = getToken() &#125; if (debug) &#123; console.log(config) &#125; return config &#125;, error =&gt; &#123; // Do something with request error console.log(error) // for debug Promise.reject(error) &#125;)// response interceptorservice.interceptors.response.use( response =&gt; &#123; const res = response.data //可能要配置相关的返回码200 404 500等等 if (res.code === 10010) &#123; MessageBox.confirm(res.message, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; window.location.href = &quot;/&quot; &#125;).catch(() =&gt; &#123; window.location.href = &quot;/&quot; &#125;); &#125; // 请求成功 else&#123; return response.data &#125; &#125;, error =&gt; &#123; console.log(&#x27;err&#x27; + error) // for debug Message(&#123; message: error.message, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;) return Promise.reject(error) &#125;)export default service 需要配置axios单个请求参数的文件群 user.js123456789101112131415161718192021import request from &quot;../plugins/request&quot;;//Get方法export function takeMeeting(meetingid, teacherId) &#123; return request(&#123; url: &#x27;/takeMeeting&#x27;, method: &#x27;get&#x27;, params: &#123; meetingid, teacherId &#125; &#125;)&#125;//POST方法export function updatePassword(updateForm) &#123; return request(&#123; url: &#x27;/updatePassword&#x27;, method: &#x27;post&#x27;, data: updateForm &#125;)&#125; 具体使用代码(注意路径问题)12345678import &#123;updatePassword&#125; from &#x27;../../api/user&#x27;updatePassword(this.updateForm).then( (res) =&gt; &#123; &#125;).catch( (error) =&gt; &#123; console.log(error)&#125;) axios请求 包括Get请求与Post请求（注意是异步）因为该方法是异步，因此无法准确知道元素的执行顺序。 有可能axios方法后面的方法会提前执行，也有可能会延后执行。 Get方法123456789var _this = thisvar _data = this.$dataaxios.get(main.requestAddress + &#x27;/book/showAllBooks&#x27;, &#123; params: &#123;&#x27;pn&#x27;: _data.queryParams.currentPageNum&#125; &#125;).then(function (response) &#123; //从后端返回给前端的内容(code、message、data...等等) &#125;).catch(function (error) &#123; &#125;); params:{ &#39;data&#39;: data} 是指以键值对的方式 往后台传输数据 因此，后台需要用@RequestParam()标签 注意，在main.js中定义一个变量 var requestAddress=&quot;192.xxx.xxx.xxx&quot; 同时导出这个main.js 最后使用的时候记得 import main from &#39;main.js的路径&#39; 请务必注意！ 第一种方案： 使用axios请求时，如果需要用到在回调函数中用到该网页的内容。 必须在axios.get/post方法外 定义一个 1var _this = this 注意外面的this与回调函数的this不一样！！！ (推荐)如果非要使用this，那么我们可以使用箭头函数：123success: res =&gt; &#123; this.xxx = res;&#125; Post方法 POST方法比较复杂，涉及到数据绑定 1234567891011121314151617181920212223242526&lt;el-form :rules=&quot;loginFormRules&quot; ref=&quot;loginForm&quot; :model=&quot;loginForm&quot; label-position=&quot;right&quot; label-width=&quot;auto&quot; show-message&gt; &lt;span class=&quot;login-title&quot;&gt;欢迎登录&lt;/span&gt; &lt;div style=&quot;margin-top: 5px&quot;&gt;&lt;/div&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;el-col :span=&quot;22&quot;&gt; &lt;el-input type=&quot;text&quot; v-model=&quot;loginForm.username&quot;&gt;&lt;/el-input&gt; &lt;/el-col&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-col :span=&quot;22&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;loginForm.password&quot;&gt;&lt;/el-input&gt; &lt;/el-col&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;loginSubmit(&#x27;loginForm&#x27;)&quot;&gt;登录&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible=true&quot;&gt;注册&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; ref=&quot;loginForm&quot; 与 :model=&quot;loginForm&quot; 都是指绑定data中的loginForm rules=&quot;loginFormRules&quot; 指的是绑定自定义规则 v-model=&quot;loginForm.username&quot;指的是 该值双向绑定loginForm里面的username属性因此，一定记得prop=loginForm.prop 点击登录按钮时，loginForm作为参数传进去！ 1. loginForm里面的参数-&gt;对应的所有prop 写在return里面即可： 1234loginForm: &#123; username: &#x27;&#x27;, password: &#x27;&#x27;&#125; 2. loginForm对应的规则，也写在return里面 12345678loginFormRules: &#123; username:[ &#123;required: true, message: &#x27;账号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125; ], password: [ &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125; ]&#125; require表示必须填，触发blur后，会提示message！ 这样，在JS中，可以将该表单loginForm与它对应的参数输入规则绑定在一起验证！ 同时也可以自定义验证规则！在data(){这里} 中写 1234567const validateUserName = (rule, value, callback) =&gt; &#123; if(value === 0)&#123; callback(new Error(&#x27;这里是错误提示&#x27;)) &#125;else&#123; callback() //验证成功，通过自定义规则！ &#125;&#125; 其中value是对应输入框的值！ callback用来回调 提示对方错误信息 还是 让对方通过 这样的话，可以在规则中，声明走自定义的规则方法： 12345loginFormRules: &#123; username:[ &#123;required: true, validator: validateUserName,, trigger: &#x27;blur&#x27;&#125; ]&#125; 其他自定义规则 看官方文档 具体登录+验证方法如下： 1234567891011121314151617181920212223242526loginSubmit(formName) &#123; let _this = this // 为表单绑定验证功能 this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; // 使用 vue-router 路由到指定页面，该方式称之为编程式导航 this.$axios.post(main.requestAddress + `/user/login`, _this.loginForm) .then(res =&gt; &#123; _this.$data.message = res.data.message //若数据库查询失败 则返回重新登录信息 if (res.data.data === null) &#123; _this.openLoginFailMessage(); return; &#125; sessionStorage.setItem(&quot;token&quot;, true); sessionStorage.setItem(&quot;username&quot;, res.data.data.username); _this.$router.push(&quot;/index&quot;);//路由跳转至 path=&gt; /index 具体看自己的路由配置 &#125;) .catch(Error =&gt; &#123; console.log(Error) &#125;) &#125; else &#123; return false; &#125; &#125;); &#125; 全局路由配置（基于session的前端权限）1.首先搞清楚，除了登录、404..页面，其他的涉及到必须要先登录的业务数据页面都是要授权认证的！ 2.授权认证，必须要经过成功登录 3.每次页面进行跳转都要经过权限认证过程！ 配置路由，除了登录页面，其他都要认证我们给相应涉及业务数据的页面，比如主页面index，加上需要拦截的头信息： 注意！登录页面是不需要加的！ 12345678&#123; meta: &#123; requireAuth: true //如果来该页面 需要验证 &#125;, path: &#x27;/index&#x27;, name: &#x27;业务逻辑&#x27;, component: ()=&gt;import(&#x27;../views/ShowAll&#x27;)&#125; 然后，在页面拦截时，我们需要判断要去的页面是否需要授权？ 也就是requireAuth是否是&#39;true&#39;？ 123456789101112131415161718192021//添加全局路由拦截router.beforeEach((to, from, next) =&gt; &#123; if (to.meta.requireAuth) &#123; //如果去的页面需要认证 那么就开始认证 if (sessionStorage.getItem(&quot;token&quot;) == &#x27;true&#x27;) &#123; next(); //放行 &#125; else &#123; alert(&#x27;请您登陆...&#x27;); //否则下一步也放行 但放行到登录页面 next(&#123; path: &#x27;/login&#x27; &#125;) &#125; &#125; else &#123; //如果不需要授权 比如直接去登录页面 if (sessionStorage.getItem(&quot;token&quot;) == &#x27;true&#x27; &amp;&amp; to.path != &#x27;/login&#x27;) &#123; next(&#x27;/index&#x27;) &#125; else &#123; next() &#125; &#125;&#125;) 注意这里的sessionStorage.getItem(&quot;token&quot;)取出来的值是字符串类型 这里的 &amp;&amp; to.path!=&#39;/login&#39; 是用户从index主界面 到login登录页面 而不想已经验证但还是跳到index页面的情况 如果不指定 1next(&#123;path: &#x27;/login&#x27;&#125;) 即指定去登录页面（前提是登录页面的path是&#39;/login&#39;）， 那么next()就代表允许去想要去的页面 因为每次我们要看sessionStorage.getItem(&quot;token&quot;)里面值是不是&#39;true&#39;。因此，我们需要在登录成功的时候！添加对应的token信息 登录成功添加可“允许通过”的路由信息（Token，Session，Cookies均可）1sessionStorage.setItem(&quot;token&quot;, true); 过滤路由显示菜单如果在菜单中不想让某些通用模块出现（比如登录、注册、注销等功能） 可以在对应路由信息中，添加属性: hidden: true 在页面中的el-submenu 以及el-submenu-item中 去for循环遍历时，加一个v-if=&quot;!item.hidden&quot; 注意，v-if 与 v-for 是不能同时出现在属性中 可以将v-for 提前一个标签！ Vue 项目中加入常用插件加入插件通常，我们通过vue/cli来创建相应的vue项目 1vue create vue_demo 注意，如果不想要VUE严格的eslint语法规则。 可以在创建的时候，取消勾选Fomatter。 若需要VUEX全局状态管理，可以勾选。 若需要路由router，则可以选择勾选。 ...在经过漫长的cmd后 不用关闭当前git bash或者命令行控制工具Command 我们首先进入这个项目，直接利用npm配置一些插件。 1234cd vue_demovue add vuetify //下载vuetify移动自适应插件vue add element //引入elementUI 并且在接下来选择时Fully import还是按需引入vue add axios //将ajax封装好的axios 不出意外的话，在具体的项目目录中，可以看到多出一个文件夹plugins。 这里装着我们安装进去的插件。 在配置之后，我们可以用VS code来打开这个文件夹，并且 1npm run serve 运行项目 VUE中添加Echarts可视化图表npm 安装echarts插件1npm install echarts --save 如果npm的安装速度较慢，可以使用cnpm淘宝镜像 123456//安装淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org//从淘宝镜像下载cnpm install echarts -S 当完成npm安装后，echarts插件出现在 node_modules 目录下 全局引入ECHARTSmain.js 文件 1234// 引入echartsimport * as echarts from &#x27;echarts&#x27;Vue.prototype.$echarts = echarts 初始化图表1&lt;div ref=&quot;chartCircle&quot; :style=&quot;&#123;width: &#x27;300px&#x27;, height: &#x27;300px&#x27;&#125;&quot;&gt;&lt;/div&gt; ref属性是为了JS代码中能引用这个图表 &lt;div&gt;属性之间默认隔行 如果想要多个图表在同一行中显示 添加属性：style=&quot;display: inline-block&quot; 如果想要动态改变 图表的高度与宽度 可以利用VUE的动态绑定 JS画图动态渲染（柱状图与饼状图）饼状图将画图抽象成一个函数 drawLine() 这个函数放在mounted() 生命周期函数中 1this.drawLine(); 图标参数JSON数据 （定义在data中的return{}） 1234567891011121314151617181920212223242526272829optionCircle:&#123; title: &#123; text: &#x27;实时热门图书&#x27;, subtext: &#x27;站点动态统计&#x27;, left: &#x27;center&#x27; &#125;, tooltip: &#123; trigger: &#x27;item&#x27; &#125;, legend: &#123; orient: &#x27;vertical&#x27;, left: &#x27;left&#x27;, &#125;, series: [ &#123; name: &#x27;访问来源&#x27;, type: &#x27;pie&#x27;, radius: &#x27;50%&#x27;, data: [], emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125; 正常情况下，是看不到任何数据的 但是能看到你的饼状图标题 接下来，我们要在data中从后台动态添加数据 这里我选择 AXIOS 异步刷新数据 JS drawLine() 函数 1234567891011121314151617181920212223242526272829drawLine()&#123; // 基于准备好的dom，初始化echarts实例 //通过ref来找到图表 let myChartCircle = this.$echarts.init(this.$refs.chartCircle); //如果这里this.$refs.chartCircle 无效 则给div加一个id为chartCircle //然后将this.$refs.chartCircle替换成document.getElementById(&#x27;chartCircle&#x27;)即可 //动态从数据库中取数据 //画饼图 const _this = this axios.get( main.requestAddress + &#x27;/book/showPopularBooks&#x27;).then(function (response) &#123; let list = response.data.data let data = _this.$data.optionCircle.series[0].data for(let i =0; i&lt;list.length; i++)&#123; data.push(&#123; name: list[i].bookname, value: list[i].borrowNum &#125;) &#125; //这一句很重要 加载到页面中 myChartCircle.setOption(_this.$data.optionCircle); &#125;).catch(function (error) &#123; alert(error); &#125;);&#125; 可以看到，其实真正的饼状图数据是： &quot;name&quot;代表饼图的名称 &quot;value&quot;代表对应name的饼图数据 值得注意的是，这种push方法是加入新的JSON对象的方法 12345data.push(&#123; key1: value1(可以来自后台), key2: value2(可以来自后台), ...&#125;); 效果图如下： 柱状图与饼状图相似，先是配置图标参数，渲染图表，最后是取数据 配置图表参数123456789101112131415161718optionColumn:&#123; title: &#123; text: &#x27;实时借书用户&#x27; &#125;, tooltip: &#123; &#125;, legend: &#123; &#125;, xAxis: &#123; data: [] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &#x27;借阅次数&#x27;, type: &#x27;bar&#x27;, data: [] &#125;] &#125; 渲染图表123456789101112131415161718let myChartColumn = this.$echarts.init(this.$refs.chartColumn) //使用刚指定的配置项和数据显示图表。 //画柱状图 axios.get( main.requestAddress + &#x27;/book/showPopularUsers&#x27;).then(function (response) &#123; let list = response.data.data let nameArray = _this.$data.optionColumn.xAxis.data let numArray = _this.$data.optionColumn.series[0].data for(let i=0; i&lt;list.length; i++)&#123; nameArray.push(list[i].username); numArray.push(list[i].totalBorrowNum); &#125; myChartColumn.setOption(_this.$data.optionColumn); &#125;).catch(function (error) &#123; alert(error); &#125;); 可以看到，对于柱状图，我们要配置两个 xAxis 即X轴的数组中的数据 series[0]中的data数组 代表从左往右依次的 棱柱所代表的value 效果图如下 VUEX 存值与取值区域在VUE中，如果有些数据我们不太需要后台频繁的查询数据 我们就可以将这些数据存放在VUEX中 声明store的index.js12345678910111213141516171819202122232425import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)//导出之后 外部可以使用export default new Vuex.Store(&#123; state:&#123; //放全局变量 比如viewCounter是浏览量统计器 viewCounter = 1 &#125;, mutations:&#123; //setter方法区域 setViewCounter(state, viewCounter)&#123; state.viewCounter = viewCounter &#125; &#125;, getters:&#123; //getter方法区域 getViewCounter: state =&gt; state.viewCounter &#125;, action:&#123;&#125;, modules:&#123;&#125;&#125;) 在需要存值、取值的地方 调用方法取值getViewCounter1this.$store.getters.getViewCounter 存值setViewCounter方法1this.$store.commit(&#x27;setViewCounter&#x27;, newValue); WEB项目实现文件下载与上传SSM项目+非MultipartFile类 在这种类型的项目中，我们需要在相应的Spring MVC.xml配置文件中，去配置一个MultipartFile的Bean对象。 代码如下： 12345&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;104857600&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;4096&quot;/&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 这种，我们就可以在Controller层中，使用@RequestParam(&quot;file&quot;) MultipartFile file了。 如果前端是Form表单的话，则前端代码如下： 12345&lt;form class=&quot;form-horizontal &quot; action=&quot;/UploadServlet&quot; id=&quot;upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input class=&quot;form-control&quot; type=&quot;file&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-sm&quot;&gt;上传&lt;/button&gt; &lt;div&gt; $&#123; message &#125; &lt;/div&gt;&lt;/form&gt; 这样，当我们点击上传后，即会跳转到对应的action，我们用@PostMapping来接收即可。 后台代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 // 上传文件存储目录 private static final String UPLOAD_DIRECTORY = &quot;upload&quot;; // 上传配置 private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3; // 3MB private static final int MAX_FILE_SIZE = 1024 * 1024 * 40; // 40MB private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 50; // 50MB @RequestMapping(value = &quot;/UploadServlet&quot;, method = RequestMethod.POST) public String upload( ModelAndView modelAndView, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; // 配置上传参数 DiskFileItemFactory factory = new DiskFileItemFactory(); // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中 factory.setSizeThreshold(MEMORY_THRESHOLD); // 设置临时存储目录 factory.setRepository(new File(System.getProperty(&quot;java.io.tmpdir&quot;))); ServletFileUpload upload = new ServletFileUpload(factory); // 设置最大文件上传值 upload.setFileSizeMax(MAX_FILE_SIZE); // 设置最大请求值 (包含文件和表单数据) upload.setSizeMax(MAX_REQUEST_SIZE); // 中文处理 upload.setHeaderEncoding(&quot;UTF-8&quot;); // 构造临时路径来存储上传的文件 // 这个路径相对当前应用的目录 String uploadPath = request.getServletContext().getRealPath(&quot;./&quot;) + File.separator + UPLOAD_DIRECTORY; // 如果目录不存在则创建 File uploadDir = new File(uploadPath); if (!uploadDir.exists()) &#123; uploadDir.mkdir(); &#125; try &#123; List&lt;FileItem&gt; formItems = upload.parseRequest(request); if (formItems != null &amp;&amp; formItems.size() &gt; 0) &#123; // 迭代表单数据 for (FileItem item : formItems) &#123; // 处理不在表单中的字段 if (!item.isFormField()) &#123; String fileName = new File(item.getName()).getName(); String filePath = uploadPath + File.separator + fileName; File storeFile = new File(filePath); // 在控制台输出文件的上传路径 String filePathSaved = uploadPath + File.separator; // 保存文件到硬盘 item.write(storeFile); teacherServer.saveFilePath(filePathSaved, fileName); request.setAttribute(&quot;message&quot;, formItems.get(0).getName() + &quot;文件上传成功!&quot;); &#125; &#125; &#125; &#125; catch (Exception ex) &#123; request.setAttribute(&quot;message&quot;, &quot;错误信息: &quot; + &quot;文件上传失败，请检查是否文件为空！&quot;); &#125; return &quot;/teacher/tea_add_paper&quot;; &#125; 注意到return这里，我们需要配置相应的视图解析器，不然我们不知道return哪个地方去显示。 12345&lt;!--配置试图解析--&gt; &lt;bean class = &quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 注意：webapp 就是我们配置的根目录，并且配置的视图后缀为.jsp 这样我们就能在，相应的视图中，看到message的内容了 SpringBoot项目+JSP+MultipartFile（非AJAX异步）首先，我们需要在SpringBoot的配置文件application.yml或者application.properties中配置： application.properties 123spring.servlet.multipart.max-request-size=40MBspring.servlet.multipart.max-file-size=40MB 然后我们，在controller中写相应语句： 我们仍然需要配置视图解析器ViewResolver： 在application.properties中： 123spring.mvc.view.prefix=/spring.mvc.view.suffix=.jsp 仍与上方图片中的项目结构图一致！ 1234567891011121314151617181920212223242526 private static final String UPLOAD_DIRECTORY = &quot;upload&quot;; @PostMapping(&quot;/upload&quot;) @ResponseBody public String upload(@RequestParam(&quot;file&quot;) MultipartFile file, HttpServletRequest request) &#123; if (file.isEmpty()) &#123; request.setAttribute(&quot;message&quot;, &quot;对不起，检测到文件为空！&quot;); return &quot;/teacher/tea_add_paper&quot;; &#125; String fileName = file.getOriginalFilename(); String templatePath = request.getServletContext().getRealPath(&quot;./&quot;) + File.separator + UPLOAD_DIRECTORY; File dest = new File(filePath + fileName); try &#123; file.transferTo(dest); request.setAttribute(&quot;message&quot;, &quot;文件上传成功！&quot;); return &quot;/teacher/tea_add_paper&quot;; &#125; catch (IOException e) &#123; System.out.println(e) &#125; request.setAttribute(&quot;message&quot;, &quot;文件上传失败！&quot;); return &quot;/teacher/tea_add_paper&quot;; &#125; 接下来，就准备写前端页面请求： 12345678&lt;form method=&quot;post&quot; action=&quot;/uploading&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交给服务器&quot;&gt; &lt;div&gt; $&#123;message&#125; &lt;/div&gt;&lt;/form&gt; SpringBoot+VUE+ElementUI前后端分离 我们规定前端用户只能上传后缀为.doc或者.docx的文件，即在前端向后台发送请求之前进行过滤。并且文件大小不能超过40MB。 1. VUE前端页面 12345678910111213141516171819202122232425&lt;el-uploadclass=&quot;uploadDemo&quot;ref=&quot;upload&quot;accept=&quot;.doc&quot;action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;:on-preview=&quot;handlePreview&quot;:on-remove=&quot;handleRemove&quot;:on-change=&quot;handleChange&quot;:http-request=&quot;httpRequest&quot;:auto-upload=&quot;false&quot; &gt;&lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot; &gt;选取文件&lt;/el-button&gt;&lt;el-button style=&quot;margin-left: 10px&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot; &gt;上传到服务器&lt;/el-button&gt;&lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt; 只能上传.doc后缀文件，且不超过40MB&lt;/div&gt; &lt;/el-upload&gt; 写两个函数 一个是按钮点击函数，另一个是上传文件的表单具体提交（axios请求）的函数 提交按钮函数123submitUpload() &#123; this.$refs.upload.submit(); //我们通过el-upload的引用来找到 并让他提交&#125;, 注意，我们这里看到他的action位置，并不是我们的后台地址。 也就是说，我们通过先把自己的文件传给他的action，再由他的action服务器地址，传给我们的后台服务器。 最后，提交表单后，会走绑定属性httpRequest的方法，即： 表单提交函数 1234567891011121314151617181920212223242526272829//最后上传走这个方法！ httpRequest(param) &#123; let fileObj = param.file; // 相当于input里取得的files let data = new FormData(); // FormData 对象 data.append(&quot;file&quot;, fileObj); // 文件对象 后台用@RequestParam来接收 const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart/form-data&quot; &#125; &#125;; var _this = this; //在这里我将后台的服务器地址 存进了VUEX中 只要后台地址正确即可。 //并通过相应的getters 来获取 this.$axios .post( this.$store.getters.getRequestAddress + `/uploading`, data, config ) .then((res) =&gt; &#123; let data = res.data; console.log(data); if (data.data === 1) &#123; _this.sendMessage(data.message, &quot;success&quot;); &#125; else &#123; _this.sendMessage(data.message, &quot;error&quot;); &#125; &#125;) .catch((Error) =&gt; &#123; _this.sendMessage(&quot;请求失败！&quot;, &quot;error&quot;); &#125;); &#125;, 当然，我们绑定了三个回调函数，on-change、on-preview以及on-remove，分别代表“改动”“预览”以及“移除”文件的操作。 1234567891011121314151617181920handleRemove(file, fileList) &#123; console.log(file, fileList);&#125;,handlePreview(file) &#123; console.log(file);&#125;,handleChange(file) &#123; const isLt40M = file.size / 1024 / 1024 &lt; 40; //必须小于40M const isSuffixDoc = file.name.indexOf(&quot;.doc&quot;) !== -1 ? true : false; if (!isSuffixDoc) &#123; this.$refs.upload.clearFiles(); //清空文件 this.$message.error(&quot;您好，请上传以.doc或者.docx为后缀的文档文件！&quot;); return; &#125; if (!isLt40M) &#123; this.$refs.upload.clearFiles(); //清空文件 this.$message.error(&quot;上传文件大小不能超过 40MB!&quot;); return; &#125;&#125;, 发送消息的方法，记得引入ElementUI。 1234567//弹窗发送消息 以传入的参数而定 sendMessage(messageContent, messageType) &#123; this.$message(&#123; message: messageContent, type: messageType, &#125;); &#125;, 然后就是后台接收（如果是SSM项目，在SpringMVC配置文件中配置MultipartFile的Bean。 如果是SpringBoot项目，记得在application.properties中配置。 见上方内容 接下来，我们写后台的具体上传方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@RequestMapping(value = &quot;/uploading&quot;)public TSMResult uploadFile( @RequestParam(&quot;file&quot;) MultipartFile file, TSMResult tsmResult) &#123; //上传文件的路径 String filePath = FilePathUtils.getFileUploadPath(); //filename 包括文件的后缀名 String filename = file.getOriginalFilename(); Boolean isExists = sourceServer.isExistsFilename(filename); if (isExists) &#123; tsmResult.setData(0); tsmResult.setMessage(StatusMessage.FILE_EXISTED); return tsmResult; &#125; //用来判断上传文件的父目录是否存在 File fileTestDirIFExists = new File(filePath); if (!fileTestDirIFExists.exists()) &#123; //如果目录不存在 则手动创建一个新目录 //mkdirs 可以在比如C盘等根盘下 创建多个连续的子目录 fileTestDirIFExists.mkdirs(); &#125; //真正存储的目标文件 File dest = new File(filePath + filename); try &#123; //开始从web上传的file 存储到目标file file.transferTo(dest); //数据库中存储文件的路径 sourceServer.saveFilePath(filePath, filename); tsmResult.setData(1); tsmResult.setMessage(StatusMessage.FILE_UPLOAD_SUCCESS); return tsmResult; &#125; catch (IOException e) &#123; e.printStackTrace(); tsmResult.setData(0); tsmResult.setMessage(StatusMessage.FILE_UPLOAD_FAILED); &#125; return tsmResult;&#125; 1sourceServer.saveFilePath(filePath, filename); 这个代表，我们将这个上传的文件名字，以及对应的上传路径，写进数据库中。 对应服务层代码： 123public int saveFilePath(String filePathSaved, String fileName) &#123; return sourceMapper.saveFilePath(filePathSaved, fileName); &#125; 对应mapper代码： 123@Insert(&quot;insert into source(source, papername) values (#&#123;filePath&#125;,#&#123;fileName&#125;)&quot;) int saveFilePath(@Param(&quot;filePath&quot;) String filePath, @Param(&quot;fileName&quot;) String fileName); 可以建立一个Source实体类，引入Lombok插件。 123456@Data@All..所有参数构造函数@No...无参构造函数 private Integer id; private String filePath; private String fileName; 并且数据库也建立一个source表，其中字段名与这个Source实体类的属性名一模一样（避免Mybatis的字段映射ResultMap） 实现文件下载# 在实现文件的上传后，我们肯定会有相应的下载功能。 即从上传目录中的文件中，去下载对应的文件。 需求：我们将文件的信息以及路径，存进数据库了，也就代表： 我们“只能下载那些已经保存在数据库中的文件” JSP实现文件下载（且动态检测文件是否可下载） 前端页面动态生成一个锚点（Bootstrap可加上按钮样式类） 1234567891011// 1. 利用Ajax异步获取到分好页的论文（PageHelper插件）var list = result.data.list// 2. 利用$.each来遍历这些数据 对每个数据进行筛选$.each(list, function (index, item) &#123; //3. 首先获取到即将下载的论文名(鉴于我们上传时 是将论文的文件名存进数据库的) var papername = item.papername //4. 为每一项“模拟按钮” 动态加上类 方便我们后期动态remove掉 var download = $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(papername + &quot; btn btn-danger btn-sm&quot;).append($(&quot;&lt;span&gt;&lt;/span&gt;&quot;).addClass(&quot;glyphicon glyphicon-download&quot;)).append(&quot;下载&quot;).attr(&quot;href&quot;, &quot;/DownloadServlet?paperName=&quot; + item.papername);&#125;); 注意到，我们这里的路径是：/DownloadServlet?paperName=xxx 因此，我们肯定是以get的请求方式 后台controller层代码12345678910111213141516171819private static final String UPLOAD_DIRECTORY = &quot;upload&quot;;@RequestMapping(value = &quot;/DownloadServlet&quot;) public ResponseEntity&lt;byte[]&gt; fileDownload( HttpServletRequest request, @RequestParam(&quot;paperName&quot;) String fileName, Model model) throws Exception &#123; fileName = new String(fileName.getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;); //后台接受中文数据编码 fileName = fileName + &quot;.doc&quot;; String filePath = request.getServletContext().getRealPath(&quot;./&quot;) + File.separator + UPLOAD_DIRECTORY + &quot;\\\\&quot; + fileName; File file = new File(filePath); HttpHeaders headers = new HttpHeaders(); String downloadFile = new String(fileName.getBytes(&quot;utf-8&quot;), &quot;iso-8859-1&quot;); headers.setContentDispositionFormData(&quot;attachment&quot;, downloadFile); headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED); &#125; 其实，上述代码是不够完整的，因为如果数据库中没有这个以.doc为后缀（后缀写死了）的文件，就会报错。 因此，我们需要在前端下载之前就进行一次查询： 如果该文件的文件名存到数据库里了，才给予下载（即才动态添加下载的锚点样式） 完整代码：写在$.each遍历中：123456789101112131415161718192021222324252627282930// 1. 利用Ajax异步获取到分好页的论文（PageHelper插件）var list = result.data.list// 2. 利用$.each来遍历这些数据 对每个数据进行筛选$.each(list, function (index, item) &#123; //3. 首先获取到即将下载的论文名(鉴于我们上传时 是将论文的文件名存进数据库的) var papername = item.papername //4. 为每一项“模拟按钮” 动态加上类 方便我们后期动态remove掉 var download = $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(papername + &quot; btn btn-danger btn-sm&quot;).append($(&quot;&lt;span&gt;&lt;/span&gt;&quot;).addClass(&quot;glyphicon glyphicon-download&quot;)).append(&quot;下载&quot;).attr(&quot;href&quot;, &quot;/DownloadServlet?paperName=&quot; + item.papername); //5. 查询该文件是否可下载 $.ajax(&#123; url: &quot;isExistsFilename&quot;, data: &#123;&quot;paperName&quot;: item.papername&#125;, type: &quot;GET&quot;, dataType: &quot;JSON&quot;, success: function (result) &#123; //数据库存储了文件信息的论文 才可以下载 //如果为false表示不可下载 则根据对应的papername来remove样式 if(result.data == false)&#123; $(&quot;.&quot; + item.papername).remove(); &#125; &#125;, error: function (error) &#123; console.log(error) &#125; &#125;);&#125;); 查询的控制层代码： 1234567891011121314151617@RequestMapping(value = &quot;/isExistsFilename&quot;, method = RequestMethod.GET) @ResponseBody public TSMResult isExistsFilename( @RequestParam(&quot;paperName&quot;) String paperName) &#123; //处理中文 Boolean isExists = false; try &#123; paperName = new String(paperName.getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;); paperName = paperName + &quot;.doc&quot;; Source source = adminServer.isExistsPaperFile(paperName); isExists = (source == null) ? false : true; &#125; catch (Exception e) &#123; System.out.println(&quot;检测到异常！&quot;); e.printStackTrace(); &#125; return new TSMResult(200, &quot;查询成功&quot;, isExists); &#125; 从代码中的三目运算符可以看出： 1isExists = (source == null) ? false : true; 如果这个文件为空则会true，否则为false 也就是说，如果文件不为空，则为false，表示不可下载 服务层代码： 123public Source isExistsPaperFile(String paperName) &#123; return sourceMapper.selectPaperFile(paperName); &#125; 具体Source类看上方代码即可。 Mapper代码： 12@Select(&quot;select* from source where papername = #&#123;paperName&#125;&quot;)Source selectPaperFile(@Param(&quot;paperName&quot;) String paperName); 实现通用JS代码全局引用（现在推荐Mixin全局组件复用）ElementUI的Message消息提示、Notify通知等等我们希望在弹出消息或者通知（Notify）时 根据我们自定义的参数，来相应提示用户 提示用户更改信息成功 这个提示类型是success类型 只需调用： 1this.$sendMessage(&#x27;这是消息内容&#x27;, &#x27;info/success/error/warning&#x27;) info 是灰色 success是绿色 error是红色 warning是黄色 创建通用功能的utils.js 定义多个function 最后导出即可 注意，这里有一个知识点：对于默认导出的函数，使用时函数名外不需要{xxx} 即直接： import XXX from &#39;xxx/xxx&#39; 而如果有多个函数，想要按需引入的话，需要加上{} 按需引入（包括默认导出函数）： 1import &#123; fun1, fun2 &#125; from &#x27;xxx/xxx&#x27; 12345678910111213//弹窗发送消息 以传入的参数而定export function sendMessage(messageContent, messageType) &#123; this.$message(&#123; message: messageContent, type: messageType, &#125;);&#125;export function alertTest() &#123; alert(&#x27;这是测试方法！&#x27;)&#125;export default sendMessage main.js中引入并使用123import &#123; sendMessage,loadingAnimation &#125; from &#x27;./assets/js/utils&#x27;Vue.prototype.$sendMessage = sendMessage Vue.prototype.$alertTest = alertTest 这样我们就可以，直接在vue项目中：使用this.$sendMessage来使用相应方法了。 Vue3.x中的Mixin实现组件功能的复用为什么要有Mixin呢？从字面意思来说，我们就将不同组件之间，所具有的相同功能以及相同数据。给他们混合进任意一个组件中MixIn。。 说白了，就是不同组件中共享公共的代码块。 但是，比起一般的JS import export。 mixin的优点在我们可以直接传入涉及到data的数据 因为我们在传入数据的时候，如果涉及到data(){return{}}中的数据，我们必须在方法体中去处理。 如果是一般的import&amp;export，会找不到这个this，如果用了Mixin，直接共享在一套data(){}与methods中，就不存在这个问题了。 代码如下：1. 新建minxin目录写一个baseMixin.js来写所有的公共区域，并在最后export导出。 1234567891011121314const baseMixin = &#123; data() &#123; return &#123; data: &quot;通用数据&quot; &#125; &#125;, methods: &#123; showInfo() &#123; console.log(&quot;通用信息！&quot;); &#125; &#125;,&#125;export default baseMixin 2. 在需要用公共代码块的地方，去import进来，并指定mixin。 123456789import baseMixin from &quot;../mixin/baseMixin&quot;;mixins: [baseMixin],data() &#123; return &#123;&#125;;&#125;,mounted() &#123; console.log(this.data); this.showInfo();&#125;, 当数据属性名字重复的时候：如果当前使用Mixin的组件中的数据（1）的名字与Mixin定义的data中的属性名（2）重复时，Vue会使用（1）。 如果是方法，也是如此，不会执行通用模板中的方法。 全局配置Mixin在main.js中定义: 12import App from &#x27;./App.vue&#x27;const app = createApp(App) 配置全局Mixin 12import baseMixin from &#x27;baseMixin.js的路径&#x27;app.mixin(baseMixin) HTML中引入VUE并使用ElementUI样式head标签引入ElementUI的CSS、JS以及VUE的JS123&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; 初始VUE（2.0版本） 页面非body标签 标记 123&lt;div id=&quot;app&quot;&gt; &lt;/div&gt; vue挂载上去（可以使用template写HTML页面 如果已经有内容了就去掉template）1234567891011121314151617new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125;, created() &#123; &#125;, mounted() &#123; &#125; &#125;)","categories":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"Gitee_上传项目","slug":"Gitee-上传项目","date":"2021-06-01T15:20:01.000Z","updated":"2021-11-09T07:53:30.186Z","comments":true,"path":"Gitee-上传项目/","link":"","permalink":"https://github.com/Vincent990413/blog/Gitee-%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"Gitee上传项目1. 创建一个仓库（要用到git地址） 配置Git.config12git config --global user.name &quot;vincent990413&quot;git config --global user.email &quot;370216714@qq.com&quot; #点击初始化readme文件 2. 克隆git地址随便创建一个文件夹，Git Bash中进入这个文件夹 （这个文件夹的名字无所谓）， 输入代码： 1git clone xxxxx.git 然后将目标文件夹里面的内容（不包括文件夹）直接复制过来。 然后输入代码： 1git add . 然后输入代码：备注： 1git commit -m &quot;备注&quot; 然后依次输入： 123git pull origin mastergit push -u origin master","categories":[{"name":"Gitee上传项目","slug":"gitee上传项目","permalink":"https://github.com/Vincent990413/blog/categories/gitee%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Gitee上传项目","slug":"gitee上传项目","permalink":"https://github.com/Vincent990413/blog/tags/gitee%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"}],"author":"vincent"},{"title":"设计模式学习_工厂方法模式","slug":"设计模式学习-工厂方法模式","date":"2021-05-25T13:20:08.000Z","updated":"2021-11-09T07:53:30.225Z","comments":true,"path":"设计模式学习-工厂方法模式/","link":"","permalink":"https://github.com/Vincent990413/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂方法设计模式 Factory Pattern 定义以及抽象层面 工厂方法定义了一种更好地创造对象的方式。但是它让工厂子类来决定怎么创造以及创造哪一个对象。也就是说，工厂模式将创造对象的过程延迟给子类来进行。 它以这两种东西组成： 1. 我们想要创造的对象。 2.我们用来创造这些对象的工厂。 抽象层面的图所示： # 我们可以看到： 1. 左边代表的是各个我们需要创建的对象。 2. 右边代表的是我们用什么（工厂）来创建，当然了，根据什么规则来创建这些对象，我们也可以写在工厂中。 具体案例层面以及代码实现# 现在，我们用可以实现的代码形式来说明： 重要的图如下： 也就是说，业务场景如下：我们需要创造一个可以画出形状的图形：可以是画出长方形，正方形或者圆形。我们利用工厂类来有逻辑地创造这些类。 接口 形状 Shape.java 12345package com.company.inter;public interface Shape &#123; void draw();&#125; 具体的实现子类.java 12345678910package com.company.impl;import com.company.inter.Shape;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;画出来的是圆形图案...&quot;); &#125;&#125; 12345678910package com.company.impl;import com.company.inter.Shape;public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;画出来的是长方形图案...&quot;); &#125;&#125; 12345678910package com.company.impl;import com.company.inter.Shape;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;画出来的是正方形图案...&quot;); &#125;&#125; 创造指定对象的工厂.java 1234567891011121314151617181920package com.company.factory;import com.company.impl.Circle;import com.company.impl.Rectangle;import com.company.impl.Square;import com.company.inter.Shape;public class ShapeFactory &#123; public Shape getShape(String specificShapeName) &#123; //定义如何生成对象的逻辑 if (specificShapeName.equals(&quot;Rectangle&quot;)) &#123; return new Rectangle(); &#125; else if (specificShapeName.equals(&quot;Square&quot;)) &#123; return new Square(); &#125;else if (specificShapeName.equals(&quot;Circle&quot;)) &#123; return new Circle(); &#125; return null; &#125;&#125; 测试的主函数Main.java 123456789101112131415161718package com.company;import com.company.factory.ShapeFactory;import com.company.inter.Shape;public class Main &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //通过指定不同的名字 来创造不同的对象（依照具体的业务场景来定义不同的对象创建规则） Shape s1 = shapeFactory.getShape(&quot;Circle&quot;); s1.draw(); Shape s2 = shapeFactory.getShape(&quot;Square&quot;); s2.draw(); &#125;&#125; 效果图","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"vincent"},{"title":"Java技巧_配置视图解析器","slug":"Java技巧-配置视图解析器","date":"2021-05-23T03:36:49.000Z","updated":"2021-11-09T07:53:30.202Z","comments":true,"path":"Java技巧-配置视图解析器/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-%E9%85%8D%E7%BD%AE%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/","excerpt":"","text":"SpringBoot配置MVC视图解析 首先确保自己创建的是SpringBoot项目 项目结构图如下：接下来正式开始配置： 1. 在SpringBoot的配置文件中12spring.mvc.view.prefix=classpath:/static/spring.mvc.view.suffix=.html （主要看图配置！） 2. Controller层写代码跳转即可12345678@RequestMapping(&quot;/user&quot;)@Controllerpublic class User&#123; @GetMapping(&quot;/index&quot;) public String toIndex()&#123; return &quot;index&quot;; &#125;&#125; 注意，这里不能用@RestController注解","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"Spring Security学习笔记","slug":"Spring-Security学习笔记","date":"2021-05-22T01:34:20.000Z","updated":"2021-11-09T07:53:30.208Z","comments":true,"path":"Spring-Security学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/Spring-Security%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安全保证框架Shiro与Spring security 他们之间很像，除了名字、类名不一样。 Spring Security 可以实现定制化身份认证 Authentication 权限控制 Access of Control 权限： 功能权限 访问权限 菜单权限 Spring Security 用于简化过滤器&amp;拦截器 WebSecurityConfigurerAdapter：自定义Security策略（适配器模式） AuthenticationManagerBuilder：自定义认证策略（建造者模式） AOP概念我们不用改变原来项目的业务代码，而是在项目中加入config。帮我们去做一些事情 入门案例 使用工具idea，新建一个Spring initize项目（只勾选一个web即可） 使用SpringBoot 2.2.1版本来使用: pom.xml文件中修改 添加springboot-security依赖 修改controller 体验security在controller包下新增TestController.java 12345678910111213import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/test&quot;)public class TestController &#123; @GetMapping(&quot;/hello&quot;) public String add()&#123; return &quot;Hello, Spring Security!&quot;; &#125;&#125; 修改默认端口（避免占用）在application.properties中 1server.port = 8181 启动项目并测试1localhost:8181/test/hello 系统会出现这个界面：Spring Security会强制让我们先登录。 默认的用户名：user 控制台（如图）会出现我们的默认密码Using generated security password 在正确输入后，会出现下图效果： SpringSecurity 基本原理（过滤链）Spring Security框架本质上就是一套的过滤器链 FilterChain 也就是说，有很多的过滤器Filter，执行到具体方法时，就会进入过滤器，只有过滤器对其进行过滤放行，才能进入到下一个过滤器。 常见三个过滤器FilterSecurityInterceptorFilterSecurityInterceptor是一个方法级的权限过滤器，具体有doFilter方法。 首先看之前的过滤器是否执行，如果执行，才执行自己的过滤器。 ExceptionTranslationFilterExceptionTranslationFilter是一个处理权限过程中，出现的异常问题的过滤器。依据每个不同的异常，做不同的处理。 UsernamePasswordAuthenticationFilter对/login且使用POST请求过来的表单做一个用户名密码校验。 SpringSecurity 过滤器的加载过程使用Spring Security配置过滤器如果使用SpringBoot项目的话，自动帮我们集成以下的这些代码。 如果不用SpringBoot项目集成SpringSecurity的话，需要写一个DelegationFilterProxy过滤器。 而这个DelegationFilterProxy的doFilter方法中，有一个init初始化方法，这个初始化方法中，用于获得FilterChainProxy，这个Proxy中有一个doFilterInternal方法，这个方法中有一个List&lt;Filter&gt;很多个过滤器，并通过迭代的方式getFilters获得这些所有的过滤器。 SpringSecurity 中重要的接口UserDetailsService 用户细节信息接口在实际开发中，我们的账号和密码，并不是Spring Security所默认的user和默认生成密码。 而都是从数据库中查询出来的。 因此，这个接口很方便我们进行自定义逻辑业务开发。 实现这个UserDetailsService接口即可，在这个实现方法中，写查数据库的方法。 创建一个类，继承UsernamePasswordAuthenticationFilter过滤器（重写三个方法） 创建一个类，重新UserDetailsService接口，编写查询数据过程，并返回User对象（这个对象由Security提供） PasswordEncoder 密码加密接口在上一个UserDetailsService中我们需要返回一个Spring Security框架中的User对象，在这个对象中的密码，必须是要返回加密后的密码。而不能是明文。 Web项目中 认证&amp;授权 思路认证 Authentication： 就是用户在登录Web中，利用自己的用户名与密码，进行用户认证。 设置登录的用户名与密码 通过 application.properties 配置文件进行配置 通过配置类 通过自定义编写实现类，实现UserDetialsService，返回这个User对象即可 1. 通过配置文件配置代码如下： 12spring.security.user.name = userspring.security.user.password = 123456 2. 通过自定义配置类 添加注解@configuration 继承WebSecurityConfigurerAdapter类 重写这个类的方法（如下图） 在重写这个方法时，我们利用auth来配置用户信息，对于密码需要加密。 而且，要记得加一个@bean注解用于验证PasswordEncoder映射，否则会报错。 123456789101112131415161718192021222324import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //利用这个auth来设置登录的用户信息 // 密码需要加密 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); String passwordEncoded = bCryptPasswordEncoder.encode(&quot;123456&quot;); auth.inMemoryAuthentication().withUser(&quot;user&quot;).password(passwordEncoded).roles(&quot;admin&quot;); &#125; @Bean PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 现在我们可以用这个用户名user 密码123456去登录了。而这个user用户，具有的角色是：admin 3. 利用UserDetailsService接口配置（开发经常用） 创建配置类，auth使用UserDetailsService(注入一个UserDetailsService类) 编写实现类，返回User对象，这个对象由用户名、密码以及权限 创建配置类SecurityUserServiceConfig12345678910111213141516171819202122232425262728293031package com.vincent.securitydemo.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configurationpublic class SecurityUserServiceConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth .userDetailsService(userDetailsService) .passwordEncoder(passwordEncoder()); //1. 使用UserDetailsService //2. 使用返回的PasswordEncoder @Bean加密 &#125; @Bean PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 编写实现类MyUserDetailsService编写一个实现类MyUserDetailsService去实现UserDetailsService（我们的配置类需要），重写这个loadUserByUsername方法加载用户信息。 注意：@Service(&quot;userDetailsService&quot;) 这个参数要与配置类中，@Autowire自动装配的名字一样。不然找不到。 123456789101112131415161718192021222324package com.vincent.securitydemo.service;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.AuthorityUtils;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;import java.util.List;@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; // 手动代替查询数据库操作 List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); return new User(&quot;user&quot;, new BCryptPasswordEncoder().encode(&quot;123456&quot;), authorityList); &#125;&#125; 注意，我们返回的User对象有三个参数：用户名，加密后的密码以及一个Collection表示具有的权限集合 加入数据库操作 到MyUserDetailsService实现类中整合MybatisPlus进入到这一步，实现具体的数据库操作。 引入相关依赖 引入MybatisPlus依赖 引入MySQL依赖 引入工具类Lombok 方便实体类注解 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!--web项目依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--security依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--pojo注解生成get、set方法--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 处理数据库中的User表 id 自增数字主键 username varchar类型 password varchar类型 处理Mapper 继承Mybatis+ 给我们写好的基本Mapper即可 创建mapper包 UserMapper接口 extends BaseMapper 泛型 12345678910package com.vincent.securitydemo.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.vincent.securitydemo.entity.User;@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123; &#125; 重写之前MyUserDetailsService实现类中的方法 通过数据库查询 Service实现类中 注入UserMapper对象 1234567891011121314@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; // 数据库查询语句 用于认证用户 //并最终返回Security框架中的User对象 return ...; &#125;&#125; 利用Mybatis-plus中的QueryWrapper帮我们规定查询满足的条件 并通过UserMapper中的查询方法，注意判断根据用户名查询出来的User对象（我们定义的Entity）是否为空 最终返回Spring Security框架自己的User对象 注意看代码中的注释内容！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.vincent.securitydemo.service;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.vincent.securitydemo.entity.User;import com.vincent.securitydemo.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.AuthorityUtils;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import java.util.List;@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //数据库查询语句 用于认证用户 //参数中的s 即代表用户提交表单中的用户名 //现在我们要根据用户名 去查询对应的数据库中是否存在这个数据 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //条件构造器 通过这个构造器去做查询 类似UserExample wrapper.eq(&quot;username&quot;, username); User user = userMapper.selectOne(wrapper); if (user == null) &#123; //认证失败 没有存在的用户 throw new UsernameNotFoundException(&quot;用户名不存在&quot;); &#125; //注意我们返回的不是自己的实体类User //而是security框架给我们提供的User类 List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); return new org.springframework.security.core.userdetails.User(user.getUsername(), new BCryptPasswordEncoder().encode(user.getPassword()), authorityList); &#125;&#125; 这一步很关键 我们要在SpringBoot启动类中 加一个注解@MapperScan 启动Mapper 不然的话无法识别我们的Mapper SecuritydemoApplication.java 1234567891011121314package com.vincent.securitydemo;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.vincent.securitydemo.mapper&quot;)public class SecuritydemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecuritydemoApplication.class, args); &#125;&#125; application.properties 配置文件中 配置数据库信息 对于本SpringSecurity测试的SpringBoot版本是SpringBoot 2.2.1 Release 因此，在引入数据库驱动时，如果使用的是MySQL8.0驱动且加入时区 引入时，应使用：com.mysql.cj.jdbc.Driver 12345678910111213server.port = 8181#可直接通过配置文件 来配置用户信息#spring.security.user.name=user#spring.security.user.password=123456#数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/securitydemo?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8spring.datasource.username = rootspring.datasource.password = 123456spring.jpa.show-sql = true 自定义登录页面&amp;设置路径不需要认证在实际的业务开发中，我们需要自己的好看的登录页面。因此接下来我们将指定登录的页面。 在实际的业务开发中，有些Controller是不需要进行验证用户权限的。我们也进行设置。 主要思路就是，在 SecurityConfig 配置类中，配置一下就可以了。 值得注意的是，现在我们还是用到configure方法，但是里面的参数不是AuthenticationManagerBuilder auth，而是HttpSecurity http。 我们通过http.formLogin() 进行一系列的设置 设置默认登录页面的路径 设置默认登录的请求路径（SpringSecurity自动帮我们实现） 设置默认登录成功跳转的路径 设置哪些路径不需要认证，直接通过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.vincent.securitydemo.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configurationpublic class SecurityUserServiceConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //配置用户认证 auth .userDetailsService(userDetailsService) .passwordEncoder(passwordEncoder()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; //完成与HTTP请求的配置设置 http.formLogin() .loginPage(&quot;/login.html&quot;) //自定义自己编写的登录页面 参数是地址 . loginProcessingUrl(&quot;/user/login&quot;) //定义登录访问的请求路径 但是这个具体的方法过程由SpringSecurity实现 .failureUrl(&quot;/error.html&quot;) //定义登录错误跳转的页面 参数是地址 .defaultSuccessUrl(&quot;index.html&quot;).permitAll() //定义默认登录成功后 跳转到的路径 .and().authorizeRequests().antMatchers(&quot;/&quot;, &quot;/test/hello&quot;, &quot;/user/login&quot;).permitAll() .anyRequest().authenticated() //授权通过，这些路径是不需要认证，直接让它过！ .and().csrf().disable(); //关闭CSRF认证方式 &#125; @Bean PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 现在我们只需要，一个登录页面，一个处理登录成功的controller 注意我们这里的action值，必须跟config中配置的请求路径相同，而且name只能是用户名和密码。 resources/static/login.html 12345&lt;form action=&quot;/user/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码： &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; resources/static/error.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;抱歉，登录错误！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; resources/static/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;主页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;登录成功，这是主界面！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; controller/TestController.java 1234@GetMapping(&quot;/index&quot;) public String toIndex()&#123; return &quot;Hello, Index!&quot;; &#125; 基于角色或者权限的访问控制1. hasAuthority方法对于这个方法，如果用户具有指定的权限，则返回True，否则返回False. # 在config中声明只有哪些权限可以通过这个路径请求 12//只有具有admin权限 才能访问这个/test/index这个路径(同时在Service中加入admin）.antMatchers(&quot;/test/index&quot;).hasAuthority(&quot;admin&quot;) # Service中加入这些权限 12//在Service中加入admin权限List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;); 当出现上述图片时，代表403权限不够！ 2. hasAnyAuthority 当某个请求对于声明的角色中，任意一个角色都可以通过时使用。 比如对于学生的管理，教师Teacher与管理员Admin都可以访问这些接口路径。 1.antMatchers(&quot;/test/index&quot;).hasAnyAuthority(&quot;admin,teacher&quot;) 则表示，当权限为teacher或者admin...等等时（用逗号隔开即可）都允许通过！ 3. hasRole 基本用法不变，但是源码显示：它会将我们声明的角色名xxx变成ROLE_+xxx。 因此，我们在Service中，声明具有的角色时，应该手动添加为ROLE_xxx。 #配置类 1.antMatchers(&quot;/test/index&quot;).hasRole(&quot;salesman&quot;) #Service声明具有的权限 1List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,Role_salesman&quot;); 4. hasAnyRole用法与hasAnyAutority一致。 自定义无权限403页面 在配置类中，配置自定义403页面即可。 1http.exceptionHandling().accessDeniedPage(&quot;/unauth.html&quot;); 如果满足无权限条件的话，会跳转到这个页面。 SpringSecurity 认证&amp;授权 常见的注解 注解的作用，就是简化开发。 @Secured(&quot;ROLE_XXX, ROLE_YYY&quot;)这个注解表示：用户具有某个角色，可以根据这个角色来访问相应的接口。 使用这个注解时，我们要打开注解功能： 添加注解到Springboot启动类或者Config配置类上： 1@EnableGlobalMethodSecurity(securedEnabled = true) 在Controller的方法上面，使用这个注解，自动为我们判断角色权限。 12345@GetMapping(&quot;/deleteUser&quot;)@Secured(&quot;ROLE_admin&quot;) public String deleteUser()&#123; return &quot;通过权限，这是删除页面！&quot;; &#125; 表示这个方法，必须要具有admin角色才能进入。 @PreAuthorize 这个是在方法执行之前进行校验。 在启动类相同位置，逗号，开启prePostEnabled = true 1@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true) 在相应方法上，加入注解**@PreAuthorize()** 12345@GetMapping(&quot;/updateUser&quot;)@PreAuthorize(&quot;hasRole(&#x27;ROLE_admin&#x27;)&quot;)public String updateUser()&#123; return &quot;通过权限，这是更改页面！&quot;;&#125; 可以看到，这里可以选择之前的四种： hasRole hasAnyRole hasAuthority hasAnyAuthority 注意涉及到Role时，手动添加ROLE_XXX即可。 @PostAuthorize 这种方式用得频率比较少，代表：执行方法之后，再进行校验。一般适用于，带有返回值的校验方式！ 也就是说，方法是一定会执行的。* 只不过是，方法执行后，遇到了403权限错误。 123456@GetMapping(&quot;/afterMethodVerify&quot;)@PostAuthorize(&quot;hasRole(&#x27;ROLE_admin&#x27;)&quot;)public String afterMethodVerify()&#123; System.out.println(&#x27;一定会执行的！&#x27;); return &quot;通过权限，这是目标页面！&quot;;&#125; 用户实现注销1. 配置注销的请求路径以及注销成功后跳转的URL（可以是HTML）12//配置注销http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/login.html&quot;).permitAll(); 这里可以看到，我们配置注销url是/logout（框架内置） 并且当成功注销后，跳转到login.html。 2.在任意页面中添加/login请求路径比如我们可以在登录后跳转的主界面index.html中，加入一个超链接: 1&lt;a href=&quot;/logout&quot;&gt;点我注销&lt;/a&gt; 这样就可以实现了。 测试如下： 1. 在未认证的情况下，访问index.html。此时会自动跳转到，login.html登录页面。 登录之后进入index.html此时点击该页面上的注销锚点 此时进入登录页面，再访问index.html后会自动跳转到login.html。 用户实现自动登录使用cookie技术 缺点：是客户端技术，如果有敏感数据，不建议使用这个技术。 使用Spring security安全框架机制实现 实现原理图如下： 详细步骤如下：1. 数据库创建表（可选择自动帮我们创建）2. 配置类注入数据源配置类SecurityUserServiceConfig.java12345678910111213//将数据库源@Autowiredprivate DataSource dataSource;//操作数据库的对象@Beanpublic PersistentTokenRepository persistentTokenRepository()&#123; JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); //自动帮我们创建表 jdbcTokenRepository.setCreateTableOnStartup(true); return jdbcTokenRepository;&#125; 第一次运行时会自动帮我们创建SQL表，之后我们注释到setCreateTableStartup这一行即可。 3. 配置类设置记住我rememberMe相关信息# 将这个PersistentTokenRepository对象配置进来 12345//设置记住我(自动登录)以及记住的时间长度.and().rememberMe().tokenRepository(persistentTokenRepository()).tokenValiditySeconds(60).userDetailsService(userDetailsService).and().csrf().disable(); //关闭CSRF认证方式 4. 前端页面加入记住我复选框 注意，这里复选框的name属性值不能是其他名字，Spring Security规定只能是remember-me。 1234567&lt;form action=&quot;/user/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码： &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br/&gt; 60秒内自动登录：&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 这样的话，在每次登录时，打开控制台可以看到Cookie相关信息 图中可以看到，有一个 remember-me Cookie信息。 在60秒内（配置类中设置时长），可以直接免去登录而跳转到其他页面中。 CSRF理解 CSRF：Cross-site Request Forgery。是一种控制用户在已登录的Web应用程序中执行非本意的操作的攻击方法。简单来说，就是攻击者利用一些技术手段来欺骗用户的浏览器去访问自己曾经认证过的网站并运行一些操作，利用Web中用户认证的漏洞。 Spring Security默认打开CSRF防护功能！我们可以手动关闭它的防护功能。 通过以下代码实现： 1.and().csrf().disable(); //关闭CSRF认证方式 Spring Security 中的CSRF 第一次登录时，由于缺少Token，因此Spring Security会帮我们生成一定长度的Token放进Session或者Cookie中。 在下次请求时会带着Token进行请求，与已有保存的httpToken字符串进行比对！！！如果比对失败，则不允许。以此来实现防护CSRF攻击！ CsrfFilter来实现这个过程","categories":[{"name":"Spring 全家桶学习","slug":"spring-全家桶学习","permalink":"https://github.com/Vincent990413/blog/categories/spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Spring 全家桶学习","slug":"spring-全家桶学习","permalink":"https://github.com/Vincent990413/blog/tags/spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"Java适应前端JSON参数_万物皆可Map","slug":"Java适应前端JSON参数-万物皆可Map","date":"2021-05-19T15:16:34.000Z","updated":"2021-11-09T07:53:30.202Z","comments":true,"path":"Java适应前端JSON参数-万物皆可Map/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E9%80%82%E5%BA%94%E5%89%8D%E7%AB%AFJSON%E5%8F%82%E6%95%B0-%E4%B8%87%E7%89%A9%E7%9A%86%E5%8F%AFMap/","excerpt":"","text":"来源于之前做过的ECharts引入饼图数据： 点我回顾ECharts 我们前端图表data中有两个参数： name 代表饼图每一部分的名称 value 代表饼图每一部分的数据量（自动根据这个数据量更改比例） 因此我们前端需要复杂处理：name与value 1234567891011121314//同步请求数据$.ajax(&#123; url: &quot;$&#123;request.getContexPath()&#125;/meal/showData&quot;, type: &quot;POST&quot;, dataType: &quot;JSON&quot;, async: false, // 回调函数 success: function (res)&#123; data = res //这里具体看链接中 引入的饼图ECharts &#125;, error: function (error)&#123; console.log(error) &#125;&#125;) data中是这样的: 1data:[ &#123; &quot;name&quot;: &quot;bookName&quot;, value: &quot;20&quot; &#125;] 123456789101112131415161718192021222324252627282930313233343536373839404142434445 @ResponseBody @RequestMapping(&quot;/showData&quot;) public List&lt;Map&lt;String,Object&gt;&gt; showData( Model model, HttpServletRequest request)&#123; // 查询所有订单信息 List&lt;OrderItem&gt; list = orderItemService.list();//map: productId(Integer类型) 次数(Integer类型) Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//遍历所有待处理的list //利用map的键值唯一性统计各（具体item对象）数量 list.forEach(i -&gt; &#123; //如果存在对应的pid 作为键 那么就累加sum //否则（第一次检索） 赋值为默认1 map.merge(i.getPid(), 1, Integer::sum); &#125;); //查询商品名字返回结果集//值用Object更加的灵活 List&lt;Map&lt;String,Object&gt;&gt; res = new ArrayList&lt;&gt;(); //map映射转换为 集合set Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet(); //遍历这个集合 entries.forEach(entry -&gt; &#123; Map&lt;String,Object&gt; map1 = new HashMap&lt;&gt;(); //获取到集合中的每一个key值 Integer key = entry.getKey(); //根据这个key值（也就是pid) 去找对应的product对象 Product product = productService.get(key); //将需要两个属性 put进去 //我们需要前端data的name:val value:value map1.put(&quot;name&quot;, product.getName()); map1.put(&quot;value&quot;, entry.getValue()); res.add(map1); &#125;); return res; &#125; 微服务架构下通用类TSMResult Object数据的获取我们知道，通过Feign，我们可以对微服务架构下。不同微服务的调用。 然而，我们在Controller控制器中，一般基于RestController我们返回的是JSON通用类或者XML。 那么，我们如何获取到TSMResult通用类中的数据呢？ 首先我们要去看，我们set进去的类型是什么？这样，才能取出同样的类型。 set进去某种类型 12345TSMResult tsmResult = new TSMResult;List&lt;Message&gt; systemMsgList = messageServer.selectSystemMsg();//其中TSMResult类中的data属性 是Object类型tsmResult.setData(systemMsgList); 知道set进去的类型 以相同方式get出来 1List&lt;Message&gt; list = JSON.parseObject(JSON.toJSONString(messageTSMResult.getData()), List.class);","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"设计模式学习_装饰器模式","slug":"设计模式学习-装饰器模式","date":"2021-05-18T02:09:12.000Z","updated":"2021-11-09T07:53:30.229Z","comments":true,"path":"设计模式学习-装饰器模式/","link":"","permalink":"https://github.com/Vincent990413/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"装饰器模式 Decorator Pattern 试想有一个平安夜苹果，我们用一个精美的盒子将其装入，同时我们可以按照自己的需要，在最外层继续装精美的盒子（例子不太恰当）。 而这就是装饰器模式，本身的工作原理。 定义1. 装饰器模式，允许我们像现有的对象添加新的功能同时不改变其设计结构。 2. 是作为现有类的一个包装，即本质上，还是这个类 3. 动态扩展或者撤销类的功能 同时，装饰器模式可以解决，一般继承Inheritance的缺陷。 我们知道，当一个类继承另一个类是，它必须具备这个类的所有功能（包括属性与方法）。 这样是有缺陷的，比如： 我们有一个叫做Beverage 饮料的类 是一个抽象类（代表我们不能像接口一样 去实例化） 其中，Beverage有价格属性以及得到价格的方法 现在Beverage有两个子类：1. 咖啡 2. 茶 现在我们按照一般的思路来添加功能，就是直接在Beverage类中添加（比如咖啡是否加牛奶） 但是，试想一下，如果有牛奶这个属性，对于茶来说，就可能显得没必要了（抱歉如果你喜欢这么搭配，无意冒犯） 也就是说，部分子类有时，没必要拥有父类的所有信息。 所以，我们的装饰器模式就是来解决这样的问题：如何在不更改已有代码的同时，更高效地添加对象的功能。 UML图示 从这个图中，我们需要看到最重要的概念： 对于装饰器来说，它即具有饮料成员变量，同时自己又是一个饮料 很好解释：对于奶茶店里的珍珠，首先它要知道自己加到哪杯饮料上去，其次加到那杯饮料过后，它们共同组成了一杯新的饮料。 这样，一层一层的包裹，可以动态地延展系统中对象的功能。 代码实现 这里我们有Milk与Coffee两种饮料，分别卖5元与10元 这里我们有可选选项Sugar，加糖多加1元 首先我们要有抽象类Beverage.java 123456package com.company.entity;public abstract class Beverage &#123; public abstract int getPrice();&#125; 然后我们有两个继承Beverage的Milk.java与Coffee.java 12345678910package com.company.entity;public class Milk extends Beverage&#123; //假设菜单上规定 牛奶一杯5元 @Override public int getPrice() &#123; return 5; &#125;&#125; 12345678910package com.company.entity;public class Coffee extends Beverage&#123; //假设菜单上规定 咖啡一杯10元（注意，咖啡与牛奶都是基础选项） @Override public int getPrice() &#123; return 10; &#125;&#125; 接下来我们要有，一个抽象类AddOnDecorator.java 12345678package com.company.decorator;import com.company.entity.Beverage;public abstract class AddOnDecorator extends Beverage &#123; public abstract int getPrice();&#125; 最后我们要有自己的可选选项SugarDecorator.java去继承这个抽象类 1234567891011121314151617181920212223package com.company.decorator;import com.company.entity.Beverage;public class SugarDecorator extends AddOnDecorator &#123; //被包裹的内层 不管之前加了什么、 // （可以是咖啡来加糖 也可以是牛奶来加糖） Beverage beverage; public SugarDecorator(Beverage beverage)&#123; this.beverage = beverage; &#125; //这里糖是可选选项 // 当你给已有的饮料加糖时 加上糖后 // 仍然是饮料 还可以加其他的东西 @Override public int getPrice() &#123; return this.beverage.getPrice() + 1; &#125;&#125; 这里的关键代码是： 12345Beverage beverage;...return this.beverage.getPrice() + 1; 就相当于给里层的饮料，加了一层价格1元，但是里层的饮料还加了什么我们不在乎。 因为，不管加了什么可选选项，它同时就是一杯饮料。 最后，我们用Main.java运行即可： 1234567891011121314151617181920212223package com.company;import com.company.decorator.SugarDecorator;import com.company.entity.Beverage;import com.company.entity.Coffee;public class Main &#123; public static void main(String[] args) &#123; Coffee coffee = new Coffee(); System.out.println(&quot;如果只点一杯咖啡，价格是：&quot; + coffee.getPrice() + &quot;元&quot; ); System.out.println(&quot;...&quot;); System.out.println(&quot;咖啡太苦了，准备加糖...&quot;); SugarDecorator sugarDecorator = new SugarDecorator(coffee); System.out.println(&quot;加完糖后，整个饮料的价格是：&quot; + sugarDecorator.getPrice()); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"vincent"},{"title":"毕业答辩_重点图表","slug":"毕业答辩-重点图表","date":"2021-05-17T02:36:55.000Z","updated":"2021-11-09T07:53:30.220Z","comments":true,"path":"毕业答辩-重点图表/","link":"","permalink":"https://github.com/Vincent990413/blog/%E6%AF%95%E4%B8%9A%E7%AD%94%E8%BE%A9-%E9%87%8D%E7%82%B9%E5%9B%BE%E8%A1%A8/","excerpt":"","text":"E-R 图 E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 矩形框代表实体 菱形框代表联系 实线上的1:1 1:m m:n分别代表一对一、一对多以及多对多关系 椭圆框代表实体的各个属性，如果是主键则加上下划线。 时序图 时序图（Sequence Diagram），又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。 时序图由以下部分构成： 角色 角色通常是人（图中的教师），当然也可以是系统或者子系统 对象 对象通常位于时序图的顶部，一般直接写类名即可 生命线 对象下面的虚线即称为生命线，而消息在两条生命线之间进行传递 控制焦点控制焦点，一般指的是对象下的矩形框，即对象操作的声明周期 消息在两条相邻的生命线中，消息在这之间进行传递，消息传递的本质就是方法的调用。 数据流图 数据流图（Data Flow Diagram）：简称DFD，它从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。 值得注意的是，数据流图不是传统的流程图或框图，数据流也不是控制流。数据流图是从数据的角度来描述一个系统，而框图是从对数据进行加工的工作人员的角度来描述系统。 也就是说，数据流图的根本，就是用不同层级来描述数据是怎样流动的，从哪里到哪里，中间经过了什么加工处理。 数据流图，分为顶层与第一层、第二层... UML用例图 用例图是用来描述系统功能的技术，表示一个系统中用例与参与者及其关系的图。 也就是说，用例图展示的是，系统为不同参与者提供的不同（用例）的功能。 参与者一般可以是系统内部的不同角色(图中的管理员）、或者也可以是系统外部的参与角色 一个用例是一个基本单元（图中的个人信息管理、教师管理等等） 用例与用例之间具备一些关系（比如图中虚线表示的的包含关系等等）","categories":[{"name":"毕业答辩","slug":"毕业答辩","permalink":"https://github.com/Vincent990413/blog/categories/%E6%AF%95%E4%B8%9A%E7%AD%94%E8%BE%A9/"}],"tags":[{"name":"毕业答辩","slug":"毕业答辩","permalink":"https://github.com/Vincent990413/blog/tags/%E6%AF%95%E4%B8%9A%E7%AD%94%E8%BE%A9/"}],"author":"vincent"},{"title":"毕业答辩_总体注意事项","slug":"毕业答辩-总体注意事项","date":"2021-05-17T02:35:46.000Z","updated":"2021-11-09T07:53:30.219Z","comments":true,"path":"毕业答辩-总体注意事项/","link":"","permalink":"https://github.com/Vincent990413/blog/%E6%AF%95%E4%B8%9A%E7%AD%94%E8%BE%A9-%E6%80%BB%E4%BD%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"答辩需要注意的事情封面一定保持校正一致 大数据学院加上 校外指导教师不能少 日期已正确 勿修改 摘要 研究什么东西（涉及到论文题目的解析） 用的什么技术（SpringMVC+Spring+Mybatis 凡是论文中出现的英文名 要知道是什么） 关键词语：要体现论文的题目 言简意赅 突出业务核心 不要冗余 英文摘要检查单词之间是否有空格 首字母大写 目录一定要删掉目录中的目录。 以及英文摘要与绪论之间 页眉记得要带编号 绪论 | 前言切记，不要内容太少了。要保证字数要有一页！！！ 技术介绍： 1. Tomcat（具体是干什么的？） 2. Spring...（常见的后台框架，以及简单的运作原理） 3. Ajax以及前端框架Bootstrap等等（记得概念） 注意，格式：如果要么是Mybatis就全文全部都是Mybatis！不要来个mybatis 系统分析 可行性（XX可行性分析等等） 功能分析（几个角色） 用例分析：（提供用例图（执行人以及执行功能）、增加用例说明（业务逻辑）） 用例图 要了解用例图的意义，以及其中的基本组成成分。 对用例图，要辅佐于一定的用例说明，否则无法根据业务进行代码编写。* 功能结构图# 注意结构图，要条状清晰，整体对齐 系统设计数据库设计实体图实体图不是E-R图 一般来说，写了几个实体图，就要有对应的几个E-R图。 每个字段要知道什么意思！ E-R图注意，要搞清楚一对多的关系！（检查数据库，表与表之间的关系。） 要对应实体图！ 一对多，一对一一般不做多的表，多对多要建立新的表。 时序图 系统实现代码讲解要注意找到对应的后台代码 以登录举例：（如果老师问，就在对应的页面操作！） 运行代码，按F12，调出控制台 点击对应到后台action的事件，看看触发了什么请求方法名？ login 那么在对应后台的Controller中找这个方法！ 可以使用快捷键：Ctrl + Shift + R 全局搜索这个RequestMapping 讲代码的时候，不要乱&amp;按照逻辑来讲，尽量编写代码的时候（见词生意） ==遇到不会的，那就点到为止== 尽量不要贴前端代码，代码不要贴太多，不要超过一页！ 系统测试要了解常见的测试方法：黑盒测试，白盒测试。 最好附上，系统测试表。 总结 具体开发个什么东西？ 开发的过程中，用到什么工具？ 开发过程中，遇到什么具体的问题？ 未来维护中，怎么解决所遇到的问题？或者整体是否有更好的架构工具！？ 参考文献姓名，参考来源，时间。 不要有其他的特殊符号，中间一般只有逗号与点注意，如果英文参考文献，单词之间间隔过大，可以通过以下办法调整： 选中这段英文参考文献 右键段落（Office 2010为例） 中文版式，中选择允许西文在单词中间换行 致谢检查，不要抄别人的致谢！ 遗留重点 再次熟悉代码 熟悉常见的图（用例图，数据流图，E-R图等等以及其中的概念） 提前检查环境，数据库+后台+前端页面","categories":[{"name":"毕业答辩","slug":"毕业答辩","permalink":"https://github.com/Vincent990413/blog/categories/%E6%AF%95%E4%B8%9A%E7%AD%94%E8%BE%A9/"}],"tags":[{"name":"毕业答辩","slug":"毕业答辩","permalink":"https://github.com/Vincent990413/blog/tags/%E6%AF%95%E4%B8%9A%E7%AD%94%E8%BE%A9/"}],"author":"vincent"},{"title":"设计模式学习_观察者模式","slug":"设计模式学习-观察者模式","date":"2021-05-16T13:14:46.000Z","updated":"2021-11-09T07:53:30.229Z","comments":true,"path":"设计模式学习-观察者模式/","link":"","permalink":"https://github.com/Vincent990413/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式 Observer Pattern 这很好解释：气象监测总部WeatherStation与我们的手机APP PhoneDisplay之间的关系。 我们看天气的时候，数据都是依照最新的数据变化而变化的，而变化的数据，来源于具体发送数据的仪器（比如天气传感器 Weather Sensor） 也就是说，我们可以利用这种模式，来更好地在数据变化后，让所有显示器设备更新数据变化消息。 关键概念1. 观察者模式定义了一种“一对多”的关系。 2. 当这个关系中的“一”，数据发生变化时，其中所依赖的“多”将会自动地进行变化。 解释： 这里ISubject与IObserver如何体现一对多关系？ 为什么PhoneDisplay与TvDisplay要有WeatherStation呢？ 对于第一个问题，我们在每个ISubject中，附上一个List&lt;IObserver&gt; observers列表。 对于第二个问题，回答是：我们的显示屏要显示数据变化，而这些数据来源始终是WeatherStation。 因此，update函数其实要用到WeatherStation的数据。 代码思路&amp;实现： 很简单，如果某一个时刻，WeatherStation中的数据（可以是成员变量）变化了，那么我们就执行notify()来通知List中的每一个Observer。 接下来，我们用代码来实现： 抽象接口层面： ISubject.java 12345678package com.company.inter;public interface ISubject &#123; void add(IObserver iObserver); void remove(IObserver iObserver); void notifyObserver();&#125; IObserver.java 12345package com.company.inter;public interface IObserver &#123; void update();&#125; 具体实现层面 WeatherStation 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.company.entity;import com.company.inter.IObserver;import com.company.inter.ISubject;import java.util.ArrayList;import java.util.List;public class WeatherStation implements ISubject &#123; //被注册进来的所有观察者 List&lt;IObserver&gt; observers = new ArrayList&lt;&gt;(); //温度变量 当温度变量发生变化时 通知所有观察者 Integer temperature = 18; //将观察者注册进来 其中就是用list add进来 @Override public void add(IObserver iObserver) &#123; this.observers.add(iObserver); &#125; @Override public void remove(IObserver iObserver) &#123; observers.remove(iObserver); &#125; //在温度变量发生变化后 每一个观察者通过update方法来得到最新数据 @Override public void notifyObserver() &#123; //通知每一个观察者 for(IObserver iObserver: this.observers)&#123; iObserver.update(); &#125; &#125; public Integer getTemperature()&#123; return this.temperature; &#125; //模拟实现数据变化 public void setTemperature(Integer temperature)&#123; this.temperature = temperature; &#125;&#125; PhoneDisplay.java 1234567891011121314151617181920package com.company.entity;import com.company.inter.IObserver;public class PhoneDisplay implements IObserver&#123; WeatherStation weatherStation; //我们需要得到变化后的数据信息 因此需要通过构造方法 &lt;绑定&gt; 一个被观察者 public PhoneDisplay(WeatherStation weatherStation)&#123; this.weatherStation = weatherStation; &#125; //通过这个被观察者的public get方法 我们才可以知道最新的数据信息 @Override public void update() &#123; System.out.println(&quot;数据发生变化，最新温度为:&quot; + this.weatherStation.getTemperature()); &#125;&#125; TvDisplay.java 1234567891011121314151617181920package com.company.entity;import com.company.inter.IObserver;public class TvDisplay implements IObserver&#123; WeatherStation weatherStation; //我们需要得到变化后的数据信息 因此需要通过构造方法 &lt;绑定&gt; 一个被观察者 public TvDisplay(WeatherStation weatherStation)&#123; this.weatherStation = weatherStation; &#125; //通过这个被观察者的public get方法 我们才可以知道最新的数据信息 @Override public void update() &#123; System.out.println(&quot;数据发生变化，最新温度为:&quot; + this.weatherStation.getTemperature()); &#125;&#125; 主函数：12345678910111213141516171819202122232425262728293031323334353637383940package com.company;import com.company.entity.PhoneDisplay;import com.company.entity.TvDisplay;import com.company.entity.WeatherStation;public class Main &#123; public static void main(String[] args) &#123; WeatherStation weatherStation = new WeatherStation(); //手机显示器实时绑定天气预报站台 PhoneDisplay phoneDisplay = new PhoneDisplay(weatherStation); //电视机显示器实时绑定天气预报站台 TvDisplay tvDisplay = new TvDisplay(weatherStation); //天气预报站台将手机显示器注册进来 weatherStation.add(phoneDisplay); //天气预报站台将电视机显示器注册进来 weatherStation.add(tvDisplay); System.out.println(&quot;天气正常，一直都是：&quot; + String.valueOf(weatherStation.getTemperature()) + &quot;摄氏度.&quot;); System.out.println(&quot;某一时刻，数据突然发生变化...&quot;); weatherStation.setTemperature(-20); System.out.println(&quot;天气预报站台准备广播消息！Broadcasting...&quot;); weatherStation.notifyObserver(); System.out.print(&quot;手机显示器这边显示：&quot;); phoneDisplay.update(); System.out.print(&quot;电视机显示器这边显示：&quot;); tvDisplay.update(); &#125;&#125; 效果图","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"vincent"},{"title":"设计模式学习_策略模式","slug":"设计模式学习-策略模式","date":"2021-05-15T15:05:45.000Z","updated":"2021-11-09T07:53:30.226Z","comments":true,"path":"设计模式学习-策略模式/","link":"","permalink":"https://github.com/Vincent990413/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略者模式 Strategy Pattern 使用背景 定义： 我们将算法Algorithm与使用者Client分离，让这些使用者自由地选择策略。 想象这样一个场景： 有一个基类Duck，它具有两个方法：void eat() 与 void fly() eat代表吃 fly代表飞行 现在有两个subclass 子类：WildDuck 与 CityDuck 它们在eat的行为上一摸一样 它们在fly的行为上不一样 试想，如果我们用Java来实现： 整个UML图可能是这样： 其中，- 代表这是一个私有方法，且void代表它无返回值。 前面，我们提到：这两种鸭子的eat行为是一样的，而fly的行为不一样。 那么，在这种单重继承的情况下，如果eat行为一样，我们只能重复的复制粘贴代码。 想象一下，当子类的数目在需求增大的过程中越来越多？这样的代码不具有高重用性与可维护性。 使用策略者模式解决问题 在上述问题中，eat与fly可以代表两种算法或者策略 使用者就是WildDuck以及CityDuck 我们希望对于不同的使用者，可以任意使用策略。 解决方案：我们将同一种策略，封装成接口Interface，然后采用不同的实现策略（即不同的实现类） 同时，将这些接口，注入到我们的使用者中。 使用具体的方法时，我们使用这些使用者的所注入进来的实现类的具体方法。 直接上UML图：（图不规范，见谅。） 从这个图中，我们可以看到： Duck类具有两个接口:IEatBehavior与IFlyBehavior 每个接口都有若干个实现类（策略） 当子类WildDuck与CityDuck继承Duck时，具有父类的所有资源。 那么如何用代码实现呢？ 代码实现： 首先，我们要有一个基类 Duck.java以及它的子类 WildDuck.java与CityDuck.java123456789101112131415161718192021222324package com.company.entity;import com.company.inter.IEatBehavior;import com.company.inter.IFlyBehavior;public class Duck &#123; IEatBehavior iEatBehavior; IFlyBehavior iFlyBehavior; public Duck(IEatBehavior iEatBehavior, IFlyBehavior iFlyBehavior) &#123; this.iEatBehavior = iEatBehavior; this.iFlyBehavior = iFlyBehavior; &#125; public void eat()&#123; this.iEatBehavior.eat(); &#125; public void fly()&#123; this.iFlyBehavior.fly(); &#125;&#125; 可以看到，这里有两个接口，分别代表两种策略（Eat与Fly） # WildDuck.java 1234567891011package com.company.entity;import com.company.inter.IEatBehavior;import com.company.inter.IFlyBehavior;public class WildDuck extends Duck&#123; public WildDuck(IEatBehavior iEatBehavior, IFlyBehavior iFlyBehavior) &#123; super(iEatBehavior, iFlyBehavior); &#125;&#125; # CityDuck.java 1234567891011package com.company.entity;import com.company.inter.IEatBehavior;import com.company.inter.IFlyBehavior;public class CityDuck extends Duck&#123; public CityDuck(IEatBehavior iEatBehavior, IFlyBehavior iFlyBehavior) &#123; super(iEatBehavior, iFlyBehavior); &#125;&#125; 定义两种接口 # iEatBehavior.java 123456package com.company.inter;public interface IEatBehavior &#123; public void eat();&#125; # iFlyBehavior.java 123456package com.company.inter;public interface IFlyBehavior &#123; public void fly();&#125; 定义这些接口的不同策略实现类 # SimpleEatBehaviorImpl.java 12345678910package com.company.impl;import com.company.inter.IEatBehavior;public class SimpleEatBehaviorImpl implements IEatBehavior &#123; @Override public void eat() &#123; System.out.println(&quot;吃：采用正常吃饭的策略！&quot;); &#125;&#125; # SimpleFlyBehaviorImpl.java 123456789101112package com.company.impl;import com.company.inter.IFlyBehavior;public class SimpleFlyBehaviorImpl implements IFlyBehavior &#123; @Override public void fly() &#123; System.out.println(&quot;飞：采用正常飞的策略！&quot;); &#125;&#125; # JetFlyBehaviorImpl.java 123456789101112package com.company.impl;import com.company.inter.IFlyBehavior;public class JetFlyBehaviorImpl implements IFlyBehavior &#123; @Override public void fly() &#123; System.out.println(&quot;飞：采用喷气式飞行的策略！&quot;); &#125;&#125; 那么目前为止，我们已经将这些策略与使用者分离了。 使用的时候，我们只需要让他们使用不同的策略即可。 # Main.java 1234567891011121314151617181920212223242526272829303132package com.company;import com.company.entity.CityDuck;import com.company.entity.WildDuck;import com.company.impl.JetFlyBehaviorImpl;import com.company.impl.SimpleEatBehaviorImpl;import com.company.impl.SimpleFlyBehaviorImpl;import com.company.inter.IEatBehavior;import com.company.inter.IFlyBehavior;public class Main &#123; public static void main(String[] args) &#123; //对于城市Duck来说 Eat采用的是simpleEat策略 Fly也采用的是simpleFly策略 IEatBehavior iSimpleEatBehavior = new SimpleEatBehaviorImpl(); IFlyBehavior iSimpleFlyBehavior = new SimpleFlyBehaviorImpl(); CityDuck cityDuck = new CityDuck(iSimpleEatBehavior, iSimpleFlyBehavior); System.out.println(&quot;城市鸭子采用的策略：&quot;); cityDuck.eat(); cityDuck.fly(); //对于城市Duck来说 Eat采用的是simpleEat策略（直接重用） Fly采用的是jetFly策略 IFlyBehavior iJetFlyBehavior = new JetFlyBehaviorImpl(); WildDuck wildDuck = new WildDuck(iSimpleEatBehavior, iJetFlyBehavior); System.out.println(&quot;接下来是野鸭子采用的策略：&quot;); wildDuck.eat(); wildDuck.fly(); &#125;&#125; 效果图：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"vincent"},{"title":"Hexo学习笔记以及常见错误","slug":"hexo学习笔记以及常见错误","date":"2021-05-07T02:28:50.000Z","updated":"2021-11-09T07:53:30.187Z","comments":true,"path":"hexo学习笔记以及常见错误/","link":"","permalink":"https://github.com/Vincent990413/blog/hexo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/","excerpt":"","text":"前提，注意！在进行任何更改后，务必进行以下代码： 12345//在本地看到效果，而不部署githexo clean &amp; hexo s//想在git上（比如码云或者github）看到效果hexo clean &amp; hexo g &amp; hexo d 在输入hexo g后 才会生成public目录 引入别人的主题若启动时报以下错误extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial 则在博客根路径中，键入以下代码： 1npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive 在使用别人的主题过程中，一定要去看别人发布的关于这个主题的使用文档！ 看文档！ 看文档！ 看文档！ 博客中的文章字数统计插件1npm install hexo-wordcount --save 然后在主题中的配置文件中打开wordcount: 博客中的本地搜索插件1npm install hexo-generator-json-content --save 在blog根目录中的config.yml中，键入代码： 12345# 本地搜索search: path: search.json field: post content: true 在自己的主题目录下的config.yml中打开本地搜索，键入代码： 123local_search: # 是否启用 enable: true 博客中的Valine评论（前提是上传到Gitee或者GitHub） 首先在主题中的config.yml中 找到对应Valine的区域enable相应的Valine插件 1234567891011121314151617181920212223242526# Valine# See: https://valine.js.org/quickstart.htmlvaline: enable: true # Your leancloud application appid. appid: LeanCloud上创建的appid # Your leancloud application appkey. appkey: LeanCloud上创建的appkey # Mail notifier. notify: true # Verification code. verify: true # Comment box placeholder. placeholder: 说点啥再走呗~爱你 # Gravatar style. avatar: mp # Custom comment header. meta: nick,email # Pagination size. pageSize: 10 # Article reading statistics. visitor: false # Whether to record the commenter IP. recordIP: false # Optional values: en | zh-cn language: 去LeanCloud上注册相关应用并打开你的白名单域名（设置，安全中心）https://vincent990413.gitee.io/myblog/根目录，比如：`https://vincent990413.gitee.io/myblog/` 写完博客，成功部署到这个白名单页面即可。 部署到Gitee过程以及会出现的错误 Gitee创建项目 并获得Git拉取地址(....xxx.git) 1https://gitee.com/vincent990413/myblog.git 在博客根目录配置文件中指定提交的git地址 12345deploy: type: git # 这个是克隆项目时的地址！ repo: https://gitee.com/vincent990413/myblog.git branch: master 在博客根目录配置文件中引入资源根地址 1234# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://vincent990413.gitee.io/myblogroot: /myblog/ 部署项目时出现403 have no permission错误点我看解决方案（转） 部署项目到github&amp;gitee上如果出现Can&#39;t access... 就是网络问题，重复部署即可。 部署到Github只需要改动博客根目录下的配置文件即可（前提是主题中的配置文件等导航栏、静态图片引入正确）： 1234567891011# 访问项目的URL## Set your site url here. For example, if you use GitHub Page, ## set url as &#x27;https://username.github.io/project&#x27;url: https://vincent990413.github.io/# 部署项目的git地址deploy: type: git # 这个是克隆项目时的地址！ repo: https://github.com/vincent990413/vincent990413.github.io.git branch: master 注意：当部署到Gitee码云时，如果页面的静态资源文件无法正常显示，很有可能时引用问题。 比如:如果引入某个照片，如果是部署到Github下，键入代码： 1url: /images/myPhoto.jpg 如果是引入到Gitee中，键入代码： 12url: /本页上方关于部署到Gitee git地址末尾的二级目录/images/myPhoto.jpgurl: /myblog/images/myPhoto.jpg 而且，需要将静态资源文件，放在根目录以及主题目录的两个source目录下（都要放）。","categories":[{"name":"Hexo 学习笔记","slug":"hexo-学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/hexo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Hexo 学习笔记","slug":"hexo-学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/hexo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"英语学习_16个代替very的表达","slug":"英语学习-16个代替very的表达","date":"2021-05-07T01:32:21.000Z","updated":"2021-11-09T07:53:30.224Z","comments":true,"path":"英语学习-16个代替very的表达/","link":"","permalink":"https://github.com/Vincent990413/blog/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0-16%E4%B8%AA%E4%BB%A3%E6%9B%BFvery%E7%9A%84%E8%A1%A8%E8%BE%BE/","excerpt":"","text":"Get rid of &quot;Very X&quot;16个代替very + adj 的表达 普通表达 进阶表达 Very beautiful Charming, Gorgeous, Stunning Very tired Exhausted, Completely exhausted Very sad Heart-broken, Devastated Very happy Delighted, Thrilled, Be on cloud nine Very surprise Amazed, Astonished Very small Tiny, Minuscale Very big Huge, Massive, Giant, Tremendous, Humongous Very bad Horrible, Terrible, Awful, Horrendous Very diffcult Challenging, Demanding Very simple A piece of cake, Staightforward Very smart Witty, Brilliant, Intelligent Very important Crucial, Vital, Essential Very interesting Fascinating, Captivating Very hungry Starving, Famished Very angry Mad, Pissed of, Furious","categories":[{"name":"英语学习","slug":"英语学习","permalink":"https://github.com/Vincent990413/blog/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"英语学习","slug":"英语学习","permalink":"https://github.com/Vincent990413/blog/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"基于VUE&Firebase的在线聊天室APP","slug":"基于VUE-Firebase在线聊天室APP","date":"2021-05-04T01:30:10.000Z","updated":"2021-11-09T07:53:30.217Z","comments":true,"path":"基于VUE-Firebase在线聊天室APP/","link":"","permalink":"https://github.com/Vincent990413/blog/%E5%9F%BA%E4%BA%8EVUE-Firebase%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%AE%A4APP/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< 前言这一期我们准备做一个基于VUE3.0 Composition API与FireBase的在线聊天室 用户登陆到我们的在线聊天室进行聊天 前期准备命令行中利用vue-cli创建vue3.0项目 12vue create test //test是项目名 选择手动添加Manually select features 选择上述勾选项 接下来，选择3.x（preview）因为要用到VUE的composition API 选择with node-sass，如下图所示： 然后一直enter即可，直到出现package.json，如图所示： 选择In package.json 出现preset选项，选择否 not save 然后经过漫长的等待... 如果一切顺利，那么会出现下图所示： 12345Successfully created project test.Get started with the following commands:$ cd test$ npm run serve cd 切换到这个新项目的工作目录。 这个时候我们要安装Firebase数据库用于聊天室中所有消息的存储 注意，Firebase由Google创建并持续维护，安装前请科学上网 ? ? 1npm i firebase 目前为止，我们的前期工作就已经做好了！ 然后利用VS Code或者IDEA等编译器导入这个VUE项目即可 配置项目的数据库Firebase首先，我们需要修改一个配置信息 打开package.json 在&quot;rules&quot;中添加： 1&quot;no-unused-vars&quot;: &quot;off&quot; 因为在做一些初始配置，所以演示的时候，可能会因为定义了未被使用的变量而报错。 Src 目录下创建db.js firebase配置数据库信息 进入db.js 输入以下备用代码： 1234567891011import firebase from &quot;firebase/app&quot;;import &quot;firebase/database&quot;;const config = &#123; //API KEYS &#125;const db = firebase.initializeApp(config)export default db; 这里注意到，我们的config中还没有配置我们firebase的接口信息（包括你这个应用的KEY、用户KEYS、项目ID等等） 因此，接下来我们要去firebase的官网配置： 点击右上角的转到控制台 点击添加项目并输入项目名称 取消勾选“为此项目启动 Google Analytics分析” 等待正在创建项目... 点击对应的项目名，顺利的话，会进入以下画面： 添加网页端应用，并获取到应用接口信息 输入我们的应用别名，注册应用后，可以获得Firebase SDK （下图所示） 由于我们已经在项目中 预先安装了firebase 那么就不用最上面的JS引入语句了 JS文件内容如下： 12345678910111213&lt;script&gt; // Your web app&#x27;s Firebase configuration var firebaseConfig = &#123; apiKey: &quot;AIzaSyAgKkSD7cherkQylfbmrr_cCb6awLk9ynk&quot;, authDomain: &quot;test-dc7e4.firebaseapp.com&quot;, projectId: &quot;test-dc7e4&quot;, storageBucket: &quot;test-dc7e4.appspot.com&quot;, messagingSenderId: &quot;594878054873&quot;, appId: &quot;1:594878054873:web:9d533554407419fe7259c8&quot; &#125;; // Initialize Firebase firebase.initializeApp(firebaseConfig);&lt;/script&gt; 我们需要将firebaseConfig中的内容粘贴到，我们的db.js中去： 我的配置信息如下图所示： 配置实时数据库 RealTime Database 这一步，是为了查看聊天室中的实时存储的消息。 导航栏左侧的Realtime Database实时数据库 一步步创建即可 记得数据库位置需要选择美国 US ?? 那么，到目前为止，数据库配置信息完成了。 进入项目页面的样式添加进入初始话的文件，我们将没用的初始文件都删掉：component以及assets中的内容 进入APP.vue中，写好初始页面： 123456789101112131415161718&lt;template&gt;&lt;/template&gt;&lt;script&gt; export default&#123; setup()&#123; return&#123; &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 我们可以发现，与VUE2.0不同的是，我们使用setup来配置初始化信息，并且在初始化之后，return这些信息，让前端页面任何地方可以引用这些数据（比如用于v-model)。 接下来，将以下样式贴到style中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205* &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; margin: 0; padding: 0; box-sizing: border-box;&#125;.view &#123; display: flex; justify-content: center; min-height: 100vh; background-color: #ea526f; &amp;.login &#123; align-items: center; .login-form &#123; display: block; width: 100%; padding: 15px; .form-inner &#123; display: block; background-color: #FFF; padding: 50px 15px; border-radius: 16px; box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2); h1 &#123; color: #AAA; font-size: 28px; margin-bottom: 30px; &#125; label &#123; display: block; margin-bottom: 5px; color: #AAA; font-size: 16px; transition: 0.4s; &#125; input[type=&quot;text&quot;] &#123; appearance: none; border: none; outline: none; background: none; display: block; width: 100%; padding: 10px 15px; border-radius: 8px; margin-bottom: 15px; color: #333; font-size: 18px; box-shadow: 0px 0px 0px rgba(0, 0, 0, 0); background-color: #F3F3F3; transition: 0.4s; &amp;::placeholder &#123; color: #888; transition: 0.4s; &#125; &#125; input[type=&quot;submit&quot;] &#123; appearance: none; border: none; outline: none; background: none; display: block; width: 100%; padding: 10px 15px; background-color: #ea526f; border-radius: 8px; color: #FFF; font-size: 18px; font-weight: 700; &#125; &amp;:focus-within &#123; label &#123; color: #ea526f; &#125; input[type=&quot;text&quot;] &#123; background-color: #FFF; box-shadow: 0 0 6px rgba(0, 0, 0, 0.2); &amp;::placeholder &#123; color: #666; &#125; &#125; &#125; &#125; &#125; &#125; &amp;.chat &#123; flex-direction: column; header &#123; position: relative; display: block; width: 100%; padding: 50px 30px 10px; .logout &#123; position: absolute; top: 15px; right: 15px; appearance: none; border: none; outline: none; background: none; color: #FFF; font-size: 18px; margin-bottom: 10px; text-align: right; &#125; h1 &#123; color: #FFF; &#125; &#125; .chat-box &#123; border-radius: 24px 24px 0px 0px; background-color: #FFF; box-shadow: 0px 0px 12px rgba(100, 100, 100, 0.2); flex: 1 1 100%; padding: 30px; .message &#123; display: flex; margin-bottom: 15px; .message-inner &#123; .username &#123; color: #888; font-size: 16px; margin-bottom: 5px; padding-left: 15px; padding-right: 15px; &#125; .content &#123; display: inline-block; padding: 10px 20px; background-color: #F3F3F3; border-radius: 999px; color: #333; font-size: 18px; line-height: 1.2em; text-align: left; &#125; &#125; &amp;.current-user &#123; margin-top: 30px; justify-content: flex-end; text-align: right; .message-inner &#123; max-width: 75%; .content &#123; color: #FFF; font-weight: 600; background-color: #ea526f; &#125; &#125; &#125; &#125; &#125; footer &#123; position: sticky; bottom: 0px; background-color: #FFF; padding: 30px; box-shadow: 0px 0px 12px rgba(100, 100, 100, 0.2); form &#123; display: flex; input[type=&quot;text&quot;] &#123; flex: 1 1 100%; appearance: none; border: none; outline: none; background: none; display: block; width: 100%; padding: 10px 15px; border-radius: 8px 0px 0px 8px; color: #333; font-size: 18px; box-shadow: 0px 0px 0px rgba(0, 0, 0, 0); background-color: #F3F3F3; transition: 0.4s; &amp;::placeholder &#123; color: #888; transition: 0.4s; &#125; &#125; input[type=&quot;submit&quot;] &#123; appearance: none; border: none; outline: none; background: none; display: block; padding: 10px 15px; border-radius: 0px 8px 8px 0px; background-color: #ea526f; color: #FFF; font-size: 18px; font-weight: 700; &#125; &#125; &#125; &#125;&#125; 登陆模块 定义默认提交进入的方法 @submit.prevent=&quot;Login&quot; 绑定事件 定义登陆时，输入框中输入的信息所绑定的变量(导入vue的ref) const inputUsername = ref(&quot;&quot;); 登录时，将输入框中的值对应的信息保存数据库中，否则下次登陆系统后，以前的信息（包括用户名与消息）都不会保存起来(导入vue的reactive响应变动) JS中的setup中配置相应的变量与方法（记得返回这些数据让页面显示可以使用） 1234567891011121314151617181920212223242526272829import &#123; reactive, onMounted, ref &#125; from &#x27;vue&#x27;;import db from &#x27;./db&#x27;;export default&#123; setup () &#123; //定义输入框输入绑定的变量 以及 保存用户信息的state变量 const inputUsername = ref(&quot;&quot;); //初始化为空 相当于vue2.0的 inputUsername: &#x27;&#x27; const state = reactive(&#123; //用户发的信息 后面会用到 username: &quot;&quot;, messages: [] &#125;); //定义表单提交绑定的方法 const Login = () =&gt; &#123; //与vue2.0不同的是 我们不再用this.val //检测到用户输入信息 就存储用户登陆信息 if(inputUsername.value != &quot;&quot; || inputUsername.value != null)&#123; state.username = inputUsername.value; inputUsername.value = &quot;&quot;; &#125; &#125; return&#123; inputUsername, Login, state &#125; &#125;&#125; 页面显示 12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;view login&quot; v-if=&quot;state.username === &#x27;&#x27; || state.username === null&quot;&gt; &lt;form class=&quot;login-form&quot; @submit.prevent=&quot;Login&quot;&gt; &lt;div class=&quot;form-inner&quot;&gt; &lt;h1&gt;Login to FireChat&lt;/h1&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputUsername&quot; placeholder=&quot;Please enter your username...&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;view chat&quot; v-else&gt; &lt;h1&gt; 这是聊天室显示区域 &lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; 用户界面效果图，如下图所示： 可以看到，我们使用了v-if进行判断 如果存储在state中的用户名信息不为空（即表示用户填入了信息想进入聊天室） 则显示这是聊天室显示区域 否则会显示登陆区域让用户进行登陆(由于是在线聊天室，不设置密码) 从聊天室中注销出来 刚才我们模拟进入了聊天室，现在我们添加注销功能 123456&lt;div class=&quot;view chat&quot; v-else&gt; &lt;header&gt; &lt;button class=&quot;logout&quot; @click=&quot;Logout&quot;&gt;Logout&lt;/button&gt; &lt;h1&gt;Welcome, &#123;&#123; state.username &#125;&#125;&lt;/h1&gt; &lt;/header&gt; &lt;/div&gt; 前端页面写好了，补充JS中的Logout方法，还是写在setup中 12345678910const Logout = () =&gt; &#123; state.username = &quot;&quot;;&#125;//别忘了return 让前端页面调用return&#123; ...Login, state, Logout &#125; 前面提到了，当state中的username为空或者为null时，会显示登陆区域。 为聊天室添加（发送消息，查看消息功能） 这是最后一个步骤了，也是需要用到firebase（特别是我们刚才配置的实时数据库）的一步 首先在刚才注销区域&lt;header&gt;标签 的下方，加入代码： 1234567891011121314151617181920212223&lt;section class=&quot;chat-box&quot;&gt; &lt;div v-for=&quot;message in state.messages&quot; :key=&quot;message.key&quot; :class=&quot;(message.username == state.username ? &#x27;message current-user&#x27; : &#x27;message&#x27;)&quot;&gt; &lt;div class=&quot;message-inner&quot;&gt; &lt;div class=&quot;username&quot;&gt;&#123;&#123; message.username &#125;&#125;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&#123;&#123; message.content &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt;&lt;footer&gt; &lt;form @submit.prevent=&quot;SendMessage&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputMessage&quot; placeholder=&quot;Write a message...&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Send&quot; /&gt; &lt;/form&gt;&lt;/footer&gt; 可以看到，我们用到了SendMessage方法用来发送数据 用到了state中的messages并且将当前用户的前端样式区别于其他用户 并且从messages中取出所有消息 利用v-for在前端中显示 输入的消息绑定v-model inputMessage 那么，下面就可以定义消息变量以及相应发送消息的函数！ 还是写在setup中 并注意return给前端使用 12345678910111213141516//const inputUsername = ref(&quot;&quot;);const inputMessage = ref(&quot;&quot;);const SendMessage = () =&gt; &#123; const messagesRef = db.database().ref(&quot;messages&quot;); //firebase数据库 if(inputMessage.value === &quot;&quot; || inputMessage.value === value)&#123; //用户不能发送空消息 return; &#125; const message = &#123; //准备将发送的消息存储至数据库中 username: stae.username, content: inputMessage.value &#125; messageRef.push(message); //相当于MySQL中的insert firebase是基于JSON的 故用push inputMessage.value = &quot;&quot;;&#125; 那么，到目前位置，我们写入数据库的操作就写完了。 但是现在是无法实时看到，任何用户发送的消息的，为什么？ 因为，我们虽然存储到了firebase数据库中去，但是我们每次v-for取出的数据，是从state中取出的 因此，下一步我们需要，在进入聊天室时，将数据库中的数据赋给state firebase检索数据(写在onMounted钩子函数中) 123456789101112131415onMounted(() =&gt; &#123; const messagesRef = db.database().ref(&quot;messages&quot;); //选择数据库 messagesRef.on(&#x27;value&#x27;, snapshot =&gt; &#123; //on 用于firebase数据库检索数据 const data = snapshot.val(); let messages = []; Object.keys(data).forEach(key =&gt; &#123; messages.push(&#123; id: key, username: data[key].username, content: data[key].content &#125;); &#125;); state.messages = messages; &#125;);&#125;); 其中，data是我们从数据库中查询到的所有数据。 如果我们试着打印以下内容，你会发现： 因为，Firebase中存储的信息都是JSON对象，那么，我们就要用相应的方法来遍历每个对象，并将所有对象存储在messages中 最后将messages的内容，赋给我们的state 好让我们的v-for循环遍历数据可以生效！ 并且值得注意的是，每次有新的内容添加至数据库时（即每次发送消息时） 这个messagesRef.on(&#39;value&#39;, ...) 都会被调用一次，我们可以看成是事件监听（每当有新的数据时，会被调用！) 文末总结P.S. 该文所有的代码以及教程均来自YT博主（非自己原创）只不过自己以文字思路的形式写成笔记而已 点我查看源码地址 点我查看视频教学 如果哪里有写的不对的地方，多多包涵，请于文章下方的评论区告知，谢谢！","categories":[{"name":"前端项目","slug":"前端项目","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"前端项目","slug":"前端项目","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"}],"author":"vincent"},{"title":"VUE2.0学习笔记-基础语法及其应用-2-深入组件开发","slug":"VUE学习笔记-基础语法及相应应用-2","date":"2021-04-27T12:05:49.000Z","updated":"2021-11-09T07:53:30.212Z","comments":true,"path":"VUE学习笔记-基础语法及相应应用-2/","link":"","permalink":"https://github.com/Vincent990413/blog/VUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%BA%94%E7%94%A8-2/","excerpt":"","text":"（转）本文笔记&amp;源码地址_JS胖 了解组件，什么是组件概念？ 从图中我们可以看到，总共的大区域分为了三个板块 上面一个Header，下面左边一个LeftSide以及右边的RightSide 根据每个区域，又可以分为两个（最下层的绿色中间）、以及三个（最下层的绿色右边） 组件定义：所谓组件，我们就可以看成是：一个页面中的某一个Section，通过不同的组件共同拼凑 从而，形成一个完整的组件，这也是目前前端最流行的开发方式： vue_component.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; const app=Vue.createApp(&#123; &#125;) const vm=app.mount(&quot;#app&quot;)&lt;/script&gt; 我们可以看到，现在我们将一个新的VUE实例挂载到页面ID为app的区域 定义全局组件并使用现在我们的app可以注册全局的组件，注册好后可以直接在根组件上进行使用 比如我们要显示两个信息（紧接着上方的基本代码） 这是我的网站 https://www.vincent990413.gitee.io/myblog 12345678910//第一个全局组件app.component(&#x27;my-component-describe&#x27;,&#123; template:` &lt;h1&gt; 这是我的网站 &lt;/h1&gt; `&#125;)//第二个全局组件app.component(&#x27;my-component-website&#x27;,&#123; template:` &lt;h1&gt; https://www.vincent990413.gitee.io/myblog &lt;/h1&gt;`&#125;) 以上就完成了对组件的定义，接下来我们要做的就是使用这些组件 1234567//在创建实例的同时 使用自己的组件const app = Vue.createApp(&#123; template:` &lt;my-component-describe /&gt; &lt;my-component-website /&gt; `&#125;) 可以将这些步骤想象成 “初始化数据” 初始化数据之后 -&gt; 最后一步才是挂载在网页中 全局组件的可复用性什么叫可复用性，就是可重用性，我们将一个组件封装好之后， 可以在网页中的各个区域去重复引用这个组件 全局组件的弊端？！全局组件是有弊端的，因为你处处都可以使用，但是性能不高，应用打开就开始复杂的初始化 局部组件针对与局部组件：我现在不注册，我要用的时候才注册这个组件，才进行使用 而全局组件是，我不用之前一直都被注册了，一直都存在在那里！ 我们可以把局部组件，想象成，一个变量！我定义这个变量，我用的时候再注册它。 创建局部组件12345678const myComponentCounter = &#123; data()&#123; return&#123; count: 0 &#125; &#125;, template:` &lt;div&gt; &#123;&#123;count&#125;&#125; &lt;button @click=&quot; count++ &quot;&gt;增加1&lt;/button&gt; &lt;/div&gt; `&#125; 通过这种定义“变量”的方式，我们就已经定义好一个组件了，接下来我们需要在vue.CreateApp()方法里去注册 直接用component: { myComponentCounter }, 声明即可 1234567const app = Vue.CreateApp(&#123; components: &#123;&#x27;my-component-counter&#x27;:myComponentCounter&#125;, //声明我的组件 前面的别名可以去掉 template: ` &lt;h1&gt;这是我的网站&lt;/h1&gt; &lt;my-component-counter/&gt; ` //在父组件中的任何位置 都可以调用已经注册了的组件&#125;) 我们的局部组件一般使用驼峰命名法 但多个单词，我们应该遵守规范， 1. const变量用驼峰myComponentCounter 2. 起别名时 单引号且中间加- 小写每个字母: my-component-counter (具体见上方代码) 父组件与子组件以及他们之间的静态、动态传值什么是父组件，什么是子组件？我们在父组件中，定义子组件并使用子组件 被注册，被使用的那个组件叫做：子组件 使用 “定义好的组件” 的组件叫做父组件 定义全局组件Son 并在父组件中使用123456789101112131415app.component(&#x27;Son&#x27;,&#123; template: ` &lt;div&gt; 这是子组件 Son div &lt;/div&gt; `&#125;)const app = Vue.CreateApp(&#123; template: ` &lt;h1&gt;下面调用子组件&lt;/h1&gt; &lt;Son /&gt; ` // 调用Son 子组件&#125;)const vm=app.mount(&quot;#app&quot;) 父组件的参数传给子组件（静态传值）所谓父组件向子组件传值，就是在调用子组件的时候，静态绑定props参数 123456789//父组件传入name参数 那么子组件就要有一个name处于prop数组中&lt;Son name = &quot;vincent&quot;/&gt;app.component(&#x27;Son&#x27;,&#123; prop:[&#x27;name&#x27;] template: ` &lt;div&gt; 这是子组件，父组件传过来的参数name值为：&#123;&#123;name&#125;&#125; &lt;/div&gt; `&#125;) 这种方法是静态传输，一旦运行起来，就无法改变了 父组件的参数传给子组件（动态传值）一般我们利用：将父组件中data中的参数与传入子组件的参数进行绑定 从而使得传入的值，是动态的，是可变的 12345678910111213141516171819const app = Vue.CreateApp(&#123; data()&#123; return&#123; name: &#x27;Beatrix&#x27; &#125; &#125;, template: ` &lt;h1&gt;下面调用子组件&lt;/h1&gt; &lt;Son :name=&quot;name&quot; /&gt; ` // 此时是动态传入给子组件的参数 &#125;)app.component(&#x27;Son&#x27;,&#123; prop:[&#x27;name&#x27;] template: ` &lt;div&gt; 这是子组件，父组件传过来的参数name值为：&#123;&#123;name&#125;&#125; &lt;/div&gt; `&#125;) 这样通过修改data中的参数 完成动态绑定 父组件的参数传给子组件（传入函数参数）12345678910111213141516171819202122232425262728293031323334//父组件const app=Vue.createApp(&#123; data()&#123; return&#123; name: &#x27;Beatrix&#x27; &#125; &#125;, methods:&#123; talk()&#123; return &quot;你好，我是Vincent.&quot; &#125; &#125;, template:` &lt;h1&gt;下面调用子组件并传入函数参数talk&lt;/h1&gt; &lt;Son :talk = &quot;talk&quot; /&gt; `&#125;)//子组件app.component(&#x27;Son&#x27;, &#123; props:[&#x27;talk&#x27;], methods:&#123; buttonTalk()&#123; //弹窗显示 父组件传来的函数参数 alert(this.talk()) &#125; &#125;, template:` &lt;div&gt; 这是子组件Beatrix，我想知道你是谁？&lt;/div&gt; &lt;div&gt; &lt;button @click=&quot;buttonTalk&quot;&gt;点我就知道了&lt;/button&gt; &lt;/div&gt; `&#125;)const vm=app.mount(&quot;#app&quot;) 父组件的参数传给子组件（Slot插槽）这种情况适用于，父组件传入给子组件一段HTML代码，欲在部分区域显示： 在子组件想要显示的区域，声明插槽 在父组件使用子组件的双标签形式，并插入HTML代码/其他子组件 &lt;Son&gt; &lt;div&gt; &#123;&#123;counter&#125;&#125;: &lt;my-component-others /&gt;&lt;/div&gt; &lt;/Son&gt; 12345678910111213141516171819202122232425262728const app = Vue.createApp(&#123; data()&#123; return&#123; counter:1 &#125; &#125;, template:` &lt;h1&gt;父组件调用子组件并传入HTML代码/其他组件&lt;/h1&gt; &lt;Son&gt; &lt;div style=&quot;background-color:red;&quot;&gt; &#123;&#123; counter &#125;&#125;&lt;/div&gt; &lt;/Son&gt; `&#125;)app.component(&#x27;Son&#x27;, &#123; data()&#123; return&#123; &#125; &#125;, methods:&#123; &#125;, template:` &lt;h1&gt;子组件的标题&lt;/h1&gt; &lt;slot&gt;&lt;/slot&gt; `&#125;)const vm = app.mount(&quot;#app&quot;) 值得注意的是，当父组件与子组件具有同名的变量时，我们父组件传入参数时，子组件的slot中会显示父组件的属性。 父模板里调用的数据属性，使用的都是父模板里的数据。 子模板里调用的数据属性，使用的都是子模板里的数据。 &#123;&#123;counter&#125;&#125; 是在父模板中调用的，那么使用的是父模板的数据。 slot中的默认数据当slot中无数据传递过来是，写在slot中的数据就是默认显示数据。 1&lt;slot&gt; 这是默认数据 &lt;/slot&gt; 指定若干个插槽的位置(指定不同的name)1234567app.component(&#x27;Son&#x27;,&#123; template:` &lt;slot name=&quot;first&quot;&gt;&lt;/slot&gt; &lt;div&gt;这是第二个&lt;/div&gt; &lt;slot name=&quot;third&quot;&gt;&lt;/slot&gt; `&#125;) 我们可以看到，指定了name显示区域，在父组件传值的时候，也指定显示在对应name的区域即可。 12345678910111213141516const app = Vue.createApp(&#123; data()&#123; return&#123; &#125; &#125;, methods:&#123; &#125;, template:` &lt;Son&gt; &lt;template v-slot:first&gt; &lt;div&gt;这是First的参数值&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:third&gt; &lt;div&gt;这是third的参数值&lt;/div&gt; &lt;/template&gt; &lt;/Son&gt; `&#125;) 在代码中，我们可以看到，利用 v-slot:XX 可以指定显示在对应子组件name为XX的区域 也可以简写成 #XX 子组件子组件向父组件传递数据 子组件调用父组件事件 子组件向父组件事件中传递参数 子组件传递参数时，如何通过emits进行校验 根据组件之间的单向数据流，子组件是没办法直接更改父组件传递过来的参数 解决办法 1. 将父组件传递过来的参数赋给子组件的数据 在子组件中更改自己的数据（本段稍后一点内容） 2. 我们可以调用父组件的 “可以改变这个参数值” 的方法，本质上是父组件来改变（紧接着读下去） 比如：我们用父组件更改传递给子组件的counter变量（用一个方法） 在子组件中调用这个方法 仔细看懂，接下来的代码！ 仔细看懂，接下来的代码！ 仔细看懂，接下来的代码！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445//父组件const app=Vue.createApp(&#123; data()&#123; return&#123; counter: 1 &#125; &#125;, methods:&#123; parentUpdateCounter()&#123; this.counter++; &#125; &#125;, template:` &lt;h1&gt;下面调用子组件传入参数counter&lt;/h1&gt; &lt;h1&gt;子组件通过父组件的方法，更改这个传递过去的参数（注意区分直接赋给子组件中的data参数）&lt;/h1&gt; &lt;Son :counter=&quot;counter&quot; @parentUpdateCounter=&quot;parentUpdateCounter&quot; /&gt; `&#125;)//子组件app.component(&#x27;Son&#x27;, &#123; props: [&#x27;counter&#x27;], emits:[&#x27;parentUpdateCounter&#x27;], data()&#123; return&#123; &#125; &#125;, methods:&#123; childUpdate()&#123; this.$emit(&#x27;parentUpdateCounter&#x27;) &#125; &#125;, template:` &lt;div&gt; 这是子组件，我想看到数据变化！&lt;/div&gt; &lt;div&gt; &#123;&#123; childCounter &#125;&#125; &#123;&#123; counter &#125;&#125; &lt;button @click=&quot; childUpdate &quot;&gt;点我就知道了&lt;/button&gt; &lt;/div&gt; ` //可以看到 上面是&#123;&#123; counter &#125;&#125; 直接引用父组件传过去的参数&#125;)const vm=app.mount(&quot;#app&quot;) 关键代码：1. 首先在父组件中定义传递过去的变量counter data()&#123;return&#123; counter:1 &#125;&#125; 2. 父组件传递过去 &lt;Son :counter=&quot;counter&quot; /&gt; 3. 子组件中声明props用来接收 props:[ &#39;counter&#39; ] 4. 父组件中写可以更改counter变量的方法 methods:&#123;parentUpdateCounter()&#123;this.counter++&#125;&#125; 5. 父组件传递过去 &lt;Son :counter=&quot;counter&quot; @parentUpdateCounter=&quot;parentUpdateCounter&quot;/&gt; (@引用名=“父组件方法名”) 6. 子组件中声明emits用来接收 emits:[&#39;parentUpdateCounter&#39;](与父组件传递过来的引用名一致) 7. 子组件在需要的时候(一般在子组件自己的方法内部)，调用这个父组件的引用名（代表对应的父组件方法）this.$emit(&#39;parentUpdateCounter&#39;) 子组件利用slot向父组件传递List中的数据在Javascript中的list中，我们视为对象，因此调用属性是需要 obj.item 为子组件中添加list数据123456789101112app.component(&#x27;Son&#x27;,&#123; data()&#123; return&#123; names: [&#x27;Vincent&#x27;, &#x27;Beatrix&#x27;, &#x27;James&#x27;] &#125; &#125;, template:` &lt;div&gt; &lt;slot v-for=&quot;name in names&quot; :item=&quot;name&quot;&gt; &lt;/slot&gt; &lt;/div&gt; `&#125;) 最重要的就是我们为这个插槽，绑定了item属性，这样父组件可以调用到这个属性。 父组件调用这个子组件，并得到绑定的item值123456789101112const app=Vue.createApp(&#123; data()&#123; return&#123; &#125; &#125;, template:` &lt;Son v-slot=&quot;props&quot;&gt; &lt;div&gt; &#123;&#123; props.item &#125;&#125; &lt;/div&gt; &lt;/Son&gt; `&#125;) props可以任意取名字，但是一定是要绑定item这个属性 校验器（引入 ElementUI）点我，见图书管理系统的前端项目地址 组件之间的单向数据流一句话说明，就是数据从父级组件传递给子组件，只能这样单向（从父到子）绑定 子组件内部不能直接修改从父组件传递过来的数据 比如我们在父组件中定义一个计数器counter，传给子组件后，在子组件中更改这个数据 结论是，我们没办法看到这个数据的变化。 既然我们没办法，直接改变父组件传过来的变量，不如我们只更改子组件data中的变量 但将这个子组件data中的变量 赋值为父组件传过来的变量 123456789101112131415161718192021222324252627282930313233比如父组件传过来的变量为counter//父组件const app=Vue.createApp(&#123; data()&#123; return&#123; counter: 1 &#125; &#125;, methods:&#123; &#125;, template:` &lt;h1&gt;下面调用子组件并静态传入函数参数talk&lt;/h1&gt; &lt;Son :counter = &quot;counter&quot; /&gt; `&#125;)//子组件中app.component(&#x27;myComponentCounter&#x27;,&#123; props: [&#x27;counter&#x27;], data()&#123; return&#123; //关键一步，我们赋给可以改变的childCounter childCounter: this.counter &#125; &#125;, template:` &#123;&#123; childCounter &#125;&#125; &lt;button @click=&quot; childCounter++ &quot;&gt; 点我可以看到数据的变化 &lt;/button&gt; `&#125;) 这样我们就可以看到数据的变化了！ 思考，为什么要有单向数据流的概念呢？ 因为，如果父组件使用多个相同的子组件，传入不同的参数，我们希望这些子组件互不干扰。 也就是说，子组件不能直接更改父组件的数据，而是更改自己的数据。 异步组件和Promise讲解异步的概念所谓异步，就是几个操作不是按严格的顺序执行（真正的执行顺序未知） 与它相反的概念是同步： 举个例子，如何将大象塞到冰箱里？ 打开冰箱 将大象塞进去 关掉冰箱门 以上的操作就是同步的，具有严格的前后时序。 一般而言，我们将经常要去后台请求数据的业务/组件，封装成异步的。 Promise123456789app.component(&#x27;async-component&#x27;,Vue.defineAsyncComponent(()=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(&#123; template:`&lt;div&gt;这是一个异步组件&lt;/div&gt;` &#125;) &#125;,3000) &#125;)&#125;)) 我们在调用这个组件时，三秒钟后，会出现对应组件中的内容 关于Promise的概念，详情点我去JavaSCript基础教程 爷孙级别组件数据传递（多用于多级组件）顺序依次继承数据如果有一个爷爷，他现在有一套房子（北京四合院），想过继下去。 我们就可以实现： 从爷爷过继给父亲，再从父亲过继给孙子 props参数1234567891011121314151617181920212223242526272829const app=Vue.createApp(&#123; data()&#123; return&#123; house: &#x27;北京四合院，价值8000万！&#x27; &#125; &#125;, template:` &lt;h1&gt; 这是爷爷，爷爷过继给儿子！ &lt;/h1&gt; &lt;Son :house=&quot;house&quot; /&gt; `&#125;)app.component(&#x27;Son&#x27;,&#123; props:[&#x27;house&#x27;], template:` &lt;h2&gt;儿子接受房子，这个房子是： &#123;&#123; house &#125;&#125; &lt;h2&gt; &lt;h2&gt;儿子继续过继给孙子&lt;/h2&gt; &lt;Grandson :house=&quot;house&quot; /&gt; `&#125;)app.component(&#x27;Grandson&#x27;,&#123; props:[&#x27;house&#x27;], template:` &lt;h3&gt;这是孙子，接受房子，房子信息是： &#123;&#123;house&#125;&#125; &lt;/h3&gt; `&#125;)const vm=app.mount(&quot;#app&quot;) 这样通过依次继承的方法，的确可以做到将“爷爷”级别的组件数据传递给“孙子”组件 但如果项目中出现5，6次继承层次的孙孙孙...这样代码就太冗余了 指定组件层次接受参数 Provide&amp;InjectProvide意为提供参数，Inject引入接受、注入参数 也就是说，我们在“祖先”级别的组件提供某个参数，可以跳过中间的若干个组件，直接过继给指定的组件 1234567891011121314151617181920212223242526272829303132const app=Vue.createApp(&#123; data()&#123; return&#123; house: &#x27;北京四合院，价值8000万！&#x27; &#125; &#125;, provide:&#123; houseDirectlyToGrandson: &#x27;给孙子的海景房！&#x27; &#125;, template:` &lt;h1&gt; 这是爷爷，爷爷不过继给儿子，直接给孙子！ &lt;/h1&gt; &lt;Son/&gt; `&#125;)app.component(&#x27;Son&#x27;,&#123; props:[&#x27;house&#x27;], template:` &lt;h2&gt;这是儿子，不接受参数，不传递参数！&lt;/h2&gt; &lt;Grandson/&gt; `&#125;)app.component(&#x27;Grandson&#x27;,&#123; props:[&#x27;house&#x27;], inject:[&#x27;houseDirectlyToGrandson&#x27;], template:` &lt;h3&gt;这是孙子，接受房子，房子信息是： &#123;&#123;houseDirectlyToGrandson&#125;&#125; &lt;/h3&gt; `&#125;)const vm=app.mount(&quot;#app&quot;) 关键代码： 在爷爷组件中，提供属性 provide:&#123; newHounse:&#39;新房子&#39; &#125; 在任意后代组件中，提供注入参数：inject:[&#39;newHouse&#39;] 即可引用 如果这种层级关系达到5-6级，再使用props进行传递，那就会非常麻烦，而且会有大量的代码冗余。 使用provide和inject可以解决这个问题。","categories":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"Java反射机制-学习笔记","slug":"Java反射机制-学习笔记","date":"2021-04-15T06:02:09.000Z","updated":"2021-11-09T07:53:30.191Z","comments":true,"path":"Java反射机制-学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< Java中的反射机制-笔记反射原理的介绍(能利用反射做什么) 获得类的信息 Class 获得类中的属性信息 Field 获得类中的方法信息 Method 获得类中的修饰符 Classifier 获得类中的构造方法 Constructor 获得该类所继承的父类 SuperClass 所实现的接口 Interface 测试类 User.java(含属性以及Setter、Getter方法) 利用反射获取该User类 获取User类中的方法以及属性 获取User类所继承的父类（默认为Object）以及实现的接口","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"vincent"},{"title":"Java集合框架-基础学习","slug":"Java集合框架-基础学习","date":"2021-04-14T03:21:42.000Z","updated":"2021-11-09T07:53:30.202Z","comments":true,"path":"Java集合框架-基础学习/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Collecion 集合框架ArrayList(动态数组-顺序表）ArrayList是一个可动态修改数据、删除数据的数组 没有固定的大小限制（可以看做是Vector的定义） （附）Java集合中各个容器的关系 添加数据、删除数据等操作 迭代方法以及其他常见方法更多见： 菜鸟教程集合框架... LinkedList(链表） HashMap(基于键值对Key-Value的哈希映射） HashSet(基于HashMap的不重复元素的集合）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"vincent"},{"title":"SpringRedis_存储Map中的KV与读取","slug":"Java技巧-Redis存储","date":"2021-04-10T11:30:51.000Z","updated":"2021-11-09T07:53:30.193Z","comments":true,"path":"Java技巧-Redis存储/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-Redis%E5%AD%98%E5%82%A8/","excerpt":"","text":"依赖注入1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 application.yml123spring: redis: port:6379 实例代码（存储同一个map下的-&gt;key:value值）Controller层注入StringRedisTemplate关于Redis在SpringBoot中，有两个 第一个是RedisTemplate 第二个是StringRedisTemplate 如果想以字符串的形式存储，选择StringRedisTemplate即可。 存值 123456@Autowiredprivate StringRedisTemplate stringRedisTemplate;//存值：stringRedisTemplate.opsForHash().put(&quot;student&quot;, &quot;name1&quot;, &quot;vincent&quot;);stringRedisTemplate.opsForHash().put(&quot;student&quot;, &quot;name2&quot;, &quot;Jack&quot;); 取值 12//结果是vincentString redisCode = (String) stringRedisTemplate.opsForHash().get(&quot;student&quot;, name1); 通过Redis-cli查看首先打开redis-serve.exe打开redis-cli.exe12//hget map key 返回valuehget student name1 1hset student name1 1hdel student name1","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"PageHelper根据页数数据分页显示","slug":"Java技巧-SpringBoot-PageHelper根据页数数据分页显示","date":"2021-04-10T11:15:28.000Z","updated":"2021-11-09T07:53:30.194Z","comments":true,"path":"Java技巧-SpringBoot-PageHelper根据页数数据分页显示/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-SpringBoot-PageHelper%E6%A0%B9%E6%8D%AE%E9%A1%B5%E6%95%B0%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E6%98%BE%E7%A4%BA/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< 引入依赖123456&lt;!-- pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; 配置文件12345pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 实例代码123456//startNum=1, pageSize=5//页数为第一页 每页大小为5PageHelper.startPage(startNum, pageSize);List&lt;Book&gt; list = bookService.findAllBooks();PageInfo pageInfo = new PageInfo(list, pageSize);return new ApiResponse(200, &quot;请求成功&quot;, pageInfo); 微服务下的PageHelper注意事项 注意，PageHelper只在本次上下文中查询有用。因此，A服务在调用B服务时，需要传入至少pageNumber与pageSize。而分页等复杂逻辑，需要放在B服务中，因为B服务进行查询。 只需要返回PageInfo对象即可，这个对象就包含了经过复杂逻辑处理后的所有page信息。","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"政治上60分就够了？不是吧，你一定要看看","slug":"不会吧考研政治","date":"2021-04-09T11:08:30.000Z","updated":"2021-11-09T07:53:30.213Z","comments":true,"path":"不会吧考研政治/","link":"","permalink":"https://github.com/Vincent990413/blog/%E4%B8%8D%E4%BC%9A%E5%90%A7%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< 政治准备书籍或资料1. 徐涛老师的《核心考案》徐涛老师的核心考案就像是一本书的大纲一样，从马原的第一章到思修法基的最后一章。 该书都涵盖了该有的考点，当然最好是能够： 边看核心考案，边做笔记，老师会勾画重点 2.肖秀荣老师的《1000题》可以说，市面上的题目质量，最好的前几名，肖老师的《1000题》一定名列前茅。 可以选择一手听徐涛老师的强化课， 一手做肖老师的1000题 当然最好是能反复！！ 我的方法就是：第一遍用铅笔做，答案都写在题目的左侧 然后第二遍可以，用中性笔做，记得标出经常错的题目 3. 腿姐的技巧班腿姐的技巧班可以说，真的是实战。 不玩虚的，就是教你如何从历年真题出发，到底如何高效地做题 如果有条件，一定听一下腿姐的相关配套课程！ 4. 肖老师的《肖四》《肖八》针对于去年考研，我想说： 我绝对会给这两本书五颗星 ☆☆☆☆☆ 原因不详细阐述，我多次在公开场合提到，你一定要备这两本书！ 5.注意关注徐涛老师的微博、徐涛老师的微信公众号时间安排7月份~开始复习基本上你会看到，大部分同学都是在这个时间点开始复习。 我是在七月份开始复习政治与专业课 政治每天安排： 傍晚：1~2节徐涛老师的视频课 然后做一做肖老师的《1000题》 9月份-技巧阶段在这个时候 基本上 你应该完成考研政治的大部分内容了 这个时候，其实是比较建议听腿姐老师的《核心技巧班》 因为还是那句话，我们最终是要上考场做题的 所以，技巧班能从题目本身教我们如何做题？ 避免以自己的思维来做题 12月份 “背多分” 协奏曲！可以说，政治考得好不好。就看最后这些时间 我强烈建议 要多看肖秀荣老师的《肖四》 《肖八》 当然如果能够买一本徐涛老师的“小黄书”《背诵笔记》，辅佐以素材是更好的了","categories":[{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"}],"tags":[{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"}],"author":"vincent"},{"title":"2021年计算机重庆邮电大学研究生入学考试经验","slug":"2021年计算机重庆邮电大学研究生入学考试经验","date":"2021-04-09T09:17:34.000Z","updated":"2021-11-09T07:57:24.700Z","comments":true,"path":"2021年计算机重庆邮电大学研究生入学考试经验/","link":"","permalink":"https://github.com/Vincent990413/blog/2021%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%BA%86%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A6%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"前言 Preface一年一度的全国研究生入学考试终于落下帷幕。今天是2021-04-09，距离2121届研究生入学考试已经过去了几个月的时间。 现在终于能够静下心来，好好分析自己走过的旅程。以及总结踩过的雷区，错误的学习方法以及可以分享给大家的好方法， 当然百密难逃一疏，恳请理解。 感谢信 Acknowledgement在我写这篇文章的时候，首先感谢在考研过程中给我提供帮助的小哥哥、小姐姐。 首先感谢我的本科学校：攀枝花学院 真的是所很棒的学校 我在这里遇到了很多优秀的人！感谢你PANDA 感谢我在考研前期准备阶段给我提供资料、一直给我打气的权哥、涛兄（什么时候开博客啊？我给您们开友链呢！） 感谢提供给我关于专业知识的2016级直系高学长，谢谢你 感谢在复试过程中给予我帮助，曾面试我给我宝贵面试经验的莲莲学姐（抱歉我不知道您的真名） 感谢我们的301寝室的小哥哥、尤其感谢一起备考的李总（李总博客会放在友链里面，咱们得支棱起来！） 感谢外语院的摄影师秋水（一定前程似锦） ☆☆☆ 特别感谢： 直系学姐-小七，非常，非常，非常感谢在我初试、复试过程中的无私帮助！简直就是我的贵人，大佬受小弟一拜。 有想学舞蹈的小姐姐可以找她，专业的！ 需要任何帮助可以加我的微信噢，我会及时回复： Without further ado 废话少说还是直接进入正题。 ：）老规矩，介绍自己参加考研的基本情况。 报考院校：重庆邮电大学（忍不住Bold字体，真的是好学校） 专业/类型：电子信息（专业型硕士学位） 考研分数情况 Info##（初试分数：复试分数=6：4） 12345678910☆ 初试：（总分357分） 1. 政治： 71分 2. 英语： 79分 3. 数学： 116分 4. 专业课： 91分（计算机网络）☆ 复试： 1.英语口语、听力：18.8分（总分20分） 2.笔试分数：92分（总分100分） 3.综合面试：90分（总分100分） 初试过程 Process1.考研择校择校成功 = 考研成功1/4我想特别说明关于你的target university目标院校的重要性！ 首先你可以通过你的目标院校研究生院获得相关信息 比如重庆邮电大学为例： 点我进入重庆邮电大学官网研究生院 那么看什么？ 123456首先看报考的目标专业招多少人？初试科目考哪些？考英语一还是英语二？专业课考408还是只考其中部分科目？以及对应的科目参考书籍。 注意：有可能你想报考的专业分布于不同学院：比如软件学院、XX学院、然后不同学院招收的人数不同。 这里我给出地址（方便各位下载）： 2021年计算机科学与技术学院/重邮科大讯飞人工智能学院硕士研究生招生报考指南： 网址里面有： 学院的招生专业信息 初试参考书目 初复试考试大纲 最新的初试专业课真题！ 如图所示： 看完相应的科目，要顺便看看：学术型硕士与专业型硕士参考科目的不同。 以重庆邮电大学为例（注意，这里的专业课不同的学校可能是不同的，而且考的门数也不同，要仔细看看） 12345678910* 专业型硕士： 1. 数学二（高等数学+线性代数） 2. 英语二 3. 政治 4. 计算机网络* 学术型硕士： 1. 数学一（高等数学+线性代数+概率论） 2. 英语一 3. 政治 4. 数据结构 直接上图： 上图是学术型硕士的基本招收信息 下图是专业型硕士的基本招收信息 具体看你所报考的院校基本信息！ 那么，以上就是真正地准备初试所需要的基本信息收集 2. 各科目准备过程数学（初试中的爸爸ROLE）本人基本情况，高考数学没及格。大学数学也学得不好。根据自己严格的做题方法和做题步骤，最终能够拿到这个成绩，真的很不容易。Trust Me，考研数学，其实没有想象中的那么难。 数学整体题目分布（转自新东方网）： 数学一： 数学二 数学三 针对数学二部分的备考经验、以及各个Section的备考方法。同在我个人博客网站中，链接如下： 考研数学到底怎么样才能上一百分？我来告诉你... 让人头疼的英语考研英语分为英语二与英语一，本人基本情况是，大一通过四六级。 回归考研英语本身： 题目分布： 1234561. 完形填空20个（每个0.5分）共10分2. 经典阅读理解题，四篇20个，每个2分，共40分3. 新题型（段落匹配、连线等）10分4. 英译汉（15分）5. 作文一：书信10分6. 作文二：图表15分 英语一不同的地方在于，书信是一样的，但是图表作文换成了图画作文。 同时英语二的翻译是，翻译整篇短文 英语一的翻译是：挑选一篇文章中的五句话，要求结合上下文进行翻译 针对英语部分的备考经验以及各个Section的备考方法。同在我个人博客网站中，链接如下： 不会吧？都2021年了，还有人觉得考研英语简单！？ “价值连城”的政治！政治是很重要的科目，同时政治也是比较容易速成的科目！ 总体而言，考研政治分为几大板块： 12341. 第一部分 马克思主义基本原理概论（马原）2. 第二部分 毛泽东思想和中国特色社会主义理论体系概论（毛中特3. 第三部分 中国近现代史纲要（近现代史）4. 第四部分 思想道德修养与法律基础（思修法基 其中，马原占到试卷的24%， 毛中特占到试卷的30%， 近现代史占到14% 最后思修法基占到16% 总共38道题，1~16题是单项选择题， 17~33题是多选题（多选题是爸爸，分值高分值低都看多选题！！！） 最后的34~38题是分析题（分析题也可以挽救你，只要你字写得好看，答题1、2、3地按序，按重点答） 针对政治部分的备考经验以及各个Section的备考方法。同在我个人博客网站中，链接如下： 政治上60分就够了？不是吧，你一定要看看 备受“争议”的专业课专业课满分150分，各个院校的专业课组成部分不同。 譬如有的考两三门，有的考一门，有的考四门： 但大致上，针对计算机专业的大部分院校，都由以下几门专业课组成： 1234567数据结构 严蔚敏著计算机网络 谢希仁著操作系统 汤子瀛著计算机组成原理 唐朔飞著 我备考的时候专硕只考一门课：计算机网络 参考书目是：谢希仁著的，《计算机网络》（第七版） 总体来说，这门课考得有点不好，91分。 这是我没有想到的，但是我想肯定是自己在答题方面，没有发挥好。 OR 就是自己太菜了！ 部分知识理解 就不跟大家分享了~ 那么主要是还是要从备考本身 分享一些好的学习 渠道吧 ☆ 王道还是天勤？了解计算机考研的都应该知道这两个机构。 其实我想说，不管是王道的计算机网络讲义还是天勤的高分笔记 都是大牛编者编写的，只不过在个人使用方面， 我比较推荐都看哈哈哈哈！ ☆ 思维导图有多重要？重要的事情说三遍：很重要，很重要，很重要！ 对于计算机网络这门课程，一定要有思维导图， 当然如果你购买了王道、天勤的课程或者他们的书籍 一定是会有相应的思维导图的！ 对于这门课程，我想整体一定要有清楚的认知。每章的重点在哪里？ ☆ 历年真题！！！Five Stars ☆☆☆☆☆针对目标院校的真题，一定要反复研读！ 很多题目，不说完全重复，但是非常相近！ 不是这个考点，就是这个考点的情况，非常多！！！务必引起大家的重视。 复试过程 Re-Examination富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。 我的建议：Recommendation1. 如果能有跟自己并肩作战的研友是最好不过的了！2. 一定要去图书馆！！！3. 重要的是效率！高效的6h &gt; 盲目的12h4. 学累了就放松 放松够了就继续冲！5. 考研不是终点 考上了也要付出多出常人的努力！（考不考得上 你都是王者 需要这种心态！）6. 遇到自己喜欢的另一半 就在一起吧 不要错过爱情~","categories":[{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"}],"tags":[{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"}],"author":"vincent"},{"title":"考研数学到底怎么样才能上一百分？我来告诉你...","slug":"不会吧考研数学","date":"2021-04-09T09:11:14.000Z","updated":"2021-11-09T07:53:30.214Z","comments":true,"path":"不会吧考研数学/","link":"","permalink":"https://github.com/Vincent990413/blog/%E4%B8%8D%E4%BC%9A%E5%90%A7%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< 接下来我将以： 12345n月份~6月份7月份~9月份以及最后考试前两个月的时间段来描述具体如何备考 6月份之前（基础阶段）：这个时间段，是铁定的基础阶段，当然这个基础阶段是要打上引号的！所谓的基础阶段，并不是单纯地看本科阶段所学科目的书！而是从-&gt;本科书-&gt;到名师基础班的过渡。 也就是说，这个阶段最重要的事情就是：打好基础！越牢越好，切忌好高骛远，埋头苦干。 我复习的时候，看的老师： 高等数学：汤家凤（基础阶段）线性代数：李永乐基础阶段我建议，先看高等数学、线性代数的书，入门知识过一遍。能够掌握做课后习题的方法即可！不要做太难的题。 再看完高等数学、线性代数的书后，可以开始进入真正的考研数学基础班了。 还是建议数学汤家凤基础阶段紧跟！ 值得一提的是，我非常建议 12345买汤家凤老师的《接力题集1800》汤家凤老师的高等数学讲义关注汤家凤老师的微信、微博（关注寒暑假等假期的的直播课程） 对的，必买！！！ 汤老师在课程中，会讲数学一、数学二、数学三的公共部分！ 对于数学科目的独属部分以及题集的部分讲解，会在公众号以直播的形式播出！ 给出自己基础阶段的复习方法： 高等数学跟汤家凤老师，线性代数跟李永乐老师即可。 ☆ 第一、看对应的汤老师视频课程，但不要看多了，建议是看数集视频（看自己的状态）然后立马投入到1800题集的题海中！ 过完一章后，最好是看看这一章学到了什么？可不可以以笔记的形式过一遍。 ☆ 第二、《接力题集1800》，一定要关注、标黑错题。错题是很有价值的，到底自己是错在哪里？ 详细看看答案，为什么汤老师要这么写？ 如果不知道，那么，看了答案后，下次是否能够同步汤老师的思维！ 看到该类型的题，就要想起： 1234567这个题是涵盖哪些章节的知识（真正的考题都是综合题）解该题的基本方法是什么？在计算的过程：字迹工整！！思路清晰（对，恨不得给出注释那种） 为数不多还遗留下来的笔记了！ 这个阶段不是很困难，但是一定要养成基本的解题素养！要知道常见的题型，以及常见的解法！ 长时间的 Deliberate Practice（刻意练习） 即可！重复重复再重复。 第三、线性代数我想特别说明： 由于线性代数的抽象性！导致我们看了老师的课程内容 != 我们会做对应的题目， 这个时候我们要反复地看书、经典的例题！！！ 重难点绝对是：向量，方程组以及特征值、特征方程~（大题就是这么来的） 7/8月份~9月份（强化阶段）：高等数学：汤老师的1800题集、武忠祥老师的系统强化课线性代数：李永乐老师的系统强化课这个阶段就是决定自己到底能不能在数学科目有所突破！有所成长的关键时候了。 对，这个阶段要做大量的题，高难度的题，综合的题 请注意！我这里说的难题，是指贴合考研数学考场难度的题目 这个阶段我推荐： 1234567汤老师的 《接力题集1800》强化篇 （除开基础篇即可）武忠祥老师的《高等数学辅导讲义》李永乐老师的《线性代数辅导讲义》武忠祥、李永乐老师（好像今年他们去到不同的机构）的330重点题 ☆ 强化班：听武忠祥老师的课程！！！ ☆ 强化班：听线性代数，李永乐老师的课程！！ 其他阶段的课程我不建议反复听，但是： 强化班的课程很有必要反复听！！！ 听课的同时，一定要加强自己计算的能力！速度，准确度！ 强化班不是基础班，是真正要上战场的预备课！练习的题目也都是大量高于考场的题目，不要畏难！ 这个阶段是绝对适合做高难度的题目的。 同时！基础阶段的标黑题目、多次错误题目也不能落下他们，因为很有可能是因为自己的哪一部分的基础不扎实！ 很有必要在这个阶段提一嘴！所谓的多种方法，其实在考场上是不适用的。 let&#39;s put it another way，也就是说你会什么方法，就用什么方法解题。熟悉自己的解题方法，熟练自己的解题方法即可。 10月份国庆~12月份（冲刺阶段）☆☆☆ 汤老师的套题☆☆☆☆ 李永乐老师团队的套题☆☆☆ 张宇老师的闭关修炼☆☆☆☆☆ 李林老师的套题在大量方法的灌输下，国庆节之后，我们可以开始做套题了！ ☆☆☆☆☆ 李林老师的四套卷、八套卷 ☆☆☆ 汤老师的卷子（不做参考，因为部分题源是1800题集上的题目） 其他的卷子没有做过..不予评价 请千万记住，不能按照自己做模块题目的思路去做题，一定要强迫自己在规定的时间2~2.5h内做完卷子！！ 请千万记住，做卷子的目的不是，所有的题目都要做出来！而是拿到对于这张卷子，自己能拿到的分数！ 否则，只会懊悔自己，为什么自己的分数不如自己所愿！ 就像我的好研友李总说的那样，你上岸又不是一定要数学150分！ 说的很好，每个人对数学的理解能力不同，要求自己做对能做对的题目（这点很重要） 对于实在不会或者算不出来的题目，字迹要工整、思路要清晰，是老师给你评分，不是你自己的思路给你自己评分！ 一定要老师知道，你每一步的意义。老师也是 按点给分，按步骤给分！ 同时，如果有条件。可以看看数学张宇老师的《闭关修炼》，为的是拓展自己的数学思维！ 注意！越是临近考试，越不能放弃考研数学的本质！刷题。结合强化阶段的题目以及做套题的错题 考研数学真题&gt;模拟套题 刷题最开始的阶段，请选择 x年到2010年，x为自己决定起点年份的卷子！ 对于近年的真题卷子，一定要珍惜不能浪费！ 建议整理真题、部分精彩的模拟题的错题！反复阅读。 那么，到了最后的冲刺阶段： 是一定要多看李林老师的《四套卷》、《六套卷》 By the way 直到考试前的早上！我还在看六套卷的选择题。结果你懂的 上考场的具体答题顺序建议：高等数学、线性代数的顺序做题方式。","categories":[{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"}],"tags":[{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"}],"author":"vincent"},{"title":"Ajax请求PostAndGet","slug":"Java技巧-Ajax请求PostAndGet","date":"2021-04-05T05:51:44.000Z","updated":"2021-11-09T07:53:30.192Z","comments":true,"path":"Java技巧-Ajax请求PostAndGet/","link":"","permalink":"https://github.com/Vincent990413/blog/Java%E6%8A%80%E5%B7%A7-Ajax%E8%AF%B7%E6%B1%82PostAndGet/","excerpt":"","text":"Ajax的Get与Post方法请注意，必须引入JQuery CDN代码如下： 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&quot;&gt;&lt;/script&gt; Get方法请注意GET方法一般用于从后台中获取数据，而不是提交数据 默认是GET方法，速度很快。但是由于数据将直接以localhost:8080?data1=111&amp;data2=222的形式 出现在浏览器的地址栏中， 因而Get方法一般不用于：敏感、隐私的数据传输 123456789101112131415161718var id = $(&quot;input[name=&#x27;editor&#x27;]&quot;).val() $.ajax(&#123; //后台的请求路径 一般在@Controller层中添加相关注解 //注解一：@RequestMapping(value=&quot;/show_paper&quot;)或者指定@GetMapping(value=&quot;/show_paper&quot;) url:&quot;show_paper&quot;, data:&#123;&quot;Id&quot;:, id&#125;, type:&quot;GET&quot;, //注解二：由于指定返回类型为JSON数据 //@ResponseBody dataType:&quot;JSON&quot;, success:function(result)&#123; //后台的回调函数中 result中可以找到 后台返回的JSON数据 console.log(result); &#125;, error:function () &#123; alert(&quot;抱歉，请求失败，请重新发出请求！&quot;) &#125;&#125;); 1. 在SpringBoot中，@RestController=@Controller+@ResponseBody2. 使用Get方式请求时，后台SpringMVC用@RequestParam(&quot;Id&quot;)来获取Post方法与Get方法不同的是，Post方法一般用于向服务器提交数据。而不是获取数据！ 因此，我们可以将需要隐私处理的数据以POST方式以服务器交互：比如账户密码，业务逻辑数据等等 1. 网页中没有form标签1234567891011121314151617var username = $(&quot;input[name=&#x27;username&#x27;]&quot;).val() var password = $(&quot;input[name=&#x27;password&#x27;]&quot;).val() $.ajax(&#123; //对应的Controller 指定登录 url:&quot;login&quot;, //字符串拼接的方式添加参数 后台可用MVC捕捉 或创建Bean对象 data:&#123;&quot;username&quot;:username , &quot;password&quot;:password&#125;, type:&quot;POST&quot;,//HTTP请求方式 dataType:&quot;JSON&quot;,//返回值的类型。 success:function(result)&#123; //请求事件成功的回调函数 console.log(&quot;JSON:&quot;+result); &#125;, error:function(data)&#123;//处理页面出错以后执行的函数 console.log(data); window.location.replace(&quot;./index.jsp&quot;); &#125; &#125;); 1. 后台函数参数中可以使用与前端同名的变量1public void fun(String username, String password) 2. 后台可以使用Bean对象 User类 其中属性与前端参数同名UserController.java 1public void fun(User user) User.java 1234567public class User&#123; private Integer id; private String username; pruvate String password; ...省略GET、SET方法&#125; 2.网页中有form标签（更便捷）关键代码 1data:$(&quot;#form&quot;).serialize(), 解释： 给网页中的form表单一个id=&quot;form&quot; 在进行AJAX请求时 找到这个表单 对这个表单中的数据进行序列化serialize() 注意：后台用对象User来接收，并且前端name中的值需要与Bean对象User中的private属性一一对应 12345678$.ajax(&#123; url:&quot;addUser&quot;, type:&quot;POST&quot;, data:$(&quot;#form&quot;).serialize(), success:function (result) &#123; showData(result); &#125; &#125;);","categories":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"author":"vincent"},{"title":"VUE2.0学习笔记-基础语法及其应用-3-SpringBoot+SpringJPA+Vue开发实战","slug":"VUE学习笔记-基础语法及相应应用-3","date":"2021-04-01T07:28:47.000Z","updated":"2021-11-09T07:53:30.213Z","comments":true,"path":"VUE学习笔记-基础语法及相应应用-3/","link":"","permalink":"https://github.com/Vincent990413/blog/VUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%BA%94%E7%94%A8-3/","excerpt":"","text":"原生VUE实战（查询数据）（含SpringBoot+Vue）1.创建VUE项目在命令行中输入 1vue ui 2.进入dashboard中 创建项目 3.进入VUE 工程管家创建工程 修改以下参数创建完之后就可以了。 4.从IDEA中导入项目编写前端代码打开IDEA-&gt;导入项目.... 安装Vue.js插件 修改JavaScript语言为ECMAScript 6 在控制台中输入npm run serve来启动项目 *******************（开发从这里开始）VUE前端项目的结构图项目结构图如图所示：通过结构图我们可以知道： App.vue 是网页的主界面，页面中包括许多组件 component 其中Home、About都是导航栏，但注意我们导航至Home与About并不代表像传统意义那样，我们去打开一个新的页面。而是说，我们在页面上加载不同来源的内容 具体含义，如图所示： 1234567&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt;&lt;/template&gt; 在上述代码中，我们可以看出router-link标签负责导航栏 to表示导航路径而具体的路径配置是交给项目结构中的router下的index.js来配置 index.js中的关键代码如图import代表从那个vue页面中导入相关组件 而在routes中具体配置相应的路径，名字，以及组件的名字 这里的path需要与前端页面vue中router-link中的to属性参数一一对应 name可以不填写，但最好与组件名一致 component代表组件 这里的component需要与import导入语句后面一致 而对于VUE3.0，我们建立导航可以用新的写法： import语句可以省略，除了写path与name参数之外，我们的component参数可以变成： 1component:()=&gt;import(&#x27;../views/About.vue) 创建SpringBoot项目添加以下依赖：1. Lombok2. Spring Web3. Spring Data JPA4. MySQL Driver 以上四个依赖 1.资源文件中添加数据库文件连接信息： 12345678910111213spring: datasource: url: jdbc:mysql://localhost:3306/vuetest?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 username: root password: 123456 jpa: show-sql: true properties: hibernate: format_sql:trueserver: port: 8181 连接数据库信息 JPA打印SQL 格式化SQL 端口8181 避免占用（vue的端口与后台的端口占用） 建立实体类User类（注意使用@Entity @Data注解 @Id放在主键属性上）值得注意的是，类中的每个属性，在首字母小写后-必须等于数据库表中的字段名 12345678910111213141516import lombok.Data;import javax.persistence.Entity;import javax.persistence.Id;@Entity@Datapublic class User &#123; //默认是类名首字母小写 与数据库中的表进行对应 @Id private Integer id; private String username; private String password; private String email;&#125; ApiResponse 后端前台通用-交互类1234567891011121314151617181920212223242526272829303132333435import lombok.Data;@Datapublic class ApiResponse&#123; private int code; private String message; private Object data; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125;&#125; 建立Repository层或称DAO层UserRepository类 extends JpaRepository&lt;User, Integer&gt;（其中User是对应的类 Integer是主键）利用这种方法，可以避免写一些比如1.查询一条数据2.查询全部数据3.根据主键查询数据...已经封装好了 常见的DAO层操作 12345678import com.example.demo.entity.User;import org.springframework.data.jpa.repository.JpaRepository;//继承已经封装好了的 JPA不用自己去写简单的 增删改查接口public interface UserRepositery extends JpaRepository&lt;User, Integer&gt; &#123;&#125; 建立RepositoryTest测试类 先看看能不能获得到数据库的数据！ 在类名上右键 Goto中选择test 命名UserRepositeryTest123456789101112131415import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass UserRepositeryTest &#123; @Autowired private UserRepositery userRepositery; @Test void findAll()&#123; System.out.println(userRepositery.findAll()); &#125;&#125; 点击函数名左边的运行！测试看控制台能否读取数据库数据。 建立Service层以及对应的Impl实现类值得注意的是 注解@Service应加在实现类上 UserService接口12345678import com.example.demo.entity.User;import org.springframework.stereotype.Service;import java.util.List;public interface UserService &#123; List&lt;User&gt; showAllTheUsers();&#125; UserServiceImpl实现类12345678910111213141516import com.example.demo.entity.User;import com.example.demo.repository.UserRepositery;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserRepositery userRepositery; @Override public List&lt;User&gt; showAllTheUsers() &#123; return userRepositery.findAll(); &#125;&#125; 建立Controller层UserController1234567891011121314151617181920212223242526import com.example.demo.entity.ApiResponse;import com.example.demo.entity.User;import com.example.demo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestController@RequestMapping(value = &quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/show&quot;) public ApiResponse showAll()&#123; ApiResponse apiResponse = new ApiResponse(); List&lt;User&gt; users = userService.showAllTheUsers(); apiResponse.setData(users); apiResponse.setMessage(&quot;返回成功！&quot;); return apiResponse; &#125;&#125; 值得注意的是：@RestController = @Controller + @ResponseBody后台从数据库中查询到的数据以XML或者JSON的格式，返回给前端。 解决端口跨域的问题由于我们修改了SPRINGBOOT的端口为8181 而VUE默认是8080因此，我们需要对SpringBoot做一个配置！ 新建config.CorsConfig类1234567891011121314151617181920212223242526import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.addAllowedOriginPattern(&quot;*&quot;); config.setAllowCredentials(true); // 允许服务端访问的客户端请求头 config.addAllowedHeader(&quot;*&quot;); // 允许访问的方法名,GET POST等 config.addAllowedMethod(&quot;*&quot;); // 对接口配置跨域设置 source.registerCorsConfiguration(&quot;/**&quot; , config); return new CorsFilter(source); &#125;&#125; 到此为止，后台的代码基本算是完成了！接下来开始编写 *******************(前端代码开始)User导航栏修改App.vue文件中的template标签为 12345678&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;| &lt;router-link to=&quot;/user&quot;&gt;User&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt;&lt;/template&gt; 同时在router文件夹中的index.js文件中 配置router导航映射（见文章前部分内容！） 第一种方式：适用于VUE2（显式声明） 12345678910111213141516171819import User from &#x27;../views/User.vue&#x27; //建立VUE页面与组件的映射const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: About &#125;, &#123; path: &#x27;/user&#x27;, name: &#x27;User&#x27;, component: User //从上方的import User中建立映射 &#125;] 第二种方式：建立隐式映射 12345678//注释掉上方的import User from &#x27;../views/User.vue&#x27; //但是下方变成：&#123; path: &#x27;/user&#x27;, name: &#x27;User&#x27;, component: ()=&gt;import(&#x27;../views/User.vue&#x27;) //边声明组件 边建立映射 &#125; 创建User.vue 具体显示内容在views文件夹下创建User.vue文件： Style CSS样式1234567891011121314&lt;style scoped&gt; table&#123; font-size:25px; &#125; table&#123; table-layout:fixed; empty-cells:show; border-collapse: collapse; margin:0 auto; &#125; td&#123; height:20px; &#125;&lt;/style&gt; JavaScript 利用axios与后台交互第一步、添加axios插件（并修改一些内容）首先，在命令行中输入 1vue add axios 然后找到项目结构图中的plugins文件夹下面的axios.js粘贴以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&quot;use strict&quot;;import Vue from &#x27;vue&#x27;;import axios from &quot;axios&quot;// Full config: https://github.com/axios/axios#request-config// axios.defaults.baseURL = process.env.baseURL || process.env.apiUrl || &#x27;&#x27;;// axios.defaults.headers.common[&#x27;Authorization&#x27;] = AUTH_TOKEN;// axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;;let config = &#123; // baseURL: process.env.baseURL || process.env.apiUrl || &quot;&quot; // timeout: 60 * 1000, // Timeout // withCredentials: true, // Check cross-site Access-Control&#125;;const _axios = axios.create(config);_axios.interceptors.request.use( function(config) &#123; // Do something before request is sent return config; &#125;, function(error) &#123; // Do something with request error return Promise.reject(error); &#125;);// Add a response interceptor_axios.interceptors.response.use( function(response) &#123; // Do something with response data return response; &#125;, function(error) &#123; // Do something with response error return Promise.reject(error); &#125;);export default _axios 第二步、引用axios并发起get请求1234567891011121314151617181920&lt;script&gt; import axios from &quot;../plugins/axios&quot;; //引用axios export default &#123; name: &quot;User&quot;, data()&#123; return&#123; // 具体的变量 msg: &#x27;Hello, Vue!&#x27;, users:[] &#125; &#125;, created()&#123; //当网页准备就绪时 const _data = this //利用这个this好使得在回调函数中 调用回调函数外的data中的数据 axios(&#x27;http://localhost:8181/user/show&#x27;).then(function (response) &#123; _data.users = response.data.data //将controller返回给后台的data 赋给data中的数组 &#125;) //跟ajax一样 直接请求8181端口下的请求路径 注意 已经配置了跨域！不用担心 &#125; &#125;&lt;/script&gt; 第三步、将数据显示在网页中template HTML内容1234567891011121314151617181920&lt;template&gt; &lt;!--template中写html代码 且只能有一个根div节点--&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;user of users&quot;&gt; &lt;!--利用for循环 加载data中users数组中数据--&gt; &lt;td &gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt; &lt;td &gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt; &lt;td &gt;&#123;&#123;user.password&#125;&#125;&lt;/td&gt; &lt;td &gt;&#123;&#123;user.email&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt; 到此为止。一个简单的查询数据库所有数据的请求就完成了 项目效果图如下：","categories":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"VUE2.0学习笔记-基础语法及相应应用-1-基本语法","slug":"VUE学习笔记-基础语法及相应应用-1","date":"2021-03-28T08:17:03.000Z","updated":"2021-11-09T07:53:30.212Z","comments":true,"path":"VUE学习笔记-基础语法及相应应用-1/","link":"","permalink":"https://github.com/Vincent990413/blog/VUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%BA%94%E7%94%A8-1/","excerpt":"","text":"Vue开头好戏-小案例Hello World123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.createApp(&#123; template: &#x27;&lt;div&gt;Hello World&lt;/div&gt;&#x27; &#125;).mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; 面向数据编程-&gt;实现计时器1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;计数器&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.createApp(&#123; data()&#123; return &#123; counter:1 &#125; &#125;, //需要一个mounted方法 自动执行 mounted()&#123; //页面渲染完 就自动执行 setInterval(()=&gt;&#123; this.$data.counter += 1 &#125;, 1000) //周期执行 &#125;, template: &#x27;&lt;div&gt;&#123;&#123;counter&#125;&#125;&lt;/div&gt;&#x27; //字面量 双括号 放JS表达式或者变量 &#125;).mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; mounted()表示当文档加载时 就执行该函数data(){}中存放类似 全局数据template:放入全局数据 取值绑定数据&amp;事件-&gt;编写方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;象牙山洗脚城&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.createApp(&#123; data()&#123; return &#123; content:&quot;&quot;, num:0, Menu:&#x27;真空套餐 帝王套餐 夏日套餐 学生套餐&#x27;, isShowMenu: false //标志不展示 &#125; &#125;, methods:&#123; welcomeBtnClick()&#123; this.content = &quot;欢迎光临, 贵宾&quot; + ++this.num + &quot;位&quot; &#125;, byeBtnClick()&#123; if(parseInt(this.num) == 0)&#123; alert(&quot;操作有误，无人可离.&quot;) return; &#125; this.content = &quot;还剩贵宾&quot; + --this.num + &quot;位, &quot;+&quot;欢迎下次光临!&quot; &#125;, hideBtnClick()&#123; this.isShowMenu = !this.isShowMenu &#125; &#125;, template: //波浪 代表多行 v-on:click=&quot;&quot; 表示对某个标签绑定某个函数 //&#123;&#123;content可以看做是数据绑定 从data中取出的数据&#125;&#125; ` &lt;div&gt; &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt; &lt;button v-on:click=&quot;welcomeBtnClick&quot;&gt;有顾客来&lt;/button&gt; &amp;nbsp; &lt;button v-on:click=&quot;byeBtnClick&quot;&gt;顾客离开&lt;/button&gt; &lt;div&gt; &lt;div v-if=&quot;isShowMenu&quot;&gt;&#123;&#123;Menu&#125;&#125;&lt;/div&gt; &lt;button v-on:click=&quot;hideBtnClick&quot;&gt;显示/隐藏套餐&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ` //字面量 双括号 放JS表达式或者变量 &#125;).mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; data(){} 中可以放多个数据template: ``波浪中可以放多行的 前端代码v-on:click=&quot;function&quot; 指定点击事件 当变量boolData为真时 变量data才会显示出来parseInt(val) 可以将val值转换为数值型数据for循环增加佳丽（技师）123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;for循环遍历佳丽&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.createApp(&#123; data()&#123; return &#123; waitresses: [&#x27;小红&#x27;, &#x27;小丽&#x27;, &#x27;小芳&#x27;] &#125; &#125;, methods:&#123; &#125;, template: ` &lt;div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;(waitress, index) of waitresses&quot;&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;waitress&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ` &#125;).mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; v-for=&quot;(item, index) of list&quot; 属性 代表从数组list中遍历每个item且附上索引 index将手动输入的值 添加佳丽123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;手动输入增加佳丽数据&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.createApp(&#123; data()&#123; return &#123; waitresses: [&#x27;小红&#x27;, &#x27;小丽&#x27;, &#x27;小芳&#x27;], inputWaitress:&#x27;&#x27; &#125; &#125;, methods:&#123; addWaitress()&#123; this.waitresses.push(this.inputWaitress) this.inputWaitress = &#x27;&#x27; &#125; &#125;, template: //波浪 代表多行 v-on:click=&quot;&quot; 表示对某个标签绑定某个函数 //&#123;&#123;content可以看做是数据绑定 从data中取出的数据&#125;&#125; ` &lt;div&gt; &lt;div&gt; &lt;input v-model=&quot;inputWaitress&quot; /&gt; &lt;button v-on:click=&quot;addWaitress&quot;&gt;增加技师&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;(waitress, index) of waitresses&quot;&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;waitress&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ` //字面量 双括号 放JS表达式或者变量 &#125;).mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; v-model=&quot;stringVal&quot; 定义输入的值 传给变量stringVal同时给按钮绑定函数 将对应输入的值 尾添至数组中（同时输入框值清空）Vue重要概念：组件式开发什么是组件？组件就像是 “网页窗体中-一个又一个不同的Section” 网页上所看到的任何东西 都可以写成组件比如在上个例子中的-&gt;增加佳丽 就可以利用这种思想来-&gt; 组件式开发把可以抽出来或者说可能重复被用到的代码块 抽离出来小案例：组件式开发-洗脚城系统1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;手动输入增加佳丽数据&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; //app是一个可以将自己的内容 挂载在id为app区域上的变量 const app = Vue.createApp(&#123; data()&#123; return &#123; waitresses:[&#x27;小红&#x27;, &#x27;小芳&#x27;, &#x27;小丽&#x27;], inputValue:&#x27; &#x27; &#125; &#125;, methods:&#123; add()&#123; this.waitresses.push(this.inputValue) this.inputValue = &#x27; &#x27; &#125; &#125;, template: ` &lt;my-title/&gt; &lt;input v-model=&quot;inputWaitress&quot;/&gt; &lt;button v-on:click=&quot;add&quot;&gt;添加佳丽&lt;/button&gt; &lt;div&gt; &lt;ul&gt; &lt;my-waitress v-for=&quot;(item, index) of waitresses&quot; v-bind:item=&quot;item&quot; v-bind:index=&quot;index&quot; /&gt; &lt;/ul&gt; &lt;/div&gt; ` &#125;) app.component(&#x27;my-title&#x27;,&#123; template:&#x27;&lt;h1 style=&quot;text-align=center&quot;&gt;洗脚城&lt;/h1&gt;&#x27; &#125;) //抽离出上个例子中 动态地渲染 参数为props列表中的值 app.component(&#x27;my-waitress&#x27;, &#123; props:[&#x27;item&#x27;, &#x27;index&#x27;], template:`&lt;li&gt;[&#123;&#123;index&#125;&#125;] &#123;&#123;item&#125;&#125;&lt;/li&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; VUE的组件式开发之总结： 在代码中，首先将app作为一个const常量（不可更改） 创建出来-&gt; const app = Vue.createApp({}) 然后编写这个app常量的各个组件- app.component(&#39;name&#39;,{data}) ....重复编写组件 最后选择把这个app挂载在 网页中的某个区域（可以id选择器，class选择器等..) app.mount(&quot;#id_name&quot;) 重要属性:1.组件中的template:&#39;&#39;/ ``分别填写单行、多行HTML2.v-on:click=&quot;fun_name&quot; 绑定单击事件3.v-for=&quot;(item, index) of list&quot; 利用for循环遍历数组4.v.bind-&gt;绑定这个自定义组件中的props参数数组中的参数VUE的createApp()方法 与 mount()方法讲解12const app = Vue.createApp(&#123;&#125;)app.mount(&quot;#app&quot;) createApp就是Vue创建一个应用 mount方法就是挂载到某一个DOM节点上 VUE的设计模式：mvvm-&gt;model, view, viewModelVue的编程设计模式应该叫做mvvm的设计模式。什么叫做mvvm？它首先是面向数据的编程，程序中定义了数据，然后定义了模板，Vue就可以把数据和模板自动进行关联。最后挂载到真实的DOM上，展示给用户。 1mvvm解释: 第一个m代表model数据，第一个v代表view视图，最后两个字幕vm代表viewModel视图数据连接层。 小案例认识 “数据” “模板” “数据视图连接层”123456789101112&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;vincent99013.github.io&#x27; //1.在这里定义了数据，也就是`model`数据 &#125; &#125;, template: &quot;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot; //2.在这里定义了模板，也就是`view`， //定义后的自动关联，就叫做`vm`，viewModel数据视图连接层。 &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; data(){} 中放数据 template:&quot;&quot; 中放模板view 即HTML代码 使得数据与视图之间得以连接 model数据，是我们自己定义的，view模板也是我们自己定义的，但是vm是Vue自动给我们关联的。 当我们明白了什么是mvvm后，你就知道为什么我们给根组件起名vm了。 当我们获取了vm根节点后，其实就可以操作里边的数据了。比如在控制台中输入下面的代码： 1vm.$data.message = &#x27;vincent&#x27; 如果在app里 我们使用this指针操作data数组中某个变量 自动执行函数的理解说起自动执行函数，还要从被动执行函数说起。比如给网页某一个元素一个点击事件： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Demo7&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;弹窗成功&#x27; &#125; &#125;, methods: &#123; clickFun() &#123; alert(this.message) &#125; &#125;, template: `&lt;div&gt; &lt;button v-on:click=&quot;clickFun&quot;&gt;点击我弹窗（被动事件）&lt;/button&gt; &lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; 在面向数据编程中，此时给该按钮加入点击事件。只有当该按钮被点击时，事件才会被触发。这就是被动函数的概念！ 而对于自动执行函数..不需要相应的点击事件才触发 自动执行函数-&gt; mounted()123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Demo7&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;弹窗成功&#x27; &#125; &#125;, mounted()&#123; alert(&#x27;自动弹出的内容&#x27;) &#125;, methods: &#123; &#125;, template: `&lt;div&gt; &lt;h1&gt;不用点击 自动弹窗&lt;/h1&gt; &lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; 在网页加载完成后，自动进入mounted函数中，即自动执行里面的代码块。 （很重要！）VUE的所有生命周期 重要的四个基本生命周期函数 beforeCreate(): 在实例生成之前会自动执行的函数 created(): 在实例生成之后会自动执行的函数 beforeMount(): 在模板渲染完成之前执行的函数 mounted(): 在模板渲染完成之后执行的函数 那么，现在用具体的例子来演示一下这四个基本周期函数吧： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Demo7&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;弹窗成功&#x27; &#125; &#125;, beforeCreate() &#123; console.log(&#x27;beforeCreate&#x27;) &#125;, created() &#123; console.log(&#x27;created&#x27;) &#125;, beforeMount() &#123; console.log(&#x27;beforeMount&#x27;) &#125;, mounted() &#123; console.log(&#x27;mounted&#x27;) &#125;, methods: &#123; &#125;, template: `&lt;div&gt; &lt;h1&gt;不用点击 自动弹窗&lt;/h1&gt; &lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; 浏览器的控制台：可以看到：执行流程是: beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted beforeUpdate和updated生命周期函数这两个周期函数是在VUE中的data数据发生变化时，才会被执行，一个是在变化之前，一个是在变化之后。 用一个改变data中变量message的值的例子来说明： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Demo7&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;初始值&#x27; &#125; &#125;, beforeUpdate()&#123; console.log(&#x27;当前的值未被改变！&#x27;) &#125;, updated()&#123; console.log(&#x27;当前的值已被改变!&#x27;) &#125;, methods: &#123; clickFun()&#123; this.message = &#x27;恭喜您，成功更改message的值！&#x27; &#125; &#125;, template: `&lt;div&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;button v-on:click=&quot;clickFun&quot;&gt;点击改变data中的数据值&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt;&lt;/html&gt; beforeUnmount和unmounted周期函数这两个生命周期函数是在VUE销毁时自动执行的函数，一个是销毁前执行，一个是销毁后执行。beforeUnmount(): 当VUE应用失效时，会自动执行。unmounted():当VUE应用失效，且DOM完全销毁之后，会自动执行。 代码演示如下： 1234567891011121314151617181920212223242526&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;初始值&#x27; &#125; &#125;, beforeUnmount()&#123; console.log(&#x27;beforeUnmount！&#x27;) &#125;, unmounted()&#123; console.log(&#x27;unmounted!&#x27;) &#125;, methods: &#123; clickFun()&#123; this.message = &#x27;恭喜您，成功更改message的值！&#x27; &#125; &#125;, template: `&lt;div&gt; &lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;) app.unmount()&lt;/script&gt; 可以看到，页面在调用unmount函数前后，控制台会打印：在app.unmount()函数执行后，在beforeUnmount()方法里，DOM还是有内容的，然后到了unmounted方法中，就已经没有任何的DOM内容了。 VUE中最重要的概念-八大生命周期创建，挂载，更改，非挂载记住八大生命周期，可回想安卓中的生命周期函数！各有两个un-XX与xx-ed 如图所示： 插值表达式与v-bind数据绑定在之前的代码类似 content 这种，正确叫法是 插值表达式 当然也可以叫做 字面量 JSP中从后台SpringMVC中的ModelAndView中存储的数据 利用EL表示JSP网页取值一样 123456789&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123;message: &#x27;数据&#x27;&#125; &#125;, template: &quot;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&quot; &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 在以上代码中，我们利用面向数据编程的插值表达式 在模板template当中显示出data数组中的数据。 但有时可能我们需要显示的一些数据变量，中含有HTML标签，我们想在网页中以标签的形式显示出来而不是字符串的内容（即不会把&lt;&gt;这样的内容也显示出来），这样我们就需要用到 v-html=&quot;message&quot; ，需要注意的是，我们需要用多行代码块`而不是单行代码块&quot; 具体代码如下： 1234567891011&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;&lt;i&gt;斜体的内容（不含标签）&lt;i&gt;&#x27; &#125; &#125;, template: `&lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; VUE中的数据双向绑定在模板template中引用的data数据，被绑定到模板对应mount挂载的网页区域中。当data中的数据发生改变时，对应网页中显示出来的内容也会发生改变。这就是双向数据绑定，而有时我们只需要这样的数据，让它只在第一次渲染出来，而之后不再跟随data中的数据的值变化而变化。这样的思想，我们可以用v-once属性完成！ 代码如下： 123456789101112131415161718192021&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;message数据的初始内容&#x27; &#125; &#125;, methods:&#123; fun()&#123; this.message = &#x27;更改数据中...&#x27; &#125; &#125;, template: ` &lt;div&gt; &lt;div v-once&gt;只会显示初始数据：&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;div&gt;&lt;button v-on:click=&quot;fun&quot;&gt;点击我但不会改变message的初始值&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 在上述代码中，我们无论点击多少次按钮，带有v-once属性的div中的字面量数据，绝对不会再次渲染新值 插值表达式中-使用JS代码（三目运算）比如我们要实现这么一个功能：这里有一个灯（不是开着的，就是关着的），我们利用嵌入JS代码至插值表达式中，实现开关灯。 1234567891011121314151617181920&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; Switch: true //我们默认灯是开着的 &#125; &#125;, methods:&#123; fun()&#123; this.Switch = !this.Switch //点击一下 就改变一下灯的状态 &#125; &#125;, template: ` &lt;div&gt; &lt;div&gt;状态：&#123;&#123;Switch? &#x27;灯已关闭&#x27;: &#x27;灯已打开&#x27;&#125;&#125;&lt;/div&gt; &lt;div&gt;&lt;button v-on:click=&quot;fun&quot;&gt;开关灯&lt;/button&gt;&lt;/div&gt; &lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 在某些情况下，我们需要这种“非真即假”的场景，来为我们改变一些元素的状态！ v-bind 给某个元素绑定属性假设我们data数组中有message这个数据，而我们想要某个元素有一个title属性，同时这个title的值为message的值。（联想我们插入HTML标签，而不是标签变成了字符串） 代码如下： 123456789101112&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;数据内容&#x27; &#125; &#125;, template: ` &lt;div v-bind:title = &quot;message&quot; &gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 此时我们将鼠标移到对应的数据内容上，悬停出来的内容即为title，而title的值也是数据内容。说明，我们利用v-bind属性给这个元素赋值了message变量中的内容。 v-on 的基本用法及简写v-on 是用来绑定响应事件的，在之前提到： 1234methods:&#123; alert(&#x27;显示数据中...&#x27;)&#125;,template:&quot; &lt;button v-on:click=&quot;fun&quot;&gt;点击我弹窗显示数据&lt;/button&gt; &quot; 现在可以利用@click来代替：v-on:click事件 也就是说 @事件=v-on:事件 完整代码： 12345678910111213141516171819&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;数据内容&#x27; &#125; &#125;, methods: &#123; fun()&#123; alert(this.message) &#125; &#125;, template: ` &lt;button @click=&quot;fun&quot;&gt;点击我弹窗显示数据&lt;/button&gt; ` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 效果图如下： v-bind绑定的基本用法及简写与v-on一样，v-bind也可以用来绑定属性。基本用法是： :title=&quot;val_name(变量名)&quot;，即绑定title为data中的变量名。 1234567891011121314151617181920&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;数据内容&#x27;, title: &#x27;:title生成的按钮标题&#x27; &#125; &#125;, methods: &#123; fun()&#123; alert(this.message) &#125; &#125;, template: ` &lt;button @click=&quot;fun&quot; :title=&quot;title&quot;&gt;点击我弹窗显示数据&lt;/button&gt; ` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 效果图如下： 模板动态参数属性动态参数对于绑定的title属性，我们可以看成是一个动态变量parameter里面，赋值为title，title的值为相应的变量名。 所以我们可以利用这样的形式来写：简写bind函数时，我们不用title（:title），我们把title抽离出来，看成是一个parameter变量的值 代码如下： 123456789101112131415161718192021&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;数据内容&#x27;, name: &#x27;title&#x27;, val: &#x27;标题值&#x27; &#125; &#125;, methods: &#123; fun()&#123; alert(this.message) &#125; &#125;, template: ` &lt;button @click=&quot;fun&quot; :[name]=&quot;val&quot;&gt;点击我弹窗显示数据&lt;/button&gt; ` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 事件动态绑定与属性动态绑定一样，我们可以将点击这个动作抽象成一个变量event，其值为click作为参数。对应的值不变！仍为data中的变量。 1&lt;button @[event]=&quot;fun&quot; :[name]=&quot;val&quot;&gt;点击我弹窗显示数据&lt;/button&gt; 12345678910111213141516171819202122&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;数据内容&#x27;, name: &#x27;title&#x27;, val: &#x27;标题值&#x27;, event: &#x27;click&#x27; &#125; &#125;, methods: &#123; fun()&#123; alert(this.message) &#125; &#125;, template: ` &lt;button @[event]=&quot;fun&quot; :[name]=&quot;val&quot;&gt;点击我弹窗显示数据&lt;/button&gt; ` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 通过事件绑定，属性绑定，这样我们可以动态切换对应的事件。只需要更改this.event以及this.parameter的值 VUE阻止默认事件（比如表单的默认提交）最常见的事件就是阻止表单的默认提交，比如在表单的数据还没有完全验证成功情况下。是必须阻止表单默认提交的！ 通常我们的代码会像这样： 123456789101112131415161718192021222324&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;数据内容&#x27;, name: &#x27;title&#x27;, val: &#x27;标题值&#x27;, event: &#x27;click&#x27; &#125; &#125;, methods: &#123; handleButton(e)&#123; e.preventDefault() &#125; &#125;, template: ` &lt;form action=&quot;https://www.baidu.com&quot;&gt; &lt;button type=&quot;submit&quot; @click=&quot;handleButton&quot;&gt;提交数据&lt;/button&gt; &lt;/form&gt; ` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 我们给一个自定义的阻止事件handleButton(e) 这个e看做是触发事件的源按钮 看做是哪一个按钮触发了这个事件，就指哪一个按钮 调用**e.preventDefault()**函数以阻止默认事件 对于那些经常要做的阻止操作而言，这种方法太低效了。 因而，VUE给我们提供了一个模板修饰符，直接可以阻止默认行为，写法如下： 123&lt;form action=&quot;https://www.baidu.com&quot; @click.prevent=&quot;handleButton&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;button&gt;&lt;/form&gt; 上述代码中:@click.prevent=&quot;阻止之后 转而进入的事件完整代码如下： 123456789101112131415161718192021222324&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;数据内容&#x27;, name: &#x27;title&#x27;, val: &#x27;标题值&#x27;, event: &#x27;click&#x27; &#125; &#125;, methods: &#123; handleButton()&#123; alert(&#x27;拦截成功...&#x27;) &#125; &#125;, template: ` &lt;form action=&quot;https://www.baidu.com&quot; @click.prevent=&quot;handleButton&quot;&gt; &lt;button type=&quot;submit&quot; &gt;提交数据&lt;/button&gt; &lt;/form&gt; ` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; VUE中模板的条件判断 v-if前面我们提到了三目运算符，结合例子说明： 123456789101112131415161718192021222324&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; num: 10, inputNum:&#x27;&#x27;, flag: false, message: &#x27;&#x27; &#125; &#125;, methods: &#123; handleButton()&#123; this.message = (parseInt(this.inputNum)&gt;this.num)? &#x27;你输入的数比10大&#x27;: &#x27;并没有比10大&#x27; &#125; &#125;, template: ` &lt;input v-model=&quot;inputNum&quot;/&gt; &lt;button @click=&quot;handleButton&quot;&gt;查询&lt;/button&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; ` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt; 当输入的数字大于10或者小于10时 都会提示 现在从这种三目运算符到v-if的过渡： 如果有这么一个场景，当输入的值为“蓝色”时，标签的背景是蓝色，如果是红色，背景是红色。 代码实现如下： 12345678910111213141516171819202122232425262728293031&lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; num: 10, inputValue:&#x27;&#x27;, flag: false, message: &#x27;&#x27; &#125; &#125;, methods: &#123; handleButton()&#123; this.message = this.inputValue &#125; &#125;, template: ` &lt;input v-model=&quot;inputValue&quot;/&gt; &lt;button @click=&quot;handleButton&quot;&gt;查询&lt;/button&gt; &lt;div v-if=&quot;message==&#x27;红色&#x27;&quot; class=&quot;red&quot;&gt;这片区域是红色&lt;/div&gt; &lt;div v-if=&quot;message==&#x27;蓝色&#x27;&quot; class=&quot;blue&quot;&gt;这片区域是蓝色&lt;/div&gt; ` &#125;) app.mount(&quot;#app&quot;)&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt; .red&#123;color:red&#125; .blue&#123;color:blue&#125;&lt;/style&gt; VUE中的computed域对应一般的方法而言，若页面重新渲染；则相应需要计算的方法，会再进行一次计算。 比如，现data数据中有val，和content两个变量；有一个涉及val变量的方法，计算val*10的值。 现在若在普通方法中，更改同在data中的变量content，那么val变量会重新计算一遍。 现在将代码放入computed域中，现在更改content的值时涉及val的方法不会再执行 VUE中的watch域Watch译为监听，则我们可以将一些需要监听数据变化，并对这些变化作出一些操作的数据源，放在Watch域中。而且可以获取到 改变前的值&amp;改变后的值 123456789101112131415161718192021222324252627&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; num: 1 &#125; &#125;, computed:&#123; &#125;, methods:&#123; fun()&#123; this.num--; &#125; &#125;, watch:&#123; num(current, prev)&#123; alert(&quot;你的num数据从&quot; + prev + &quot;变化到了&quot; + current) &#125; &#125;, template:` &lt;div&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; &lt;div&gt;&lt;button @click=&quot;fun&quot;&gt;点我减一&lt;/button&gt;&lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; VUE中的模板样式绑定详细讲解单个样式动态绑定现有三种样式，我们动态地引用这三个样式： 123.red&#123;color:red&#125;.green&#123;color:green&#125;.back&#123;background-color:orange&#125; 完整代码如下： 123456789101112131415161718192021&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; className:&#x27;red&#x27; &#125; &#125;, template:` &lt;h1 :class=&quot;className&quot;&gt;初始字体颜色为红色&lt;/h1&gt; &lt;h2&gt;您可以通过在控制台中修改vm.$data.className来动态引用class&lt;/h2&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt;&lt;style&gt;.red&#123;color:red&#125;.green&#123;color:green&#125;.back&#123;background-color: orange;&#125;&lt;/style&gt; 其中利用动态绑定:class=&quot;className&quot;，而在data中的变量className值代表真正的class值因此，我们可以在控制台中修改：vm.$data.className=&#39;green&#39; 使得我们在style标签中的CSS样式能够生效。 对象形式绑定多个样式在上个例子中，我们有字体颜色.red类，有背景颜色.back类现在我们想要绑定这个DOM元素，既让它有样式.red，又让它有样式.back则我们可以利用一个自定义对象classObject，将想要生效的样式置为true 完整代码如下： 123456789101112131415&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; className:&#x27;red&#x27;, classObject:&#123;&#x27;red&#x27;:true, &#x27;back&#x27;:true&#125; &#125; &#125;, template:` &lt;h1 :class=&quot;cl assObject&quot;&gt;初始字体颜色为红色&lt;/h1&gt; &lt;h2&gt;您可以通过在控制台中修改vm.$data.className来动态引用class&lt;/h2&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; 其中，我们看到，相应的red、back样式类都为true VUE中的for循环（以及如何避免重新渲染）在之前的for循环，我们每次都是重新渲染页面：如果有含初始数据的数组，我们只需要重新渲染“新数据”的内容每次添加数据 我们可以避免重新渲染之前的已有数据 利用 :key=&quot;index+item&quot; 绑定key属性！ 完整代码如下： 1234567891011121314151617181920212223&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; list:[&#x27;初始值&#x27;] &#125; &#125;, methods:&#123; fun()&#123; this.list.push(&#x27;尾添数据&#x27;) &#125; &#125;, template:` &lt;button @click=&quot;fun&quot;&gt;点我&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index+item&quot;&gt; [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; VUE中的事件对象-event无参函数 const app = Vue.createApp({ data(){ return{ list:['初始值'] } }, methods:{ fun(event){ console.log(event) } }, template:` 点我 ` }) const vm = app.mount(\"#app\") tips: 我们用event.target看到事件触发源含参函数当我们有参数时，调用函数若想用event， 此时应用click(para1, para2 ..., $event) const app = Vue.createApp({ data(){ return{ } }, methods:{ fun(num, event){ alert(++num) console.log(event.target) } }, template:` 点我+1 ` }) const vm = app.mount(\"#app\") VUE中一个按钮绑定两个方法有时，我们可能需要同时对一个按钮绑定一个事件。并同时执行两个方法fun1与fun2 **@click=&quot;fun1(), fun2()&quot;**可以完成这个功能。会顺序执行这两个方法！ 完整代码如下： 1234567891011121314151617181920&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; &#125; &#125;, methods:&#123; fun1()&#123; alert(&quot;小明取走100元&quot;) &#125;,fun2()&#123; alert(&quot;银行少了100元&quot;) &#125; &#125;, template:` &lt;button @click=&quot;fun1(), fun2()&quot;&gt;点我交易&lt;/button&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; VUE中的事件修饰符VUE中有六种常见的事件修饰符他们分别是： stop prevent capture self once passive 停止事件的冒泡机制-事件修饰符@click.stop所谓冒泡机制（就像水里面的泡泡，DOM树中的事件就像泡泡一样向上逐个被捕捉！） 比如网页结构是！ 1234&lt;body&gt; &lt;h2&gt; &lt;button&gt;...省略闭合标签 那么此时给button加的事件，会自底向上得逐个被各个标签捕获也就是说，若给h2添加点击事件，给button添加点击事件。 最终根据冒泡机制，会执行h2的点击事件。完整代码如下： 12345678910111213141516171819202122232425&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; count: 1 &#125; &#125;, methods:&#123; divClick()&#123; alert(&#x27;最终被标签捕捉到了！&#x27;) &#125;, btnClick()&#123; this.count++ console.log(this.count) &#125; &#125;, template:` &lt;div @click=&quot;divClick&quot;&gt; &lt;button @click=&quot;btnClick&quot;&gt;点击我体验冒泡机制&lt;/button&gt; &lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; 而我们可以用**@click.stop=&quot;btnClick&quot;**给下边的按钮添加，避免它往上冒泡被捕获到。 prevent修饰符：阻止默然行为的修饰符@click.prevent例如阻止form表单的默认提交行为。 123&lt;form @click.prevent=&quot;handleButton&quot;&gt;&lt;/form&gt; 上述代码可以避免自动form自动提交，转而转向handleButton函数 capture修饰符，冒泡反方向(自顶向下)once修饰符，事件只执行一次once修饰符修饰的事件，只会执行一次。 完整代码如下： 12345678910111213141516171819202122232425&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; count: 1 &#125; &#125;, methods:&#123; divClick()&#123; alert(&#x27;最终被标签捕捉到了！&#x27;) &#125;, btnClick()&#123; this.count++ console.log(this.count) &#125; &#125;, template:` &lt;div @click=&quot;divClick&quot;&gt; &lt;button @click.once=&quot;btnClick&quot;&gt;只会自增一次&lt;/button&gt; &lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; passive修饰符：解决滚动时性能的修饰符VUE中的MOUSE、KEYBOARD鼠标&amp;键盘按键绑定在某种场景下，我们需要按下Enter键登录&amp;注册我们需要在鼠标hover悬停于某个元素上方时，进行交互 这样的操作还涉及到键盘、鼠标之间的事件 KEYDOWN事件绑定 敲下键盘里的某个键（input属性）在输入框中输入内容时，会触发keydown事件 完整代码如下： 12345678910111213141516171819202122&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; count: 1 &#125; &#125;, methods:&#123; keyDownHandler()&#123; console.log(&#x27;正在键入....&#x27;) &#125; &#125;, template:` &lt;div &gt; &lt;input @keydown=&quot;keyDownHandler&quot; /&gt; &lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; 单个特定键位检测(input属性)对于特定的键Enter、Space等键有时我们会需要检测比如实现表单的Enter提交方式 完整代码如下： 1234567891011121314151617181920212223242526&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; count: 1, username:&#x27;&#x27; &#125; &#125;, methods:&#123; keyEnterDownHandler()&#123; console.log(&#x27;提交成功！您的数据为&#x27; + this.username) &#125; &#125;, template:` &lt;div &gt; &lt;input @keydown.enter=&quot;keyEnterDownHandler&quot; v-model=&quot;username&quot;/&gt; &lt;/div&gt; &lt;div&gt; &lt;button &gt;提交表单&lt;/button&gt; &lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; 表单的数据双向绑定什么叫数据的双向绑定？所谓数据的双向绑定，就是指：data中的变量val与页面中的字面量相互绑定 当data中的val发生改变时 前端页面显示的值会发生变化 当前端中的内容发生变化（比如输入框输入不同的值） 那么data中的内容也会发生变化 这种两方中其中一方发生变化，而另一方必然随之变化的过程，称为双向绑定 表单INPUT TEXTAREA文本框的绑定比如data中有一个变量val 12345data()&#123; return&#123; val:&#x27;&#x27; &#125;&#125; 而前端页面中，输入的值赋给val 1template:&quot;&lt;input v-model=&quot;val&quot; /&gt;&quot; 这样，输入不同的前端页面，data中的val也会不同！ input单行文本框添加**v-model=&quot;val&quot;**属性 textarea多行文本框同样适用 表单单选框RADIO的绑定单选框一般用字符串接收 参与单选框中的v-model对应的data中的字符串变量命名意义是：这些若干同属的类别**比如男、女 其v-model=&quot;gender&quot;**这样命名 其次，应有不同的value属性值来区分这些单选框！ 完整代码如下： 1234567891011121314151617181920212223&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; gender:&#x27;&#x27; &#125; &#125;, methods:&#123; keyEnterDownHandler()&#123; console.log(&#x27;提交成功！您的数据为&#x27; + this.username) &#125; &#125;, template:` &lt;div &gt; &lt;input type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;男&quot;/&gt;男 &lt;br&gt; &lt;input type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;女&quot;/&gt;女 &lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; 表单多选框CHECKBOX的绑定对于多选框的每个框要么属于checked被选中的状态 要么没被选中 所以如果只有一个选项 我们应用Bool值true与false来确定多选框的选中状态 如果有多个选项，我们**应该用一个数组[]**来装！ 完整代码如下： 1234567891011121314151617181920212223&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; gender:&#x27;&#x27;, interests:[] &#125; &#125;, methods:&#123; keyEnterDownHandler()&#123; console.log(&#x27;提交成功！您的数据为&#x27; + this.username) &#125; &#125;, template:` &lt;div &gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;interests&quot; value=&quot;打篮球&quot;/&gt;打篮球 &lt;br&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;interests&quot; value=&quot;游泳&quot;/&gt;游泳 &lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; 深入v-model1.LAZY 懒显示对于双向绑定，当输入框绑定data中的变量content后，如果页面的某一个区域立即用到了这个content那么在输入的过程中，页面会实时显示content的值 我们使用 v-model.lazy=&quot;val&quot; 来懒显示，即输入框失去焦点后，内容才会发生变化 代码如下： 12345678910111213141516&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; content:&#x27;&#x27; &#125; &#125;, template:` 输入框失去焦点才会显示的content：&#123;&#123;content&#125;&#125; &lt;div &gt; &lt;input v-model.lazy=&quot;content&quot;/&gt; &lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; 2.NUMBER 输入数字默认输入的内容是字符串类型 为避免后台转换数字 我们可以使用v-model.number=&quot;val&quot; 来转换成输入绑定data中的变量val 代码如下： 12345678910111213141516&lt;script&gt; const app = Vue.createApp(&#123; data()&#123; return&#123; content:&#x27;&#x27; &#125; &#125;, template:` 输入的数据类型是：&#123;&#123;typeof content&#125;&#125; &lt;div &gt; 年龄：&lt;input v-model.number=&quot;content&quot;/&gt; &lt;/div&gt; ` &#125;) const vm = app.mount(&quot;#app&quot;)&lt;/script&gt; 去除前后空格-trimtrim属性用来消除input框输入内容前后的空格的。现在我们再字符串上输入空格，其实它会在DOM元素上进行增加空格的，这个可以在控制台清楚的看出(详细请看视频操作)。 加入trim修饰符后，Vue就会自动给我们去除前后的空格. 1v-model.trim=&quot;content&quot;","categories":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"author":"vincent"},{"title":"翻译作品--如何像母语者一样说英语","slug":"翻译作品-如何像母语者一样说英语","date":"2021-03-26T09:28:57.000Z","updated":"2021-11-09T07:53:30.224Z","comments":true,"path":"翻译作品-如何像母语者一样说英语/","link":"","permalink":"https://github.com/Vincent990413/blog/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81-%E5%A6%82%E4%BD%95%E5%83%8F%E6%AF%8D%E8%AF%AD%E8%80%85%E4%B8%80%E6%A0%B7%E8%AF%B4%E8%8B%B1%E8%AF%AD/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< How to speak English fast and understand natives (Part I) | 如何更快理解母语者该视频由YouTube博主讲述如何像母语者一样说英语Do you really need to speak English fast? When native English speakers speak fast, the boundaries between words disappear and this gives the impression of talking fast. In reality, they are not talking faster than normal —it’s just that the sounds in their pronunciation flow together in the most smooth and efficient way.你一定要说得快吗?当以英语为母语的人说得很快时，单词之间的界限就消失了，这会给人一种说得很快的印象。在现实生活中，他们并没有说得比平时快，只是他们的发音中的声音以最流畅和有效的方式衔接在一起。 视频地址","categories":[{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"author":"vincent"},{"title":"C++管理系统","slug":"C-管理系统","date":"2021-03-19T06:45:08.000Z","updated":"2021-11-09T07:53:30.180Z","comments":true,"path":"C-管理系统/","link":"","permalink":"https://github.com/Vincent990413/blog/C-%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;typedef struct student //学生信息&#123; char stu_num[15]; //学号 char name[15]; //姓名 char stu_id[20]; //身份证号 char institute[50]; //学院 char stu_type; //学生类型 char major[50]; //专业 char route[100]; //返校路线 char TrafficTools[100]; //交通工具 char isCloseContact; //近14天是否有密切接触确诊人员 char temperature[10]; //入校时温度 char isFever; //是否发烧 char isCough; //是否咳嗽 char time[20]; //进校时间 &#125;Student;void Print(Student stu) //输出学生信息&#123; printf(&quot;\\n*****************学生信息*****************\\n\\n&quot;); printf(&quot;学号: %s\\n姓名: %s\\n身份证号: %s\\n学生类型: %c\\n&quot;,stu.stu_num,stu.name,stu.stu_id,stu.stu_type); printf(&quot;学院: %s\\n专业: %s\\n返校路线: %s\\n交通工具: %s\\n&quot;,stu.institute,stu.major,stu.route,stu.TrafficTools); printf(&quot;过去14天是否密切接触确诊人员（是：1/否：0）： %c\\n返校温度: %s\\n&quot;,stu.isCloseContact,stu.temperature); printf(&quot;是否发烧（是：1/否：0）: %c\\n是否咳嗽（是：1/否：0）: %c\\n返校时间: %s\\n&quot;,stu.isFever,stu.isCough,stu.time); &#125;void Instruction() //帮助&#123; printf(&quot;====================学生返校信息管理系统====================\\n&quot;); printf(&quot;= =\\n&quot;); printf(&quot;= ***功能介绍*** =\\n&quot;); printf(&quot;= =\\n&quot;); printf(&quot;= 1.录入学生信息 =\\n&quot;); printf(&quot;= 2.查找学生信息 =\\n&quot;); printf(&quot;= 3.修改学生信息 =\\n&quot;); printf(&quot;= 4.按顺序输出某学院学生信息 =\\n&quot;); printf(&quot;= 5.请求帮助 =\\n&quot;); printf(&quot;= 6.退出系统 =\\n&quot;); printf(&quot;= =\\n&quot;); printf(&quot;= =\\n&quot;); printf(&quot;============================================================\\n&quot;); return ;&#125;void WriteStuInfo()&#123; FILE *fp; char c = &#x27;y&#x27;; char file[50] = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\&quot;; while(c == &#x27;y&#x27;)&#123; Student stu = &#123;0&#125;; //初始化 cout &lt;&lt; &quot;请按照以下内容初始化：\\n&quot;; cout &lt;&lt; &quot;请输入学号\\n&quot;; cin &gt;&gt; stu.stu_num; cout &lt;&lt; &quot;请输入姓名\\n&quot;; cin &gt;&gt; stu.name; cout &lt;&lt; &quot;请输入身份证\\n&quot;; cin &gt;&gt; stu.stu_id; cout &lt;&lt; &quot;学生类型：（1本 2研 3博）\\n&quot;; cin &gt;&gt; stu.stu_type; cout &lt;&lt; &quot;所在学院\\n&quot;; cin &gt;&gt; stu.institute; cout &lt;&lt; &quot;所在专业\\n&quot;; cin &gt;&gt; stu.major; cout &lt;&lt; &quot;返校所经城市\\n&quot;; cin &gt;&gt; stu.route; cout &lt;&lt; &quot;交通工具\\n&quot;; cin &gt;&gt; stu.TrafficTools; cout &lt;&lt; &quot;是否接触确诊：1是 0否&quot;; cin &gt;&gt; stu.isCloseContact; cout &lt;&lt; &quot;入校时的温度\\n&quot;; cin &gt;&gt; stu.temperature; cout &lt;&lt; &quot;是否发烧: 1是 0否\\n&quot;; cin &gt;&gt; stu.isFever; cout &lt;&lt; &quot;是否咳嗽: 1是 0否\\n&quot;; cin &gt;&gt; stu.isCough; cout &lt;&lt; &quot;入校时间\\n&quot;; cin &gt;&gt; stu.time; strcat(file, stu.institute); strcat(file, &quot;.txt&quot;); cout &lt;&lt; file; fp = fopen(file, &quot;a&quot;); if(fp == NULL)&#123; cout &lt;&lt; &quot;文件无法打开\\n&quot;; exit(0); &#125; if(fwrite(&amp;stu, sizeof(Student), 1, fp) != 1)&#123; cout &lt;&lt;&quot;数据无法录入\\n&quot;; &#125; //在定义的数组长度不够的情况下 //每次读入一组数据 可以在文件中打印一个换行符 //fprintf(fp, &quot;\\n&quot;); fclose(fp); cout &lt;&lt; &quot;是否继续录入？(y/n)\\n&quot;; cin &gt;&gt; c; &#125;&#125;void Search()&#123; char c = &#x27;y&#x27;; int flag = 0; FILE* fp; int isSearch; Student stu = &#123;0&#125;; while(c == &#x27;y&#x27;)&#123; char stu_info[50], ins[50] = &#123;0&#125;; char file[50] = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\&quot;; cout &lt;&lt; &quot;输入学生所在学院\\n&quot;; cin &gt;&gt; ins; strcat(file ,ins); strcat(file, &quot;.txt&quot;); fp = fopen(file, &quot;r&quot;); cout &lt;&lt; &quot;请输入查找方式：1/学号,2/姓名\\n&quot;; cin &gt;&gt; flag; cout &lt;&lt; &quot;待查找的信息：&quot; &lt;&lt;endl; cin &gt;&gt; stu_info; isSearch = 0; while(fread(&amp;stu, sizeof(Student), 1, fp) == 1 )&#123; //当读到数据时 if(flag == 1)&#123; if(!strcmp(stu.stu_num, stu_info))&#123; cout &lt;&lt; &quot;找到了，数据为：\\n&quot;; Print(stu); isSearch = 1; break; &#125; if(!strcmp(stu.name, stu_info))&#123; cout &lt;&lt; &quot;找到了，数据为：\\n&quot;; Print(stu); isSearch = 1; break; &#125; &#125; if(isSearch == 0)&#123; cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt;endl; &#125; fclose(fp); cout &lt;&lt; &quot;是否继续查找(y/n)\\n&quot;; cin &gt;&gt; c; &#125; &#125;&#125; void Alter()&#123; FILE* fp; int isSearch; int pos, num; int i; char c = &#x27;y&#x27;; while(c == &#x27;y&#x27;)&#123; char newfile[10000] = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\&quot;; char stu_info[50], ins[50], file[50] = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\&quot;; Student all_stu[50], goal_stu, stu=&#123;0&#125;; cout &lt;&lt; &quot;请输入学生所在学院\\n&quot;; cin &gt;&gt; ins; strcat(file, ins); strcat(file, &quot;.txt&quot;); fp = fopen(file, &quot;r&quot;); cout &lt;&lt;&quot;输入学生学号:\\n&quot;; cin &gt;&gt; stu_info; isSearch = 0; pos = 0; num = 0; for(pos=0; fread(&amp;stu, sizeof(Student), 1, fp)==1; pos++)&#123; if(!strcmp(stu.stu_num, stu_info))&#123; goal_stu = stu; isSearch = 1; &#125;else&#123; all_stu[num++] = stu; &#125; &#125; if(isSearch)&#123; fclose(fp); fp = fopen(file, &quot;w&quot;); for(i =0; i&lt;num; i++)&#123; fwrite(&amp;all_stu[i], sizeof(Student), 1, fp); &#125; fclose(fp); cout &lt;&lt; &quot;请输入信息：\\n\\n&quot;; cout &lt;&lt; &quot;请输入学号：\\n&quot;; cin &gt;&gt; stu.stu_num; cout &lt;&lt; &quot;请输入姓名:\\n&quot;; cin &gt;&gt; stu.name; cout &lt;&lt; &quot;请输入身份证号：\\n&quot;; cin &gt;&gt; stu.stu_id; cout &lt;&lt; &quot;请输入学生类型:1/本, 2/硕, 3/博\\n&quot;; cin &gt;&gt; stu.stu_type; cout &lt;&lt; &quot;请输入所在学院：\\n&quot;; cin &gt;&gt; stu.institute; cout &lt;&lt; &quot;请输入所在专业：\\n&quot;; cin &gt;&gt; stu.major; strcat(newfile, stu.institute); strcat(newfile, &quot;.txt&quot;); fp = fopen(newfile, &quot;a&quot;); fwrite(&amp;stu, sizeof(Student), 1, fp); &#125;else&#123; cout &lt;&lt; &quot;查无此人\\n&quot;; &#125; fclose(fp); cout &lt;&lt; file &lt;&lt;endl; fp = fopen(file, &quot;r&quot;); while(fread(&amp;stu, sizeof(Student), 1, fp)==1)&#123; Print(stu); &#125; fclose(fp); cout &lt;&lt; &quot;是否继续修改y/n \\n&quot;; cin &gt;&gt; c; &#125; &#125; void print_Sort()&#123; FILE* fp; int j, Min; int num = 0; int i; Student all_stu[50]=&#123;0&#125;, stu=&#123;0&#125;; char newfile[10000] = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\sort_&quot;; char ins[20], file[50] = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\&quot;; cout &lt;&lt; &quot;请输入学院:\\n&quot;; cin &gt;&gt; ins; strcat(file, ins); strcat(file, &quot;.txt&quot;); fp = fopen(file, &quot;r&quot;); while(fread(&amp;all_stu[num++], sizeof(Student), 1, fp) == 1)&#123; ; &#125; fclose; for(i=0; i&lt;num-1; i++)&#123; Min = i; for(j=i+1; j&lt;num; j++)&#123; if(strcmp(all_stu[Min].stu_num, all_stu[j].stu_num) &gt;0)&#123; Min = j; &#125; &#125; if(Min != i)&#123; Student temp = all_stu[i]; all_stu[i] = all_stu[Min]; all_stu[Min] = temp; &#125; &#125; strcat(newfile, ins); strcat(newfile, &quot;.txt&quot;); fp = fopen(newfile, &quot;w&quot;); for(i=0; i&lt;num; i++)&#123; fwrite(&amp;all_stu[i], sizeof(Student), 1, fp); &#125; fclose(fp); fp = fopen(newfile, &quot;r&quot;); while(fread(&amp;stu, sizeof(Student), 1, fp)==1)&#123; Print(stu); &#125; fclose(fp); &#125;void passwordVerify()&#123; char password[20]=&#123;0&#125;; int i=5; printf(&quot;\\n\\n&quot;); printf(&quot;====================欢迎使用学生返校信息管理系统====================\\n\\n&quot;); while(i&gt;0)&#123; printf(&quot;请输入登录密码：&quot;); scanf(&quot;%s&quot;,&amp;password); if(strcmp(password,&quot;123456&quot;)!=0)&#123; --i; printf(&quot;密码输入错误，请重新输入，您还有%d次机会\\n&quot;,i); &#125; else&#123; printf(&quot;密码输入正确！&quot;); break;&#125; if(i==0)&#123; exit(0);&#125; &#125;&#125;void chooseMenu()&#123; int flag; char c=&#x27;y&#x27;; while(c==&#x27;y&#x27;)&#123; printf(&quot;请输入您需要的操作（按5请求帮助）： \\n&quot;); flag=0; scanf(&quot;%d&quot;,&amp;flag); getchar(); if(flag==1)&#123; //录入 WriteStuInfo(); &#125; else if(flag==2)&#123; //查找 Search(); &#125; else if(flag==3)&#123; //修改 Alter(); &#125; else if(flag==4)&#123; //排序 print_Sort(); &#125; else if(flag==5)&#123; //导航 Instruction(); &#125; else if(flag==6)&#123; //退出系统 exit(0); &#125; else &#123; printf(&quot;输入有误！请重新输入！\\n &quot;); continue; &#125; printf(&quot;是否继续使用该系统（y/n）：&quot;); scanf(&quot;%c&quot;,&amp;c); &#125;&#125;int main()&#123; passwordVerify(); Instruction(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"vincent"},{"title":"C++面向对象基础","slug":"C-面向对象基础","date":"2021-03-17T11:24:49.000Z","updated":"2021-11-09T07:53:30.181Z","comments":true,"path":"C-面向对象基础/","link":"","permalink":"https://github.com/Vincent990413/blog/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"职员类构造函数set get 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;using namespace std;//定义一个职员类class Employee&#123; //属性与方法 public: //公共方法 //构造函数 有多个构造函数后 //默认的空构造函数 会被覆盖 建议加上 Employee()&#123;&#125; Employee(string name, string company, int age); //Set方法 void setName(string name); void setCompany(string company); void setAge(int age); //Get方法 string getName(); string getCompany(); int getAge(); void introduce(); private: //私有属性 在类的外部不可直接调用 //注意！不管是接口还是属性 还是方法 //C++中 不明确指出public还是protected的 //默认是“private”！！！！ string Name; //姓名 string Company; //所就职的公司 int Age; //年龄 &#125;; //利用域名符:: 实现相应的方法 //注意：实现相应方法的形参 必须对应相应的函数声明//注意：使用this指针时 内部使用-&gt; 在主函数中的对象 使用.Employee::Employee(string name, string company, int age)&#123; //this指针 代表当前任意被调用的这个对象 this-&gt;Name = name; this-&gt;Company = company; this-&gt;Age = age;&#125;void Employee::setName(string name)&#123; this-&gt;Name = name;&#125;string Employee::getName()&#123; return this-&gt;Name;&#125;void Employee::setCompany(string company)&#123; this-&gt;Company = company;&#125;string Employee::getCompany()&#123; return this-&gt;Company;&#125;void Employee::setAge(int age)&#123; this-&gt;Age = age;&#125;int Employee::getAge()&#123; return this-&gt;Age;&#125;void Employee::introduce()&#123; cout &lt;&lt; &quot;Name-&gt;&quot; &lt;&lt; Name &lt;&lt; &quot;,&quot; &lt;&lt; &quot;Company-&gt;&quot; &lt;&lt; Company &lt;&lt; &quot;,Age-&gt;&quot; &lt;&lt;Age&lt;&lt;endl; &#125;int main()&#123; string name = &quot;Vincent&quot;; string company = &quot;Tecent&quot;; int age = 21; //利用构造函数 new一个新的职员对象 Employee e1 = Employee(name, company, age); e1.introduce(); return 0;&#125; 实现虚拟接口职员具有实现接口的功能1.定义一个接口（Virtual 虚拟方法）1234class AbstractEmployee&#123; public: virtual void AskForPromotion()=0;&#125;; 2.声明某个类实现 :这个AbstractClass12345678class Employee:AbstractEmployee&#123; public: //.....公共方法 //将接口中的方法 作为实现这个方法的类的成员函数 void AskForPromotion(); private: //.....私有属性&#125;; 3.具体实现函数123void Employee::AskForPromotion()&#123; //具体方法&#125; 程序员（Employee类的子类 继承Employee）1.程序员类具有自己特有的构造函数&amp;成员函数12345678910111213class Developer: Employee&#123; public: //别忘了默认的构造函数 以及声明程序员类特有的构造函数 Developer()&#123;&#125; Developer(string name, string company, int age, string fav); //继承Employee的同时 Developer类具有Employee的公共方法 //Set函数与Get函数 是Developer独有的方法 void setFavProgLang(string language); string getFavProgLang(); private: string FavProgLang; //最喜欢的编程语言 &#125;; 2.实现这个构造函数以及成员函数(:Empl... 表示由其父类来实现前三个参数)12345Developer::Developer(string name, string company, int age, string fav) :Employee(name, company, age)&#123; this-&gt;FavProgLang = fav;&#125; 注意：父类中的Name，Company，Age 在其子类Developer中都是不可获取的（Inaccessible）因为，这些属性都是private 私有的，在类外任何地方都不能获取！除非我们修改这些属性的修饰符 修改成protected","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"vincent"},{"title":"SpringMVC学习笔记(所有代码FROM SIKI学院)","slug":"Spring-MVC学习笔记","date":"2021-03-17T06:19:57.000Z","updated":"2021-11-09T07:53:30.208Z","comments":true,"path":"Spring-MVC学习笔记/","link":"","permalink":"https://github.com/Vincent990413/blog/Spring-MVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"SpringMVC是什么？Spring MVC又叫SpringWebMVC是一个轻量级的基于请求响应的表现层框架。它是Spring框架的一部分。SpringMVC与Struts2都可以替代原始Servlet技术。 为什么要使用SpringMVC？Spring Web MVC框架提供了MVC(模型 - 视图 - 控制器)架构和用于开发灵活和松散耦合的Web应用程序的组件。?MVC模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。 1、SpringMVC是极具代表性的MVC框架对初学者学习很有帮助； a)模型(Model)封装了应用程序数据，通常它们将由Bean对象组成； b)视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出； c)控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染； 2、与Spring框架无缝集成；3、对Servlet轻度封装，框架小巧轻便性能好；4、可使用注解式开发，编码简洁；5、便于测试；6、具有本地化、国际化、类型转换、数据验证等功能；7、使用人群十分广泛，在现在的企业招聘中属于java程序员必备技能之一； 我能从这门课中学到什么？1、SpringMVC框架学习：a)了解SpringMVC框架处理流程；b)掌握SpringMVC搭建、配置与使用；c)Spring + SpringMVC + MyBatis 三大框架整合；d)掌握SpringMVC基本参数与复杂参数绑定；e)掌握SpringMVC自定义异常处理类、拦截器、图片上传等操作；f)掌握SpringMVC处理Json格式字符串； 2、SSM框架练习项目：a)使用整合后的SSM框架完成Steam后台游戏管理和前台游戏列表的Demo； SpringMVC从哪获取？以下网址可以获取Spring框架的所有版本，SpringMVC是Spring框架中的一个子包SpringWebMvchttp://repo.spring.io/release/org/springframework/spring/ Part.1 SpringMVC入门：1、SpringMVC简要处理流程： 2、HelloSpringMVC：搭建SpringMVC HelloWorld项目a)导包 –&gt; 02_jar -&gt; spring_jar整理 -&gt; spring_mvc；b)DispatcherServlet配置和拦截规则 (前端控制器、任务派发器、前端调度器)；c)使用SpringMVC显示页面；d)使用SpringMVC向前台传递数据； 3、SpringMVC详细处理流程： 4、DispatcherServlet.properties内Bean对象：a)HandlerMapping：处理器映射 ：将请求映射到Handler上并返回处理器执行链i.通过HandlerMapping（处理器映射），可以将Web 请求映射到正确的Handler（处理器）也就是Controller上；ii.DispactherServlet（前端控制器） 将请求交给HandlerMapping，让他检查请求并找到一个合适的HandlerExecutionChain（处理器执行链），这个HandlerExecutionChain 包含一个能处理该请求的Handler； b)HandlerAdapter：处理器适配器 ：执行具体的逻辑业务i.负责执行DispactherServlet中HandlerExecutionChain的Handler；ii.从Handler中获取ModelAndView（模型与视图）对象，返回给DispactherServlet； c)ViewResolver：视图解析器 ：解析视图i.通过视图名称解析视图；ii.返回视图对象； d)HandlerExceptionResolver：处理器异常解析，将异常映射到统一错误页面，常见的404页面，不让用户看到具体的错误，友好提示；e)LocaleResolver：本地化解析，解析客户端信息进行本地化；f)ThemeResolver：主题解析，实现多风格，类似皮肤效果；g)RequestToViewNameTranslator：请求到视图名转换器，当view为空时，从request中获取viewName；FlashMapManager：FlashMap管理器，通常应用在重定向场景； 5、SpringMVC Controller简要说明a)RequestMapping注解使用：i.多请求；ii.限定请求方法；iii.窄化(简化)请求路径; b)Controller方法返回值：i.ModelAndView：返回模型和视图ii.void：使用原生request，responseiii.String：1.返回视图名 viewName；比较推荐使用2.转发 forword；3.重定向 redirect； iv.自定义类型(JSON) – 需要@ResponseBody注解 - Part.2 SpringMVC &amp; Spring &amp; MyBatis整合：1、整合ssm 3大框架a)导包 -&gt; spring_Jar整理 -&gt; ssm框架整合包b)配置 -&gt; web.xmli.读取spring配置文件；ii.配置springmvc前端控制器； c)配置 -&gt; applicationContext.xmli.读取数据库配置文件；ii.配置数据源连接池；iii.开启注解扫描；iv.配置事务核心管理器；v.开启注解事务；vi.配置视图解析器； vii.配置Mybatis：1.配置sqlSessionFactory；2.配置别名；3.配置mapper工厂； 2、准备测试用例a)准备 – 测试数据：i.Bean -&gt; 根据个人喜好；ii.数据库表 -&gt; 根据个人喜好；b)导入 – 测试数据 -&gt; 学习项目 -&gt; 后台页面使用整合后的ssm框架，查询数据库测试表，将数据显示到前台 Part.3 SpringMVC参数绑定与数据交互：1、默认参数绑定：通过id查询游戏信息，并将结果显示在页面上；a)HttpServletRequest request；b)HttpServletResponse response；c)HttpSession session；d)Model model：将数据存储在request域，前台可以获取； 2、基本参数绑定：通过id删除游戏信息；a)Integer、int；b)Float、float；c)Double、double；d)Boolean、boolean；e)String； 3、Bean对象参数绑定：添加游戏；4、包装类参数绑定：多条件查询，并将结果显示在页面上；5、解决表单post提交乱码：在web.xml中配置过滤器； 复杂类型参数绑定：1、Array数组类型的参数绑定：为页面增加多选框，获取选定游戏信息的id，后续逻辑自行选择；2、List类型的参数绑定：获取所有游戏价格，并且计算总价； Json数据交互： Json介绍：http://www.bejson.com/knownjson/aboutjson/a)导包，配置注解驱动；b)创建自己的Json对象；c)发送和接收Json字符串；d)修改游戏信息，在弹出层内回显数据；e)使用@RequestBody完成List和数组参数绑定，获取所有游戏的名称，在后台打印； Part.4 异常处理器与拦截器1、通过实现HandlerExceptionResolver接口完成异常处理；a)异常处理器原理； b)使用异常处理器捕获运行时异常；c)使用异常处理器捕获自定义异常； 2、通过注解完成全局异常处理；a)通过@ControllerAdvice注解使@ExceptionHandler异常处理注解应用到所有使用@RequestMapping的方法上；b)处理运行时异常：直接打印错误信息；c)处理自定义异常：将错误信息输出到error页面上； 拦截器Interceptor1、SpringMvc中的拦截器：a)SpringMvc拦截器帮我们按照一定规则拦截请求，后根据开发人员自定义的拦截逻辑进行处理；b)自定义拦截器需要实现HandlerInterceptor接口；c)自定义的拦截器实现类需要在SpringMvc配置文件中配置；d)可以配置多个拦截器，配置的顺序会影响到拦截器的执行顺序，配置在前的先执行；e)HandlerInterceptor有3个接口：i.preHandle 预处理：在拦截方法前执行；ii.postHandle 后处理：在拦截方法后执行；iii.afterCompletion 渲染后处理：在页面渲染后执行；f)拦截器也体现了AOP思想；g)拦截器的应用：权限检查，日志记录，性能检测等； 2、拦截器的执行流程图： 3、拦截器的执行规则；a)自定义2个拦截器，并在主配置文件中配置好；b)运行服务进入拦截器，观察执行流程； 4、总结的五条拦截器规则；a)preHandle预处理：--------------根据拦截器定义的顺序，正向执行；b)postHandle后处理：-------------根据拦截器定义的顺序，逆向执行；c)afterCompletion渲染后处理：---根据拦截器定义的顺序，逆向执行；d)postHandle预处理：-------------所有拦截器都返回成功调用；e)atterCompletion渲染后处理：---preHandle返回true调用； 5、使用拦截器开发用户登录校验；a)需要登录才可以访问列表页；b)如果未登录重定向到登录页面； 6、使用拦截器搭配异常处理器完成用户登录时的异常处理；a)使用自定义异常处理器捕获登录时异常；b)如果出现异常，将异常信息发送到登录页面提示； 7、静态资源放行；a)在web.xml配置DispatcherServlet的url-pattern以扩展名结尾，例如*.do，*.html 等；b)在web.xml配置default servlet-mapping的url-pattern，以目录形式和扩展名形式；c)在springmvc.xml中配置mvc:resources/，该方法需要注意以下几点：i.需要开启mvc:annotation-driven注解驱动；ii.如果配置了拦截器，需要在拦截器中进行过滤，否则会被拦截；iii.路径名不要打错?; 8、RESTful风格开发：一种以URL定位资源的开发风格。使用RESTful开发URL会变得一目了然，更有层次，它不是标准或者协议；更多关于RESTful风格的介绍网上查查； 使用RESTful前：http://127.0.0.1/item/save POST 新增物品http://127.0.0.1/item/delete GET/POST 删除物品http://127.0.0.1/item/update POST 修改物品http://127.0.0.1/item/query.do?id=1 GET ? 根据id查询物品 使用RESTful后：http://127.0.0.1/item POST 新增物品http://127.0.0.1/item/1 DELETE 根据id删除物品http://127.0.0.1/item PUT 修改物品http://127.0.0.1/item/1 GET ? 根据id查询物品 RESTful风格开发对Http协议中的基本方法的使用POST INSERT 增 邮寄一个新的DELETE DELETE 删 仍了，不要了GET SELECT 查 获取一个PUT UPDATE 改 往这个里边放点东西 使用Springmvc实现RESTful风格开发；a)使用物品id当作请求路径，点击按钮，跳转到具体的页面；b)当使用ajax时，页面不会跳转，需要到ajax回调中处理； SPRINGMVC-PROJECT-1前端请求页面form.jsp1234567891011121314&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/mylist.do&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; WEB配置文件 web.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;ssm_spring_mvc&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 读取springmvc配置文件 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 拦截规则 --&gt; &lt;!--1 *.htm *.do *.action 以扩展名方式进行拦截，不拦截静态资源 .jpg .css .js .png 什么情况下都可以使用 2 / 不拦截 jsp 拦截静态资源 .jpg .css .js .png /* 全都拦截 包括jsp 以及所有静态资源 不推荐使用的--&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; SPRINGMVC配置文件 springmvc.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt; &lt;!-- 开启注解扫描 基本包下有 bean,controller层.. --&gt; &lt;context:component-scan base-package=&quot;com.sikiedu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 配置viewName 前缀与后缀 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; BEAN对象 ItemInfo.java12345678910public class ItemInfo &#123; //id private String item_id; //name private String item_name; //type private String item_type; //price private String item_price;&#125; Controller层 ItemController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!-- 注解表示是控制层 通过springmvc注解扫描 --&gt;&lt;!-- RequestMapping对应前端页面的请求路径 --&gt;@Controller @RequestMapping(value=&quot;/item/&quot;)public class ItemController &#123; //显示页面 @RequestMapping(value= &#123;&quot;list.do&quot;, &quot;mylist.do&quot;&#125;, method= &#123;RequestMethod.GET, RequestMethod.POST&#125;) &lt;!-- 指定返回类型是ModelAndView 表示最后会跳转页面 --&gt; public ModelAndView list() &#123; ModelAndView mav = new ModelAndView(); //传递数据 //准备一些测试数据 ItemInfo info1 = new ItemInfo(&quot;1&quot;, &quot;王者荣耀&quot;, &quot;MOBA&quot;, &quot;0&quot;) ; ItemInfo info2 = new ItemInfo(&quot;2&quot;, &quot;守望先锋&quot;, &quot;射击&quot;, &quot;198&quot;) ; ItemInfo info3 = new ItemInfo(&quot;3&quot;, &quot;吃鸡&quot;, &quot;射击&quot;, &quot;98&quot;) ; ItemInfo info4 = new ItemInfo(&quot;4&quot;, &quot;魔兽世界&quot;, &quot;MMORPG&quot;, &quot;0&quot;) ; ItemInfo info5 = new ItemInfo(&quot;5&quot;, &quot;保卫萝卜&quot;, &quot;休闲&quot;, &quot;0&quot;) ; List&lt;ItemInfo&gt; itemList = new ArrayList&lt;ItemInfo&gt;(); itemList.add(info1); itemList.add(info2); itemList.add(info3); itemList.add(info4); itemList.add(info5); //将游戏列表返回给前台 mav.addObject(&quot;itemList&quot;, itemList); mav.setViewName(&quot;item_list&quot;); return mav; &#125; @RequestMapping(value= &#123;&quot;mylist1.do&quot;&#125;, method= &#123;RequestMethod.GET, RequestMethod.POST&#125;) public ModelAndView list1() &#123; ModelAndView mav = new ModelAndView(); //传递数据 //准备一些测试数据 ItemInfo info1 = new ItemInfo(&quot;1&quot;, &quot;王者荣耀&quot;, &quot;MOBA&quot;, &quot;0&quot;) ; ItemInfo info2 = new ItemInfo(&quot;2&quot;, &quot;守望先锋&quot;, &quot;射击&quot;, &quot;198&quot;) ; ItemInfo info3 = new ItemInfo(&quot;3&quot;, &quot;吃鸡&quot;, &quot;射击&quot;, &quot;98&quot;) ; ItemInfo info4 = new ItemInfo(&quot;4&quot;, &quot;魔兽世界&quot;, &quot;MMORPG&quot;, &quot;0&quot;) ; ItemInfo info5 = new ItemInfo(&quot;5&quot;, &quot;保卫萝卜&quot;, &quot;休闲&quot;, &quot;0&quot;) ; List&lt;ItemInfo&gt; itemList = new ArrayList&lt;ItemInfo&gt;(); itemList.add(info1); itemList.add(info2); itemList.add(info3); itemList.add(info4); itemList.add(info5); //将游戏列表返回给前台 指定Viewname即显示的页面是哪一个？ mav.addObject(&quot;itemList&quot;, itemList); mav.setViewName(&quot;item_list&quot;); return mav; &#125; //void @RequestMapping(value=&quot;&quot;) public void voidTest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取参数 request.getParameter(&quot;&quot;); //转发 request.getRequestDispatcher(&quot;&quot;).forward(request, response); //重定向 response.sendRedirect(request.getContextPath() + &quot;/xx.jsp&quot;); &#125; //String 转发 @RequestMapping(&quot;forwardString.do&quot;) public String forwardString() &#123; return &quot;forward:mylist1.do&quot;; &#125; //String 重定向 @RequestMapping(&quot;redirectString.do&quot;) public String redirectString() &#123; return &quot;redirect:/form.jsp&quot;; &#125; //String @RequestMapping(&quot;testList.do&quot;) public String testList(Model model) &#123; //传递数据 //准备一些测试数据 ItemInfo info1 = new ItemInfo(&quot;1&quot;, &quot;王者荣耀&quot;, &quot;MOBA&quot;, &quot;0&quot;) ; ItemInfo info2 = new ItemInfo(&quot;2&quot;, &quot;守望先锋&quot;, &quot;射击&quot;, &quot;198&quot;) ; ItemInfo info3 = new ItemInfo(&quot;3&quot;, &quot;吃鸡&quot;, &quot;射击&quot;, &quot;98&quot;) ; ItemInfo info4 = new ItemInfo(&quot;4&quot;, &quot;魔兽世界&quot;, &quot;MMORPG&quot;, &quot;0&quot;) ; ItemInfo info5 = new ItemInfo(&quot;5&quot;, &quot;保卫萝卜&quot;, &quot;休闲&quot;, &quot;0&quot;) ; List&lt;ItemInfo&gt; itemList = new ArrayList&lt;ItemInfo&gt;(); itemList.add(info1); itemList.add(info2); itemList.add(info3); itemList.add(info4); itemList.add(info5); //将游戏列表返回给前台 model.addAttribute(&quot;itemList&quot;, itemList); return &quot;item_list&quot;; &#125; &#125; 数据显示页面 item_list.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;游戏管理后台&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;/head&gt; &lt;body class=&quot;side_menu_active side_menu_expanded&quot;&gt; &lt;div id=&quot;page_wrapper&quot;&gt; &lt;!-- header --&gt; &lt;header id=&quot;main_header&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!--logo--&gt; &lt;div class=&quot;brand_section&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;$&#123;pageContext.request.contextPath &#125;/picture/logo01.png&quot; alt=&quot;site_logo&quot; width=&quot;108&quot; height=&quot;40&quot; style=&quot;margin-top: 5px&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;header_user_actions dropdown&quot;&gt; &lt;div data-toggle=&quot;dropdown&quot; class=&quot;dropdown-toggle user_dropdown&quot;&gt; &lt;div class=&quot;user_avatar&quot;&gt; &lt;img src=&quot;$&#123;pageContext.request.contextPath &#125;/picture/head01.png&quot; width=&quot;38&quot; height=&quot;38&quot;&gt; &lt;/div&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;dropdown-menu dropdown-menu-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;!-- main content --&gt; &lt;div id=&quot;main_wrapper&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-10&quot;&gt; &lt;table class=&quot;table table-yuk2 toggle-arrow-tiny&quot; id=&quot;footable_demo&quot; data-filter=&quot;#textFilter&quot; data-page-size=&quot;5&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;!--描述：商品数据标签--&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;游戏名称&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;th&gt;原价&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;$&#123;itemList &#125;&quot; var=&quot;item&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;item.item_id &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.item_name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.item_type &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.item_price &#125;&lt;/td&gt; &lt;td data-value=&quot;1&quot;&gt; &lt;a herf=&quot;#&quot; id=&quot;edit_btn&quot; class=&quot;btn btn-xs btn-info&quot; data-toggle=&quot;modal&quot; data-target=&quot;#editLayer&quot; onclick=&quot;editGoods(&#x27;$&#123;item.item_id&#125;&#x27;)&quot;&gt;修改&lt;/a&gt; &lt;a herf=&quot;#&quot; id=&quot;del_btn&quot; class=&quot;btn btn-xs btn-danger&quot; onclick=&quot;deleteGoods(&#x27;$&#123;item.item_id&#125;&#x27;)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;tfoot class=&quot;hide-if-no-paging&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot;&gt; &lt;ul class=&quot;pagination pagination-sm&quot;&gt;&lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- edit layer --&gt; &lt;div class=&quot;modal fade&quot; id=&quot;editLayer&quot;&gt; &lt;div class=&quot;modal-dialog modal-content&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;修改游戏信息&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;!--游戏修改详情弹出层表单--&gt; &lt;form class=&quot;form-horizontal&quot; id=&quot;edit_item_form&quot;&gt; &lt;!-- 游戏id隐藏域 --&gt; &lt;input type=&quot;hidden&quot; id=&quot;edit_item_id&quot; name=&quot;item_id&quot;/&gt; &lt;!-- 游戏名称 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;edit_item_name&quot; class=&quot;col-sm-2 control-label&quot;&gt;游戏名称&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;edit_item_name&quot; placeholder=&quot;游戏名称&quot; name=&quot;item_name&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 游戏类型 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;edit_item_price&quot; class=&quot;col-sm-2 control-label&quot;&gt;类型&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;edit_item_price&quot; placeholder=&quot;类型&quot; name=&quot;item_price&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 游戏原价 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;edit_item_price&quot; class=&quot;col-sm-2 control-label&quot;&gt;原价&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;edit_item_price&quot; placeholder=&quot;原价&quot; name=&quot;item_price&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-sm&quot; data-dismiss=&quot;modal&quot;&gt;取消&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm&quot; onclick=&quot;updateItem()&quot;&gt;确认修改&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- add layer --&gt; &lt;div class=&quot;modal fade&quot; id=&quot;addLayer&quot;&gt; &lt;div class=&quot;modal-dialog modal-content&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;新增游戏&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;!--添加游戏弹出层表单--&gt; &lt;form class=&quot;form-horizontal&quot; id=&quot;add_item_form&quot;&gt; &lt;!-- 游戏id隐藏域 --&gt; &lt;input type=&quot;hidden&quot; id=&quot;add_item_id&quot; name=&quot;item_id&quot;/&gt; &lt;!-- 游戏名称 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;add_item_name&quot; class=&quot;col-sm-2 control-label&quot;&gt;游戏名称&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;add_item_name&quot; placeholder=&quot;游戏名称&quot; name=&quot;item_name&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 游戏类型 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;add_item_price&quot; class=&quot;col-sm-2 control-label&quot;&gt;类型&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;add_item_price&quot; placeholder=&quot;类型&quot; name=&quot;item_price&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 游戏原价 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;add_item_price&quot; class=&quot;col-sm-2 control-label&quot;&gt;原价&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;add_item_price&quot; placeholder=&quot;原价&quot; name=&quot;item_price&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-sm&quot; data-dismiss=&quot;modal&quot;&gt;取消&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm&quot; onclick=&quot;addItem()&quot;&gt;确认修改&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- main menu --&gt; &lt;nav id=&quot;main_menu&quot;&gt; &lt;div class=&quot;menu_wrapper&quot;&gt; &lt;ul&gt; &lt;li class=&quot;first_level&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt; &lt;span class=&quot;icon_document_alt first_level_icon&quot;&gt;&lt;/span&gt; &lt;span class=&quot;menu-title&quot;&gt;游戏管理&lt;/span&gt; &lt;/a&gt; &lt;ul&gt; &lt;li class=&quot;submenu-title&quot;&gt;游戏管理&lt;/li&gt; &lt;!-- &lt;li&gt;&lt;a href=&quot;#&quot; data-toggle=&quot;modal&quot; data-target=&quot;#addLayer&quot;&gt;商品添加&lt;/a&gt;&lt;/li&gt; --&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/item/list.do&quot;&gt;游戏列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;menu_toggle&quot;&gt; &lt;span class=&quot;icon_menu_toggle&quot;&gt; &lt;i class=&quot;arrow_carrot-2left toggle_left&quot;&gt;&lt;/i&gt; &lt;i class=&quot;arrow_carrot-2right toggle_right&quot; style=&quot;display:none&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; //footable yukon_footable.goodslist(); //datepicker yukon_datepicker.p_forms_extended(); &#125;) //修改弹框回显 function toEdit(id) &#123; $.ajax(&#123; type:&quot;post&quot;, url:&quot;$&#123;pageContext.request.contextPath &#125;/item/toEdit&quot;, data:&#123;&quot;id&quot;:id&#125;, success:function(data) &#123; $(&quot;#edit_item_name&quot;).val(data.item_name); $(&quot;#edit_item_type&quot;).val(data.item_type); $(&quot;#edit_item_price&quot;).val(data.item_price); &#125;, dataType:&quot;json&quot; &#125;); &#125; //确认修改 function updateItem() &#123; $.post( &quot;$&#123;pageContext.request.contextPath &#125;/item/update.do&quot;, $(&quot;#edit_item_form&quot;).serialize(), function(data)&#123; alert(&quot;游戏信息更新成功!&quot;); window.location.reload(); &#125;); &#125; //确认删除 function deleteItem(id) &#123; if(confirm(&#x27;确实要删除该游戏吗?&#x27;)) &#123; $.post( &quot;$&#123;pageContext.request.contextPath &#125;/item/delete.do&quot;, &#123;&quot;id&quot;:id&#125;, function(data)&#123; window.location.reload(); &#125;); &#125; &#125; //添加游戏 function addItem() &#123; $.post( &quot;$&#123;pageContext.request.contextPath &#125;/item/save.do&quot;, $(&quot;#add_item_form&quot;).serialize(), function(data)&#123; alert(&quot;游戏添加成功!&quot;); window.location.reload(); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; SPRINGMVC-PROJECT-2新增登录拦截器与集成配置文件登录拦截器LoginIntercaptor.java12345678910111213141516171819202122public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取请求 String URI = request.getRequestURI(); if(!URI.contains(&quot;login&quot;)) &#123; //不是登录请求 拦截 Object user = request.getSession().getAttribute(&quot;user&quot;); if(user == null) &#123; //没有登录 重定向到登录页面 / 请求 response.sendRedirect(request.getContextPath()+&quot;/login/login.do&quot;); return false; &#125; &#125; return true; &#125;&#125; 集成配置文件 applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt; &lt;!-- 读取配置文件 数据库 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;com.sikiedu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 静态资源放行 --&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt; &lt;mvc:resources location=&quot;/fonts/&quot; mapping=&quot;/fonts/**&quot;/&gt; &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt; &lt;mvc:resources location=&quot;/picture/&quot; mapping=&quot;/picture/**&quot;/&gt; &lt;!-- 开启注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 事务核心管理器 --&gt; &lt;bean name=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 开启注解事务 --&gt; &lt;tx:annotation-driven/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置mybatis --&gt; &lt;bean name=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.sikiedu.bean&quot;/&gt; &lt;/bean&gt; &lt;!-- mapper工厂 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.sikiedu.mapper&quot;/&gt; &lt;/bean&gt; &lt;mvc:interceptors&gt; &lt;!-- 登录验证拦截器 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.png&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.tff&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.woff&quot;/&gt; &lt;bean class=&quot;com.sikiedu.interceptor.LoginInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; SpringMVC 源码分析 谈谈SpringMVC的执行流程？ 以下笔记以及代码来自Bilibili：https://www.bilibili.com/video/BV1Va4y1x7B7?p=2&amp;spm_id_from=pageDriver 细化执行流程 客户端的请求，会发给DispatcherServlet 请求转发器。我们可以看成是第一道网关，不处理逻辑，只负责任务的派发。 接下来DispatcherServlet会将任务，转发到HandlerMapping 处理器映射器，这个处理器映射器负责帮我们根据请求的URL，选择哪一个处理器Handler来处理当前请求。这个处理器Handler就是我们的Controller，而返回给我们的，并不是一个Handler，而是一个处理器执行链 HandlerExecutionChain，包括Handler处理器对象以及多个HandlerInterceptor处理器拦截器对象。 在找到具体应该由哪个Handler处理器后，接下来到HandlerAdapter 处理器适配器，即具体调用处理器Handler的处理请求的方法。 方法需要返回对象，会返回一个ModelAndView 视图模型对象，通过这个视图模型对象，我们可以知道：1. 在哪里显示最终的数据？ 2. 显示的数据是什么？而这个ModelAndView视图模型对象，会返回给DispatcherServlet 请求转发器。这里值得注意的是，我们通过modelAndView.setViewName(&quot;success&quot;);,即通过视图名来确定在哪里显示最终的数据，的前提是，我们要配置了视图解析器ViewResolver，最终帮我们加上前缀后缀，来返回到页面中。 因此，返回了ModelAndView对象后，我们需要视图解析器来返回View对象给DispatcherServlet请求转发器。包含数据：真正的前端视图地址信息，返回给最终展示数据的视图View。 流程图如下： DispatcherServlet，最重要的方法是doService： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Exposes the DispatcherServlet-specific request attributes and delegates to &#123;@link #doDispatch&#125; * for the actual dispatching. */ @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; RequestPath previousRequestPath = null; if (this.parseRequestPath) &#123; previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE); ServletRequestPathUtils.parseAndCache(request); &#125; try &#123; doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request); &#125; &#125; 然后比较重要是具体分派任务的方法 123try &#123; doDispatch(request, response);&#125; 这个方法的具体内容是： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet&#x27;s HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet&#x27;s installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It&#x27;s up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 在具体分派处理器的doDispatch方法中，我们可以看到一个方法：getHandler方法。 12// Determine handler for the current request.mappedHandler = getHandler(processedRequest); 注意，这里是dispatchServlet.java中的getHandler方法。 而这是对getHandler方法的定义： 1234567891011121314151617/** * Return a handler and any interceptors for this request. The choice may be made * on request URL, session state, or any factor the implementing class chooses. * &lt;p&gt;The returned HandlerExecutionChain contains a handler Object, rather than * even a tag interface, so that handlers are not constrained in any way. * For example, a HandlerAdapter could be written to allow another framework&#x27;s * handler objects to be used. * &lt;p&gt;Returns &#123;@code null&#125; if no match was found. This is not an error. * The DispatcherServlet will query all registered HandlerMapping beans to find * a match, and only decide there is an error if none can find a handler. * @param request current HTTP request * @return a HandlerExecutionChain instance containing handler object and * any interceptors, or &#123;@code null&#125; if no mapping found * @throws Exception if there is an internal error */@NullableHandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; 具体方法如下： 123456789101112131415161718/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found */@Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125; 可以注意到，HandlerMapping类型的对象mapping也有一个getHandler方法。而这个getHandler方法，是在HandlerExecutionChain方法中被定义，这个HandlerExecutionChain类很关键。 12345678910111213141516171819202122/** * Handler execution chain, consisting of handler object and any handler interceptors. * Returned by HandlerMapping&#x27;s &#123;@link HandlerMapping#getHandler&#125; method. * * @author Juergen Hoeller * @since 20.06.2003 * @see HandlerInterceptor */public class HandlerExecutionChain &#123; private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class); private final Object handler; @Nullable private HandlerInterceptor[] interceptors; @Nullable private List&lt;HandlerInterceptor&gt; interceptorList; private int interceptorIndex = -1;&#125; 在这个类中的getHandler中，方法如下： 123456/** * Return the handler object to execute. */public Object getHandler() &#123; return this.handler;&#125; 在通过getHandler方法，拿到了对应的Handler之后。 12// Determine handler adapter for the current request.HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); 可以看出，我们需要，通过这个拿到的Handler对象，来得到一个HandlerAdapter对象。 那么我们为什么需要这个HandlerAdapter对象呢？前面已经提到，在知道具体哪个是我们需要的处理器之后，我们需要去调用这个处理器的方法，我们就需要一个适配器，去做这件事。 而getHandlerAdapter方法如下： 12345678910111213141516/** * Return the HandlerAdapter for this handler object. * @param handler the handler object to find an adapter for * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error. */protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; throw new ServletException(&quot;No adapter for handler [&quot; + handler + &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);&#125; 因为在SpringMVC中有许多不同的控制器，因此对应的实现方法也是不同的。既然不同，那么互相之间是不能兼容的， 为了判断当前的Handler处理器，是可以受我们的适配器支持的。 则有这个adapter对象的supports方法。具体方法如下： 123456789101112/** * Given a handler instance, return whether or not this &#123;@code HandlerAdapter&#125; * can support it. Typical HandlerAdapters will base the decision on the handler * type. HandlerAdapters will usually only support one handler type each. * &lt;p&gt;A typical implementation: * &lt;p&gt;&#123;@code * return (handler instanceof MyHandler); * &#125; * @param handler handler object to check * @return whether or not this object can use the given handler */boolean supports(Object handler); 这里也提到，判断是否支持的典型实现代码是： 1return (handler instanceof MyHandler); 现在拿到了我们的处理器适配器方法后，关键在于，如何真正地调用我们在处理器中写的业务逻辑代码呢？ 注意，在调用业务方法之前与之后，还有一个很重要的步骤：调用拦截器方法。 123if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125; 其中调用preHandle的拦截器方法如下： 1234567891011121314151617181920/** * Apply preHandle methods of registered interceptors. * @return &#123;@code true&#125; if the execution chain should proceed with the * next interceptor or the handler itself. Else, DispatcherServlet assumes * that this interceptor has already dealt with the response itself. */boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = 0; i &lt; interceptors.length; i++) &#123; HandlerInterceptor interceptor = interceptors[i]; if (!interceptor.preHandle(request, response, this.handler)) &#123; triggerAfterCompletion(request, response, null); return false; &#125; this.interceptorIndex = i; &#125; &#125; return true;&#125; 如果拦截器不让通过，则直接return;。 现在如果能够通过，则需要调用HandlerAdapter的handle方法。 12// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 这个handler方法，返回的是一个ModelAndView对象，方法如下： 1234567891011121314/** * Use the given handler to handle this request. * The workflow that is required may vary widely. * @param request current HTTP request * @param response current HTTP response * @param handler handler to use. This object must have previously been passed * to the &#123;@code supports&#125; method of this interface, which must have * returned &#123;@code true&#125;. * @throws Exception in case of errors * @return a ModelAndView object with the name of the view and the required * model data, or &#123;@code null&#125; if the request has been handled directly */@NullableModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; 123456@Override@Nullablepublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return ((Controller) handler).handleRequest(request, response);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * Base Controller interface, representing a component that receives * &#123;@code HttpServletRequest&#125; and &#123;@code HttpServletResponse&#125; * instances just like a &#123;@code HttpServlet&#125; but is able to * participate in an MVC workflow. Controllers are comparable to the * notion of a Struts &#123;@code Action&#125;. * * &lt;p&gt;Any implementation of the Controller interface should be a * &lt;i&gt;reusable, thread-safe&lt;/i&gt; class, capable of handling multiple * HTTP requests throughout the lifecycle of an application. To be able to * configure a Controller easily, Controller implementations are encouraged * to be (and usually are) JavaBeans. * * &lt;h3&gt;&lt;a name=&quot;workflow&quot;&gt;Workflow&lt;/a&gt;&lt;/h3&gt; * * &lt;p&gt;After a &#123;@code DispatcherServlet&#125; has received a request and has * done its work to resolve locales, themes, and suchlike, it then tries * to resolve a Controller, using a * &#123;@link org.springframework.web.servlet.HandlerMapping HandlerMapping&#125;. * When a Controller has been found to handle the request, the * &#123;@link #handleRequest(HttpServletRequest, HttpServletResponse) handleRequest&#125; * method of the located Controller will be invoked; the located Controller * is then responsible for handling the actual request and &amp;mdash; if applicable * &amp;mdash; returning an appropriate * &#123;@link org.springframework.web.servlet.ModelAndView ModelAndView&#125;. * So actually, this method is the main entry point for the * &#123;@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet&#125; * which delegates requests to controllers. * * &lt;p&gt;So basically any &lt;i&gt;direct&lt;/i&gt; implementation of the &#123;@code Controller&#125; interface * just handles HttpServletRequests and should return a ModelAndView, to be further * interpreted by the DispatcherServlet. Any additional functionality such as * optional validation, form handling, etc. should be obtained through extending * &#123;@link org.springframework.web.servlet.mvc.AbstractController AbstractController&#125; * or one of its subclasses. * * &lt;h3&gt;Notes on design and testing&lt;/h3&gt; * * &lt;p&gt;The Controller interface is explicitly designed to operate on HttpServletRequest * and HttpServletResponse objects, just like an HttpServlet. It does not aim to * decouple itself from the Servlet API, in contrast to, for example, WebWork, JSF or Tapestry. * Instead, the full power of the Servlet API is available, allowing Controllers to be * general-purpose: a Controller is able to not only handle web user interface * requests but also to process remoting protocols or to generate reports on demand. * * &lt;p&gt;Controllers can easily be tested by passing in mock objects for the * HttpServletRequest and HttpServletResponse objects as parameters to the * &#123;@link #handleRequest(HttpServletRequest, HttpServletResponse) handleRequest&#125; * method. As a convenience, Spring ships with a set of Servlet API mocks * that are suitable for testing any kind of web components, but are particularly * suitable for testing Spring web controllers. In contrast to a Struts Action, * there is no need to mock the ActionServlet or any other infrastructure; * mocking HttpServletRequest and HttpServletResponse is sufficient. * * &lt;p&gt;If Controllers need to be aware of specific environment references, they can * choose to implement specific awareness interfaces, just like any other bean in a * Spring (web) application context can do, for example: * &lt;ul&gt; * &lt;li&gt;&#123;@code org.springframework.context.ApplicationContextAware&#125;&lt;/li&gt; * &lt;li&gt;&#123;@code org.springframework.context.ResourceLoaderAware&#125;&lt;/li&gt; * &lt;li&gt;&#123;@code org.springframework.web.context.ServletContextAware&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;Such environment references can easily be passed in testing environments, * through the corresponding setters defined in the respective awareness interfaces. * In general, it is recommended to keep the dependencies as minimal as possible: * for example, if all you need is resource loading, implement ResourceLoaderAware only. * Alternatively, derive from the WebApplicationObjectSupport base class, which gives * you all those references through convenient accessors but requires an * ApplicationContext reference on initialization. * * &lt;p&gt;Controllers can optionally implement the &#123;@link LastModified&#125; interface. * * @author Rod Johnson * @author Juergen Hoeller * @see LastModified * @see SimpleControllerHandlerAdapter * @see AbstractController * @see org.springframework.web.testfixture.servlet.MockHttpServletRequest * @see org.springframework.web.testfixture.servlet.MockHttpServletResponse * @see org.springframework.context.ApplicationContextAware * @see org.springframework.context.ResourceLoaderAware * @see org.springframework.web.context.ServletContextAware * @see org.springframework.web.context.support.WebApplicationObjectSupport */@FunctionalInterfacepublic interface Controller &#123; /** * Process the request and return a ModelAndView object which the DispatcherServlet * will render. A &#123;@code null&#125; return value is not an error: it indicates that * this object completed request processing itself and that there is therefore no * ModelAndView to render. * @param request current HTTP request * @param response current HTTP response * @return a ModelAndView to render, or &#123;@code null&#125; if handled directly * @throws Exception in case of errors */ @Nullable ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;&#125; 因此我们可以让某个类，实现这个Controller接口。则会走实现的handlerRequest方法，并最终返回ModelAndView类的方法。 比如我们某个类TestController可以实现这个Controller。 注意这个Controller的包位于:1import org.springframework.web.servlet.mvc.Controller; 12345678910public class TestController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(&quot;success&quot;); //前提是要设置视图解析器 mav.addObject(&quot;msg&quot;, &quot;这是消息&quot;); return mav; &#125;&#125; 当得到这个ModelAndView对象（含有Model信息与View信息）后，我们需要对这个对象进行处理。 首先判断，是否需要做ViewName的解析，如果不做解析，则用默认ViewName。 1applyDefaultViewName(processedRequest, mv); 方法如下： 1234567891011/** * Do we need view name translation? */private void applyDefaultViewName(HttpServletRequest request, @Nullable ModelAndView mv) throws Exception &#123; if (mv != null &amp;&amp; !mv.hasView()) &#123; String defaultViewName = getDefaultViewName(request); if (defaultViewName != null) &#123; mv.setViewName(defaultViewName); &#125; &#125;&#125; 可以看到，如果这个ModelAndView对象不为空，但是没有view对象。则从对象request中获取默认的视图名，并设置为新的view对象。 然后就是拦截器的postHandle方法： 1mappedHandler.applyPostHandle(processedRequest, response, mv); 其中定义方法如下： 1234567891011121314/** * Apply postHandle methods of registered interceptors. */void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; interceptor.postHandle(request, response, this.handler, mv); &#125; &#125;&#125; 当完成这些来到最后的步骤，处理转发的结果。我们知道，数据最终都是要通过视图解析器返回给前端。 因此，来到这个方法： 1processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Handle the result of handler selection and handler invocation, which is * either a ModelAndView or an Exception to be resolved to a ModelAndView. */private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; 在这个方法中，我们需要重点关注render这个方法： 1render(mv, request, response); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Render the given ModelAndView. * &lt;p&gt;This is the last stage in handling a request. It may involve resolving the view by name. * @param mv the ModelAndView to render * @param request current HTTP servlet request * @param response current HTTP servlet response * @throws ServletException if view is missing or cannot be resolved * @throws Exception if there&#x27;s a problem rendering the view */protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Determine locale for request and apply it to the response. Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()); response.setLocale(locale); View view; String viewName = mv.getViewName(); if (viewName != null) &#123; // We need to resolve the view name. view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(&quot;Could not resolve view with name &#x27;&quot; + mv.getViewName() + &quot;&#x27; in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); &#125; &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; + &quot;View object in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); &#125; &#125; // Delegate to the View object for rendering. if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Rendering view [&quot; + view + &quot;] &quot;); &#125; try &#123; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; view.render(mv.getModelInternal(), request, response); &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Error rendering view [&quot; + view + &quot;]&quot;, ex); &#125; throw ex; &#125;&#125; 可以看到，我们在获得viewName后，需要viewResolver视图解析器来处理这个viewName，并返回一个view对象。 1view = resolveViewName(viewName, mv.getModelInternal(), locale, request); 其中方法定义如下： 123456789101112131415161718192021222324252627/** * Resolve the given view name into a View object (to be rendered). * &lt;p&gt;The default implementations asks all ViewResolvers of this dispatcher. * Can be overridden for custom resolution strategies, potentially based on * specific model attributes or request parameters. * @param viewName the name of the view to resolve * @param model the model to be passed to the view * @param locale the current locale * @param request current HTTP servlet request * @return the View object, or &#123;@code null&#125; if none found * @throws Exception if the view cannot be resolved * (typically in case of problems creating an actual View object) * @see ViewResolver#resolveViewName */@Nullableprotected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; if (this.viewResolvers != null) &#123; for (ViewResolver viewResolver : this.viewResolvers) &#123; View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; &#125; return null;&#125; 而具体的对象viewResolver的resolveViewName的方法。 123456789101112131415161718@Override@Nullablepublic View resolveViewName(String viewName, Locale locale) throws BeansException &#123; ApplicationContext context = obtainApplicationContext(); if (!context.containsBean(viewName)) &#123; // Allow for ViewResolver chaining... return null; &#125; if (!context.isTypeMatch(viewName, View.class)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Found bean named &#x27;&quot; + viewName + &quot;&#x27; but it does not implement View&quot;); &#125; // Since we&#x27;re looking into the general ApplicationContext here, // let&#x27;s accept this as a non-match and allow for chaining as well... return null; &#125; return context.getBean(viewName, View.class);&#125; 返回这个view对象后。 在render方法的最后，具体调用view对象的render方法： 1view.render(mv.getModelInternal(), request, response); 12345678910111213/** * Render the view given the specified model. * &lt;p&gt;The first step will be preparing the request: In the JSP case, this would mean * setting model objects as request attributes. The second step will be the actual * rendering of the view, for example including the JSP via a RequestDispatcher. * @param model a Map with name Strings as keys and corresponding model * objects as values (Map can also be &#123;@code null&#125; in case of empty model) * @param request current HTTP request * @param response he HTTP response we are building * @throws Exception if rendering failed */void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception; 1234567891011121314151617181920/** * Prepares the view given the specified model, merging it with static * attributes and a RequestContext attribute, if necessary. * Delegates to renderMergedOutputModel for the actual rendering. * @see #renderMergedOutputModel */@Overridepublic void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;View &quot; + formatViewName() + &quot;, model &quot; + (model != null ? model : Collections.emptyMap()) + (this.staticAttributes.isEmpty() ? &quot;&quot; : &quot;, static attributes &quot; + this.staticAttributes)); &#125; Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response); prepareResponse(request, response); renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);&#125; 可以看到，这里需要将静态资源与请求上下文资源进行合并，并最后委托renderMergedOutputModel方法来实现实际的渲染。 值得一提的是，这个方法是接口中的抽象方法，因而有若干个不同的具体实现方法，对应着不同的类： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Render the internal resource given the specified model. * This includes setting the model as request attributes. */@Overrideprotected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) &#123; throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() + &quot;]: Check that the corresponding file exists within your web application archive!&quot;); &#125; // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;); &#125; rd.include(request, response); &#125; else &#123; // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;); &#125; rd.forward(request, response); &#125;&#125; 可以看到，在方法的最后，我们利用请求转发器RequestDispatcher对象来完成请求的转发。 SpringMVC控制器Controller的底层实现方式实现Controller接口当实现这个Controller接口后，我们必须要实现里面的handleRequest方法。 并且会返回他规定的ModelAndView对象，而不是其他类型的。 这种方式，就是本文开始部分所讲的部分。 @Controller注解 如果说是SSM项目的话，我们需要在SpringMVC的配置文件xml中，去指定控制器的扫描路径。否则，我们将找不到这个Bean对象。 如果说是SpringBoot项目，我们只需要在启动类中，指定@ComponentScan扫描注解即可。 实现HttpRequestHandler接口注意，之前我们实现Conroller接口时，返回的对象是ModelAndView对象，此时我们返回的是void对象，因此，我们需要使用request来指定经过这个请求后，对应的视图在哪里，然后转发过去。即以下代码： 12request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request, response); 并且需要在配置文件中，配置Bean对象，指定路径为这个实现HttpRequestHandler接口的路径。 注意：不同的控制器实现方式，之间是不兼容的，因此对于不同的实现方式，会返回不同的适配器对象，也代表着Java中的适配器设计模式。 SpringMVC参数注入比如这个方法： 1234567@RequestMapping(value = &quot;/hello&quot;)public ModelAndView say(String name) &#123; ModelAndView mv=new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;Hello, my name is &quot; + name); mv.setViewName(&quot;index&quot;); return mv;&#125; 对于参数name，我们是如何封装的呢？ 首先这是位于handler中的方法，因此肯定是在调用handle方法的时候，同时将参数注入进去的。 回到doDispatch方法中，我们具体看handle方法。这里需要注意，如果实现了Controller注解或者是RestController。 那么在下图中，应该会走AbstractHandlerMethodAdapter。 12345678910/** * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. */@Override@Nullablepublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler);&#125; 然后进入handleInternal方法中： 12345678910111213141516171819202122232425262728293031323334353637@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; checkRequest(request); // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No synchronization on session demanded at all... mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125; 以下方法是源码中，具体注入参数的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Invoke the &#123;@link RequestMapping&#125; handler method preparing a &#123;@link ModelAndView&#125; * if view resolution is required. * @since 4.2 * @see #createInvocableHandlerMethod(HandlerMethod) */@Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125; 这里用到了工厂模式，让WebDataBinderFactory工厂与ModelFactory工厂，来帮我们完成数据绑定与初始化Model的事情，以及一些异步请求管理。 关于参数注入的关键代码是： 1invocableMethod.invokeAndHandle(webRequest, mavContainer); 1234567891011121314151617181920212223242526272829303132333435363738/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers&#125;. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs &quot;given&quot; arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; disableContentCachingIfNecessary(webRequest); mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); Assert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;); try &#123; this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(formatErrorForReturnValue(returnValue), ex); &#125; throw ex; &#125;&#125; 这个方法完成的是，调用handle的方法并处理返回值： 1Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); 这里注意到：providedArgs代码提供的参数信息。我们需要关注这个。 点进去发现： 123456789@Nullablepublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs); if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Arguments: &quot; + Arrays.toString(args)); &#125; return this.doInvoke(args);&#125; 上述代码中，通过getMethodArgumentValues方法来获得方法的参数。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Get the method argument values for the current request, checking the provided * argument values and falling back to the configured argument resolvers. * &lt;p&gt;The resulting array will be passed into &#123;@link #doInvoke&#125;. * @since 5.1.2 */protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; MethodParameter[] parameters = getMethodParameters(); if (ObjectUtils.isEmpty(parameters)) &#123; return EMPTY_ARGS; &#125; Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;)); &#125; try &#123; args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; // Leave stack trace for later, exception may actually be resolved and handled... if (logger.isDebugEnabled()) &#123; String exMsg = ex.getMessage(); if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123; logger.debug(formatArgumentError(parameter, exMsg)); &#125; &#125; throw ex; &#125; &#125; return args;&#125; 这里可以看到，在参数的for循环中，通过resolveArgument方法来处理参数: 1args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); 在这个resolveArgument方法中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Override@Nullablepublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; NamedValueInfo namedValueInfo = getNamedValueInfo(parameter); MethodParameter nestedParameter = parameter.nestedIfOptional(); Object resolvedName = resolveStringValue(namedValueInfo.name); if (resolvedName == null) &#123; throw new IllegalArgumentException( &quot;Specified name must not resolve to null: [&quot; + namedValueInfo.name + &quot;]&quot;); &#125; Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest); if (arg == null) &#123; if (namedValueInfo.defaultValue != null) &#123; arg = resolveStringValue(namedValueInfo.defaultValue); &#125; else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123; handleMissingValue(namedValueInfo.name, nestedParameter, webRequest); &#125; arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType()); &#125; else if (&quot;&quot;.equals(arg) &amp;&amp; namedValueInfo.defaultValue != null) &#123; arg = resolveStringValue(namedValueInfo.defaultValue); &#125; if (binderFactory != null) &#123; WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name); try &#123; arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter); &#125; catch (ConversionNotSupportedException ex) &#123; throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(), namedValueInfo.name, parameter, ex.getCause()); &#125; catch (TypeMismatchException ex) &#123; throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(), namedValueInfo.name, parameter, ex.getCause()); &#125; &#125; handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest); return arg;&#125; 其中，这一句负责参数的处理： 1Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest); 123456789101112/** * Resolve the given parameter type and value name into an argument value. * @param name the name of the value being resolved * @param parameter the method parameter to resolve to an argument value * (pre-nested in case of a &#123;@link java.util.Optional&#125; declaration) * @param request the current request * @return the resolved argument (may be &#123;@code null&#125;) * @throws Exception in case of errors */@Nullableprotected abstract Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception; 那么是哪一个呢？这里选择@RequestParam，如果不给参数中的String类型变量加注解，默认为@RequestParam。可以看到，这里还有PathVariable。 12345678910111213141516171819202122232425262728@Override@Nullableprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception &#123; HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class); if (servletRequest != null) &#123; Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest); if (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123; return mpArg; &#125; &#125; Object arg = null; MultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class); if (multipartRequest != null) &#123; List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name); if (!files.isEmpty()) &#123; arg = (files.size() == 1 ? files.get(0) : files); &#125; &#125; if (arg == null) &#123; String[] paramValues = request.getParameterValues(name); if (paramValues != null) &#123; arg = (paramValues.length == 1 ? paramValues[0] : paramValues); &#125; &#125; return arg;&#125; 这里可以看到： 123456if (arg == null) &#123; String[] paramValues = request.getParameterValues(name); if (paramValues != null) &#123; arg = (paramValues.length == 1 ? paramValues[0] : paramValues); &#125;&#125; 主要看这句话： 12345678/** * Return the request parameter values for the given parameter name, * or &#123;@code null&#125; if none. * &lt;p&gt;A single-value parameter will be exposed as an array with a single element. * @see javax.servlet.http.HttpServletRequest#getParameterValues(String) */@NullableString[] getParameterValues(String paramName); 这个代码是，从@RequestParam中，去找对应的值。比如，name=&quot;jimmy&quot;，那么这里返回的就是&quot;jimmy&quot;，其中paramName为name。","categories":[{"name":"SSM学习笔记","slug":"ssm学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/ssm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SSM学习笔记","slug":"ssm学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/ssm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"翻译作品-大数据","slug":"翻译作品-大数据","date":"2021-03-16T09:19:42.000Z","updated":"2021-11-09T07:53:30.223Z","comments":true,"path":"翻译作品-大数据/","link":"","permalink":"https://github.com/Vincent990413/blog/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81-%E5%A4%A7%E6%95%B0%E6%8D%AE/","excerpt":"","text":"Big Data In 5 Minutes | What Is Big Data?| 5分钟大数据|什么是大数据Introduction To Big Data |Big Data Explained |Simplilearn 大数据入门This video will help you understand what Big Data is, the 5V&#39;s of Big Data, why Hadoop came into existence, and what Hadoop is. You will also learn about the storage unit and processing unit of Hadoop, and the implementation of Big Data through use cases. In the end, we will have a quiz on Hadoop. A massive amount of data that cannot be stored, processed, and analyzed using the traditional ways is known as Big Data. Hadoop is a framework that manages Big Data storage in a distributed way and processes it parallelly. Now, let&#39;s deep dive into this video and understand Big Data and Hadoop. 本视频将帮助您理解什么是大数据，大数据的5V, Hadoop为什么会出现，以及Hadoop是什么。通过用例了解Hadoop的存储单元和处理单元，以及大数据的实现。最后，我们会有一个关于Hadoop的测试。大量的数据无法通过传统的方式进行存储、处理和分析，这就是所谓的大数据。Hadoop是一个以分布式方式管理大数据存储并并行处理的框架。现在，让我们深入研究这个视频，了解大数据和Hadoop。","categories":[{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"author":"vincent"},{"title":"Spring学习笔记(所有代码FROM SIKI学院)","slug":"Spring","date":"2021-03-16T06:49:57.000Z","updated":"2021-11-09T07:53:30.208Z","comments":true,"path":"Spring/","link":"","permalink":"https://github.com/Vincent990413/blog/Spring/","excerpt":"","text":"SSM框架系列之二 大管家SpringSpring是什么？Spring是于2003 年兴起的一个轻量级的Java 开源框架，它由Rod Johnson创建。传统J2EE应用的开发效率低，Spring作为开源的中间件，提供J2EE应用的各层的解决方案，Spring贯穿了表现层、业务层及持久层，而不是仅仅专注于某一层的方案。可以说Spring是企业应用开发的“一站式（full-stack）”选择。然而，Spring并不想取代那些已有的框架，而是与它们无缝地整合。简单来说，Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。 为什么要使用Spring？ 方便解耦，简化开发通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀框架Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts、Hibernate、MyBatis 、Hessian、Quartz）等的直接支持。 降低Java EE API的使用难度Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。 我能从这门课中学到什么？ 了解Spring框架、IOC、DI的概念； 掌握Spring框架搭建、配置与使用； 掌握Spring容器创建与对象管理； 掌握Spring xml配置式开发与注解开发； 掌握Spring AOP相关知识； 掌握SpringJDBC相关知识； 将Spring集成项目中进行测试； 开始学习Spring框架Part.1 Spring框架介绍与入门案例：1、搭建Spring HelloWorld项目 a)Spring下载：http://repo.spring.io/release/org/springframework/spring/ b)导包：（以下5个包称为基本包，根据你使用的版本可能还需导入log4j包，咱们学习的版本暂时无需导入） i.核心包：bean、context、core、expression； ii.日志包：apache.commons.logging c)引入约束：bean约束和引入主配置文件头； d)测试：将自定义对象由自己创建交由Spring管理； 2、SpringIDE - sts插件安装； a)下载地址：http://spring.io/tools/sts/all/ b)安装springIDE； Spring-IoC | DI概念介绍：（要实现IOC依赖DI的支持） IoC（Inversion of Control）：反转控制：将我们自己创建对象的工作交给Spring容器帮我们完成； DI（Dependency Injection）：依赖注入：将值通过配置的方式为变量初始化/赋值(注入)； c)注入方式：set方法注入、构造注入、字段注入(不推荐)； d)注入类型： i.值类型(value) – 八大基本数据类型； ii.引用类型(ref) – String、自定义对象； Part.2 Spring配置：1、Xml配置a)Bean元素：交由Spring管理的对象都要配置在bean标签中；i.Bean标签介绍和创建方式：空参构造、静态工厂、动态工厂；ii.Scope属性介绍：singleton、protoptype、request、session；iii.初始化方法Init-method和 销毁方法destroy-method介绍；b)属性注入：i.Set方法注入；ii.构造函数注入；iii.复杂类型注入：Array、List、Set、Map、Properties 2、Spring注解配置；a)导包和约束：基本包、aop包+context约束；b)将对象注册到容器内；c)用注解配置Scope属性；d)注解配置init-method与destroy-method；e)注解配置属性注入，值类型与引用类型； 3、Spring &amp; JUnit进行测试：a)导包： test包（依赖 aop包）；b)使用@RunWith注解创建spring容器；c)使用@ContextConfiguration读取spring配置文件；4、主配置文件的分包配置； Part.3 小结与练习：将Spring应用到servlet项目中1、使用servlet技术开发用户登陆功能；2、在项目中加入Spring框架i.将service、dao、dateSource交给Spring管理；ii.在web.xml中配置Spring监听器和读取配置文件； Part.4 Spring-aop：1、aop思想介绍（面向切面编程）：将纵向重复代码，横向抽取解决，简称：横切2、Spring中的aop：无需我们自己写动态代理的代码，spring可以将容器中管理对象生成动态代理对象，前提是我们对他进行一些设置；3、Spring-aop是基于动态代理的 – 优先选用JDKProxy动态代理；a)Proxy动态代理：被代理的对象必须要实现接口；b)Cglib动态代理：被代理的对象不能被final修饰，基于继承；4、Spring aop相关名词说明 – 详见 表-[Spring术语解释]；5、Spring aop配置：a)导包：i.基本包；ii.spring-aspects和spring-aop ；iii.aop联盟包 – aopalliance；iv.aop织入包 - aspectj.weaver；b)自定义通知，五种自定义通知类型：i.before 前置通知ii.after 最终通知（后置通知）iii.afterReturning 成功通知（后置通知）iv.afterThrowing 异常通知（后置通知）v.around 环绕通知c)配置applicationContext.xml： Part.5 Spring与Jdbc1、使用JdbcTemplate操作数据库；a)导包：新增jdbc、tx2、JdbcTemplate的增删改查操作；3、让Spring容器管理JdbcTemplate；4、继承JdbcDaoSupport甩开JdbcTemplate；5、在Spring中读取配置文件； Part.6 Spring中的aop事务1、事务相关知识：a)什么是事务：把多条数据库操作捆绑到一起执行，要么都成功，要么都失败；b)事务的原则ACID：i.原子性：事务包含的所有操作，要么全部成功，要么全部失败回滚，成功全部应用到数据库，失败不能对数据库有任何影响；ii.一致性：事务在执行前和执行后必须一致；例如A和B一共有100块钱，无论A、B之间如何转账，他们的钱始终相加都是100；iii.隔离性：多用户并发访问同一张表时，数据库为每一个用户开启新的事务，该事务不能被其他事务所影响，相互有隔离；iv.持久性：一个事务一旦提交，则对数据库中数据的改变是永久的，即便系统故障也不会丢失；c)并发可能引起的问题：i.脏读：一个事务读取到另一个事务未提交的数据；ii.不可重复读：一个事务读取到另一个事务已提交(Update操作)的数据，导致前后读取不一致；iii.幻读（虚读）：一个事务中读取到别的事务插入(Insert操作)的数据，导致前后读取不一致；d)事务的隔离级别：根据实际情况选择；i.Serializable串行化：可避免脏读、不可重复读和幻读；ii.Repeatable read可重复读：可避免脏读、不可重复读；（MySql默认值）iii.Read committed读已提交：可避免脏读；iv.Read uncommitted读未提交：任何情况都无法保证；2、Spring-aop事务-搭建环境；a)事务基本操作：打开事务、提交事务、回滚事务；b)Spring中利用接口来管理不同框架的事务操作；i.通过实现PlatformTransactionManager接口支持不同的框架完成各自的事务处理；ii.为不同平台提供对应的事务管理器的实现：JDBC&amp;Mybatis：DataSourceTransactionManager；…c)Spring-aop事务通过配置事务的隔离级别、事务传播行为、是否只读来操作；i.隔离级别：串行化、可重复读、读已提交、读未提交；ii.是否只读：1.true：不可改变数据库中的数据，查询操作推荐，2.false：可以改变数据库数据；iii.事务传播行为：事务方法嵌套调用的规则：xService.x(); -&gt; yService.y();1.REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置；2.REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务；3.SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行；4.NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起（暂停）；5.MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常；6.NEVER：以非事务方式执行，如果当前存在事务，则抛出异常；7.NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与REQUIRED类似的操作。 3、Spring-aop事务 – 从麻烦的事务代码中走出之xml配置版aop事务；a)使用经典的转账案例进行测试，准备数据：bean、service、dao；b)使用事务需要额外导入tx包和tx约束；c)配置事务核心管理器: DataSourceTransactionManager；d)配置事务通知 tx:Advice；e)配置aop；4、Spring-aop事务 – 从麻烦的事务代码中走出之注解版aop事务。 Part.7 Spring整合Mybatis加入事务操作数据库1、整合Mybatisa)导包：i.Spring：基本包、aop、aspects、jdbc、tx、test；ii.Mybatis：mybatis-3.4.6iii.整合包：mybatis-spring-1.3.2iv.三方包：1.aopalliance2.aspectj.weaver3.c3p0-0.9.5.24.mchange-commons-java-0.2.115.mysql-connector-java-5.1.46-bin6.ojdbc7b)创建项目结构(package)：bean、service、mapper、test；c)创建配置文件：sqlMapperConfig、applicaitonContext2、创建测试用例：使用Mapper扫描开发，转账；3、在service中加入事务：利用Spring-aop事务解决转账异常问题； Spring实例一 纯SpringapplicationContext.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd &quot;&gt;&lt;!-- name 是起一个名字，我们可以通过这个name来利用容器获取对象 name 可以使用特殊字符 name 可以重复 我们在实际开发中不推荐将多个对象名字命名为重复的--&gt; &lt;!-- id与name作用基本相同，单不推荐使用 不支持特殊字符，不能重复 --&gt;&lt;!-- class：是被管理对象的全包名，spring会通过这个包名来创建对象 --&gt;&lt;!-- request 在web环境下，如果scope属性为request 那么这个对象被创建出来 他的生命周期会与request请求一致--&gt;&lt;!-- session 同理 ，生命周期与session一致 --&gt;&lt;bean name=&quot;user&quot; class=&quot;com.sikiedu.bean.User&quot; lazy-init=&quot;default&quot; scope=&quot;prototype&quot; init-method=&quot;userInit&quot; destroy-method=&quot;userDestroy&quot;&gt; &lt;property name=&quot;u_id&quot; value=&quot;2&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 导入其他Spring的配置文件 --&gt;&lt;import resource=&quot;/applicationContext_Injection.xml&quot;/&gt;&lt;/beans&gt; User Bean对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class User &#123; private Integer u_id; private String u_username; private String u_password; public User(String u_username, Pet u_pet) &#123; System.out.println(&quot;方法1 String, Pet&quot;); this.u_username = u_username; this.u_pet = u_pet; &#125; public User(Integer u_username, Pet u_pet) &#123; System.out.println(&quot;方法2 Integer, Pet&quot;); this.u_username = u_username.toString(); this.u_pet = u_pet; &#125; public User(Pet u_pet, Integer u_username) &#123; System.out.println(&quot;方法3 Pet, Integer &quot;); this.u_username = u_username.toString(); this.u_pet = u_pet; &#125; //加入宠物字段 private Pet u_pet; public Pet getU_pet() &#123; return u_pet; &#125; public void setU_pet(Pet u_pet) &#123; this.u_pet = u_pet; &#125; public User() &#123; System.out.println(&quot;User 对象空参构造方法&quot;); &#125; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public void userInit() &#123; System.out.println(&quot;user init &quot;); &#125; public void userDestroy() &#123; System.out.println(&quot;user destroy&quot;); &#125; @Override public String toString() &#123; return &quot;User [u_id=&quot; + u_id + &quot;, u_username=&quot; + u_username + &quot;, u_password=&quot; + u_password + &quot;, u_pet=&quot; + u_pet + &quot;]&quot;; &#125;&#125; Test 测试方法主函数1234567891011121314151617181920212223242526272829303132333435363738394041package com.sikiedu.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.sikiedu.bean.User;public class HelloSpring &#123; //在之前项目中 new 对象是我们自己做的 @Test public void Test1() &#123; //User u = new User(); //u.setU_id(1); //System.out.println(u); &#125; //IOC的反转：创建对象这份工作由我们自己执行反转给spring帮我们执行； //IOC的控制：就是由spring帮我们负责创建销毁对象，掌控对象的生命周期等，我们在需要使用对象的时候跟Spring申请即可； //IOC是一种编程思想，也是一种新的设计模式，它需要DI（依赖注入）技术的支持； //spring是一个容器，它将帮我们管理对象 @Test public void Test2() &#123; //根据spring配置文件获取容器对象 //ApplicationContext 配置的所有bean都会在容器创建的时候被创建出来 //如果配置的bean较多，那么在创建容的时候，会产生内存过大的问题；这种情况在机器硬件性能较为落后的时候体现的比较明显； //延迟加载 true就是创建容器时不加载配置的bean对象，在获取的时候才创建； ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //通过getBean获取配置好的user对象（程序员向spring容器要对象） //User u = (User) ac.getBean(&quot;user&quot;); User u = ac.getBean(User.class); //System.out.println(u); &#125;&#125; Spring实例二 Spring+MybatisBean对象 Account.java1234567public class Account &#123; private Integer id; private String name; private Double money; ...忽略set，get，toString方法&#125; Mapper.java文件以及Mapper.xml文件AcountMapper.java123456789101112public interface AccountMapper &#123; //操作数据库扣款和加款 //扣款 void subMoney(Account pay); //加款 void addMoney(Account collect);&#125; AcountMapper.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.sikiedu.mapper.AccountMapper&quot;&gt; &lt;update id=&quot;subMoney&quot; parameterType=&quot;Account&quot;&gt; update account set money = money - #&#123;tranferMoney&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;update id=&quot;addMoney&quot; parameterType=&quot;Account&quot;&gt; update account set money = money + #&#123;tranferMoney&#125; where id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; Service层以及实现Impl类AccountService.java1234567public interface AccountService &#123; //转账方法 void updateTranferAccount();&#125; AccountServiceImpl.java123456789101112131415161718192021222324252627282930313233package com.sikiedu.service;import javax.annotation.Resource;import com.sikiedu.bean.Account;import com.sikiedu.mapper.AccountMapper;public class AccountServiceImpl implements AccountService &#123; @Resource(type=AccountMapper.class) private AccountMapper mapper; @Override public void updateTranferAccount() &#123; Double tranferMoney = 1000d; Account pay = new Account(); pay.setId(1); pay.setTranferMoney(tranferMoney); //先扣款 mapper.subMoney(pay); int a = 1/0; Account collect = new Account(); collect.setId(2); collect.setTranferMoney(tranferMoney); //加款 mapper.addMoney(collect); &#125;&#125; 主函数调用12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class MapperTest &#123; @Resource(name=&quot;accountService&quot;) private AccountService as; @Test public void Test1() &#123; as.updateTranferAccount(); &#125; &#125; Spring配置文件applicationContext.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt; &lt;!-- 读取配置文件 --&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt; &lt;!-- 配置 dataSource --&gt; &lt;!-- db.properties文件中分别有--&gt; &lt;!-- jdbc.driverClass=com.mysql.jdbc.Driver --&gt; &lt;!-- jdbc.jdbcUrl=jdbc:mysql://localhost:3306/ssm_spring --&gt; &lt;!-- jdbc.user=root --&gt; &lt;!-- jdbc.password=123 --&gt; &lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- mybatis --&gt; &lt;bean name=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:sqlMapConfig.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- mapper工厂 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.sikiedu.mapper&quot;/&gt; &lt;/bean&gt; &lt;!-- service --&gt; &lt;bean name=&quot;accountService&quot; class=&quot;com.sikiedu.service.AccountServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 需要事务核心管理器 --&gt; &lt;bean name=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;update*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.sikiedu.service.*ServiceImpl.*(..))&quot; id=&quot;txPc&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPc&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt;mapper工厂 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.sikiedu.mapper&quot;/&gt; &lt;/bean&gt; &lt;!-- service --&gt; &lt;bean name=&quot;accountService&quot; class=&quot;com.sikiedu.service.AccountServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 需要事务核心管理器 --&gt; &lt;bean name=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;update*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.sikiedu.service.*ServiceImpl.*(..))&quot; id=&quot;txPc&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPc&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; Mybatis配置文件sqlMapConfig.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.sikiedu.bean&quot;/&gt; &lt;/typeAliases&gt; &lt;/configuration&gt; Spring实例三 Spring+AOP自定义通知类 MyAdvice.java123456789101112131415161718192021222324252627282930public class MyAdvice &#123; //before 前置通知 在目标方法前调用 public void before() &#123; System.out.println(&quot;before&quot;); &#125; //after 最终通知（后置通知）在目标方法后调用，无论是否出现异常都会执行 finally public void after() &#123; System.out.println(&quot;after&quot;); &#125; //afterReturning 成功通知（后置通知）在目标方法执行后，并且执行成功，如果方法出现异常则不调用 public void afterReturning() &#123; System.out.println(&quot;afterReturning&quot;); &#125; //afterThrowing 异常通知（后置通知）在目标方法执行出现异常的时候才会调用 public void afterThrowing() &#123; System.out.println(&quot;afterThrowing&quot;); &#125; //around 环绕通知 需要我们手动调用目标方法，并且可以设置通知 public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;around before&quot;); Object proceed = pjp.proceed(); System.out.println(&quot;around after&quot;); return proceed; &#125;&#125; Service以及实现类implUserService.java12345678910public interface UserService &#123; //增 void save(); //删 void delete(); //改 void update(); //查 void find();&#125; UserServiceImpl.java12345678910111213141516171819public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; System.out.println(&quot;save&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;delete&quot;); //int a = 1/0; &#125; @Override public void update() &#123; System.out.println(&quot;update&quot;); &#125; @Override public void find() &#123; System.out.println(&quot;find&quot;); &#125;&#125; Spring配置文件 applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt; &lt;!-- 目标对象 --&gt; &lt;bean name=&quot;userService&quot; class=&quot;com.sikiedu.service.UserServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 通知对象 --&gt; &lt;bean name=&quot;myAdvice&quot; class=&quot;com.sikiedu.aop.MyAdvice&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!-- 切入点 expression 切入点表达式 可以配置要增强的方法 public void com.sikiedu.service.UserServiceImpl.save() * com.sikiedu.service.*ServiceImpl.*(..) id 就是唯一标识 --&gt; &lt;aop:pointcut expression=&quot;execution(* com.sikiedu.service.*ServiceImplabc.*(..))&quot; id=&quot;servicePc&quot;/&gt; &lt;!-- 切面 通知+切入点 --&gt; &lt;aop:aspect ref=&quot;myAdvice&quot;&gt; &lt;!-- 通知类型 --&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;servicePc&quot;/&gt; &lt;!-- 最终通知 后置通知 --&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;servicePc&quot;/&gt; &lt;!-- 成功通知 后置通知 --&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;servicePc&quot;/&gt; &lt;!-- 异常通知 后置通知 --&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;servicePc&quot;/&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;servicePc&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; 主函数测试方法AopTest.java1234567891011121314151617181920@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Resource(name=&quot;userService&quot;) UserService us; @Test public void Test1() &#123; UserServiceProxy usProxy = new UserServiceProxy(); UserService us = new UserServiceImpl(); UserService us_PowerUp = usProxy.getUserServiceProxy(us); us_PowerUp.find(); &#125; @Test public void Test2() &#123; us.delete(); &#125;&#125; UserServiceProxy.java12345678910111213141516171819202122232425262728293031323334353637383940package com.sikiedu.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import com.sikiedu.service.UserService;import com.sikiedu.service.UserServiceImpl;/** * UserService代理类 * @author Joey * */public class UserServiceProxy &#123; //UserServiceProxy //UserService public UserService getUserServiceProxy(UserService us) &#123; return (UserService) Proxy.newProxyInstance(UserServiceProxy.class.getClassLoader(), UserServiceImpl.class.getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //增强代码 System.out.println(&quot;开启事务&quot;); //调用原始方法 Object invoke = method.invoke(us, args); System.out.println(&quot;提交/回滚&quot;); return invoke; &#125; &#125;); &#125;&#125;","categories":[{"name":"SSM学习笔记","slug":"ssm学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/ssm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SSM学习笔记","slug":"ssm学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/ssm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"CSS学习笔记","slug":"CSS","date":"2021-03-15T09:08:23.000Z","updated":"2021-11-09T07:53:30.182Z","comments":true,"path":"CSS/","link":"","permalink":"https://github.com/Vincent990413/blog/CSS/","excerpt":"","text":"CSS教程什么是CSS？ CSS 指的是层叠样式表Cascading Style Sheets 样式通常存储在.css文件中 解决内容与样式定义的问题 CSS 标准语法通常，CSS规则由 选择器，若干条声明组成 比如： 1h1&#123; color:blur; font-size:12px; &#125; h1 是选择器，选择对应的标签。 花括号中是若干条声明，其中每个样式由属性：值构成。 CSS 注释1/*这是一个注释内容*/ CSS ID选择器与CLASS选择器ID选择器具有唯一性，CLASS类选择器将样式应用在同一类名的标签上 ID选择器123#id&#123; attr: value;&#125; Class选择器123.class&#123; attr: value;&#125; CSS 引入 外部样式表 我们一般在网页的头部&lt;head&gt;标签插入外部样式表 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;cssName.css&quot;&gt; 内部样式表 在网页的最底部区域，若文档需要特定的样式，则使用&lt;style&gt;标签定义样式 12345&lt;style&gt; p&#123; margin-left: 20px; &#125;&lt;/style&gt; 内联样式 对某个元素使用style属性，即可使用内联样式。 123&lt;p style=&quot; color:blue; background-color:red; &quot;&gt; 这是段落内容... 多重样式优先级：内联样式 &gt; 内部样式 &gt; 外部样式 CSS 背景 background-color 背景颜色 background-image 背景图片 background-repeat 背景图片是否、如何重复 background-attachment 背景图像是否固定或者随着页面滚动 background-position 背景图像的初始位置 CSS 文本 文本颜色 color 文本颜色一般指定为：十六进制值#FF0000 RGB值 RGB(255, 0, 0) 或者名称 red 文本对齐方式 text-align center代表居中显示，justify像报纸一样，左右边距对齐，每一行宽度相等，right右对齐。 文本修饰 text-decoration none代表不需要装饰，overline上划线，line-through删除线，underline下划线。 文本转换属性 text-transform uppercase全部大写，lowercase全部小写，capitalize首字母大写。 文本缩进 text-indent px像素点为基本单位 文本阴影 text-shadow 上右下左为基本方向，px像素点为基本单位。 1234p&#123; /* 表示上下为2px 左右为2px 颜色是#FF0000 */ text-shadow: 2px 2px #FF0000&#125; CSS 字体 多种字体设置 font-family 12/*如果前面的字体 不起作用 往后替换*/ font-family:&quot;Times New Roman&quot;, Times, serif; 字体样式 font-style normal代表正常，italic代表倾斜。 p.s. 在font-weight:bold;中设置字体为粗体效果 字体大小 font-size 123p&#123; font-size: 12px;&#125; CSS 链接1234a:link &#123;color:#000000;&#125; /* 未访问链接*/a:visited &#123;color:#00FF00;&#125; /* 已访问链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 鼠标点击时 */ a:hover必须跟在a:link与a:visited后面 a:active必须跟在a:hover后面 CSS 列表在HTML中，有两种类型的列表： 无序列表 ul 小黑点或正方块 有序列表 ol 数字或字母 123456789101112ul.a&#123; list-style-type: circle;&#125;ul.b&#123; list-style-type:square;&#125;ol.c&#123; list-style-type:upper-roman;&#125;ol.d&#123; list-style-type:lower-alpha;&#125; 如果要去掉列表的样式，可以使用 12345ul.demo:&#123; list-style-type:none; margin:0px; padding:0px;&#125; CSS 表格 表格边框 border: 1px solid black; 表格边框折叠成单一边框 border-collapse:collapse; 表格文字对齐 td{text-align:center} CSS 盒子模型所有HTML元素都可以看作是一个盒子，在CSS中，这些元素包括： 边距，边框，填充，实际内容 其中： Margin 外边距 Border 边框 Padding 内边距 Content 内容 CSS 边框 边框宽度 border-width 边框样式 border-style dotted 点线边框， dashed 虚线边框， solid实线边框。 边框颜色 border-color 还是那三种方法，RGB，name，十六进制 边框圆角 border-radius:50px; CSS 外边距 MarginCSS中的外边距指的是元素周围的空间 可单独调整元素的各种方向的外边距： 1234margin-top: 20px;margin-right: 20px;margin-bottom: 20px;margin-left: 20px; CSS 填充边距（内边距）与外边距一样，内边距也遵循：上右下左的样式顺序 分组与嵌套选择器有可能，我们想对多个元素或者区域使用同样的样式。 1234567p&#123; &#125;.className&#123; &#125; 用逗号将同样样式的元素写上 123p,.className&#123;&#125; 空格选择包裹在内的元素样式 为所有class=&quot;className&quot;元素内的p元素指定一个样式 123.className p&#123; &#125; 不用空格隔开，选择符合多种条件的元素 为所有class=&quot;className&quot;的p元素指定一个样式 123p.className&#123; &#125; 组合选择符 后代选择器 空格隔开 子元素选择器 &gt; 符号 相邻兄弟选择器 + 普通兄弟 ～ CSS 尺寸1234567p&#123; line-height: 50px; /*设置行高*/ min-height: 50px; max-height: 50px; min-width: 50px; min-height: 50px;&#125; Display与visibility隐藏一个元素可以通过两种方式：1. display:none; 2. visibility:hidden; visibility:hidden; 可以隐藏某个元素，但是这个隐藏的元素不会从DOM中脱离，仍会影响布局。 而display:none; 使得该元素不但被隐藏了，而且这个元素原本占用的空间也会从页面布局中消失。 CSS 块级元素与内联元素像 h1, p, div 这些都是块元素，占用了全部宽度，在前后都是换行符 而像span a 这种都是内联元素，不会占用全部宽度，不强制换行。 CSS 定位 static 默认定位 遵循正常的文档流对象 fixed 固定位置 即使窗口是滚动的它也不会移动 relative 相对位置 相对其DOM中正常的位置 absolute 绝对定位 相对于最近的已定位父元素 如果没有 就是相对于HTML cursor:pointer; 光标呈现手的形式 CSS 布局我们使用overflow来控制内容溢出元素框时，对应元素的显示情况。 overflow: visible; 内容不会修剪，会呈现在元素框之外。 hidden; 内容会被修剪，并且其余内容是不可见的。 scroll; 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto; 如果被修剪，会显示滚动条查看其余的内容。 CSS 浮动浮动会使得元素，向左或向右移动，剩下的元素也会重新排列； 这对布局图片时尤为重要。 水平浮动使得元素只能左右移动，如果图像是向右浮动，那么其余的文本流则会左环绕这张图像，浮动取值如下： left 元素向左浮动 right 元素向右浮动 none 元素不进行浮动 CSS浮动具有破坏性与包裹性的特点； 破坏性： 首先浮动破坏了行高，被浮动的元素不算行高；同时，浮动也引起了父元素坍塌 问题，即当父级元素全部浮动，并且未设置宽度和高度，那么它的高度将会缩减至零。 包裹性：浮动的元素将会以 inline-block 的方式显示，也就是说这些元素会与其他的元素共用一行。 如何通过添加属性来取消某一方向或所有方向的浮动呢？ 清除浮动： (clear: left|right|both) 清除左/右/两者浮动* 不允许左、右或者两者方向上的浮动 优先向上浮动 在position:absolute;前提下，z-index（z坐标）值越大 会越高覆盖在上面 CSS 变形CSS中的常用2D变换translate rotate scale 平面移位 translate平面移位是根据元素的坐标进行移动，从该位置进行移动，（x，y）表示 从该元素的位置起，水平移动x个像素点，垂直移动y个像素点 值得注意的是，由于坐标点在网页的左上角，因此可以通过负值往反方向平移。 实例：（平面移动元素） 1234div&#123; transform: translate(50px,100px); -webkit-transform: translate(50px,100px); /*针对于Safari和google浏览器*/ &#125; 旋转 rotaterotate(x)通过给定的度数x，让元素进行顺时针旋转，x可取负值以看做是逆时针旋转。 实例：（旋转元素） 1234div&#123; transform: rotate(50px,100px); -webkit-transform: rotate(50px,100px); /*针对于Safari和google浏览器*/ &#125; 缩放 scalescale（x,y) 使得变形后的宽度是之前的x倍，同时高度是之前的y倍。 实例：（缩放元素） 1234div&#123; transform: scale(2,3); -webkit-transform: scale(2,3); /*针对于Safari和google浏览器*/ &#125; CSS 动画 @keyframes 规则@keyframes 是动画规则，该规则内指定从现有的状态到指定的状态，这个状态间的改变过程就成为动画。 实例：制作div元素背景色，从红到黄持续4s（如何自定义动画规则，并将该规则绑定在元素身上） 12345678910111213141516@keyframes test &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125; &#125; @-webkit-keyframes test /*safari浏览器与google浏览器的版本号*/ &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125; &#125; div&#123; animation: test 4s; -webkit-animation: myfirst 5s; safari浏览器与google浏览器的版本号&#125; 动画常用属性及说明 属性名 值&amp;属性说明 animation-name 属性名字 animation-duration 动画持续时间，单位为秒 animation-delay 动画延迟时间，单位为秒 animation-iteration-count 动画循环次数，infine表示无限循环","categories":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"MongoDB学习笔记","slug":"MongoDB","date":"2021-03-15T08:54:23.000Z","updated":"2021-11-09T07:53:30.203Z","comments":true,"path":"MongoDB/","link":"","permalink":"https://github.com/Vincent990413/blog/MongoDB/","excerpt":"","text":"MongoDB 非关系数据库中的佼佼者 MongoDB，源自英语“Humongous”巨大的，当今也被广泛应用于大数据；Not only SQL也具体说出了非关系型数据库的心声，为什么呢？SQL是结构化，关系型的数据库，是数据库的当之无愧的老大：MySQL&amp;SQL Server。这两家数据库在这几年的发展一直高居不下。 但是，由于大数据的蓬勃发展，大量的信息开始趋于非关系化，非结构化，冗杂繁多的信息量使得数据库本身越来越复杂。 因此“关系型数据库”的规范化也越来越明显，同时也需要建立越来越多的表，关联，数据库。 作为NoSQL领军者的Redis和mongoDB后来者居上，MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。 同时是工作在集合和文档上的一种概念。 在处理大数据的冗杂性与结构繁多性，非关系型数据库MongoDB将成为数据库中的“秀儿”。 笔记前言数据库 DatabaseMongoDB中的Database是Collection的物理容器，也就是存储所有文件与集合的文件系统。 通常在一个MongoDB Server中存在有至少一个的Database。 集合 Collection集合（Collection）可以说是数据库紧接着的下一个重要的概念，同时也是MongoDB的重要的特点之一。 可以和RDBMS（Relational Database Management System）中的table等效。 也就是说它是许多文件数据的存储点。一个集合存在于数据库中。集合不强制执行模式。集合中的文档可以有不同的字段。 通常情况下，在一个集合中的所有文件都是类似或相关目的。 因此这也是NoSQL数据库的众多特点与优点之一。 文档 Document文档是一组键值对（Key-Value)。文档具有动态模式。 动态模式是指，在同一个集合的文件不必具有相同一组集合的文档字段或结构，并且相同的字段可以保持不同类型的数据。 创建数据库 use myDatabase;MongoDB建立一个新的数据库会使用到use database_name命令， 如果不存在该database的名字，将会重新创建一个。 否则会返回use的这个数据库：使用use命令创建数据库。 查看当前数据库 db;db命令查看当前所使用的数据库 12&gt; db;database test 查看所有数据库 show dbs;MongoDB查看当前所有数据库会使用到show dbs;命令: 1234&gt; show dbs;admin 0.00GB local 0.00GB test 0.00GB 在MongoDB中默认的数据库是test，若没有创建过任何数据库则会默认将数据保存在这个数据库中。 删除数据库 myDatabase.dropDatabase;MongoDB数据库删除一个当前已有的数据库，将会用到db.dropDatabase()命令。（MySQL中也是Drop） 前面已提到，如果未曾创建过任何数据库，那么将会删除默认的test的数据库； 12&gt; db.dropDatabase();&#123;&quot;dropped&quot; : &quot;test&quot;, &quot;ok&quot; : 1&#125; 创建集合 myDatabase.createCollection(&quot;myCol&quot;) 注意，我们需要先use这个数据库。 MongoDB建立一个新的集合会使用到db.createCollection(collection_name,collection_options)命令。 该命令中，collection_name是集合的名字，而collection_options是指定可选的配置属性： 如何在test数据库中创建集合1234&gt; use test switched to db test&gt; db.createCollection(&quot;runoob&quot;)&#123; &quot;ok&quot; : 1 &#125; 在直接引用未被创建的集合插入了一些文档数据后，MongoDB会自动帮你创建这个集合。 123&gt; db.mongo.insert(&#123;&quot;name:&quot; &quot;vincent&quot;&#125;);&gt; show collections;mongo 删除集合 db.myCol.drop();MongoDB中删除一个新的集合会使用到db.collection_name.drop()方法 如果成功删除选定的集合，该方法将会返回true，否则会返回false。 查看所有集合 show collections;首先可以使用show collections;查看当前所有已经存在的集合。 12345&gt; use test;switched to db test &gt; show collections; test local 接着删除该集合 12&gt; db.test.drop(); true 通过show collections再次查看数据库test中的所有集合. 12&gt; show collections;local 我们可以看出test集合已被我们删除。 插入文档MongoDB使用insert()或者save()方法向集合中插入文档， 就像关系型数据库中，向表中插入数据一样。 myDatabase.myCol.insert({Object});将数据插入到test集合中 1234db.test.insert(&#123; name: &#x27;mongodb&#x27;, writer: &#x27;vincent&#x27;&#125;); myDatabase.myCol.save({Object});如果不指定_id字段，方法类似insert()方法。如果指定，则会更新该_id的数据。 在3.2版本后，还有一下几种语法可用于插入文档： 12db.collection_name.inertOne();//插入一条数据db.collection_name.insertMany();//插入多条数据 MongoDB 更新文档相关命令与语法 MongoDB使用update()与save()更新文档，分别来看看这两个方法： update()方法 update()方法用于更新已存在的的文档，语法如下： db.test.update(query 查找方式,update 如何操作,); 实例 首先已知在test集合中，插入了name为vincent的数据。现在需要修改为rebecca： &gt;db.test.update(&#123;&#39;name&#39;:&#39;vincent&#39;&#125;,&#123;$set:&#123;&#39;name&#39;:&#39;rebecca&#39;&#125;&#125;); WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;) save()方法 save()方法通过传入的文档来替换已有文档。语法如下： db.test.save( document ) MongoDB 删除文档相关命令与语法 MongoDB中删除文档，将会使用到remove()方法，建议在删除之前，先查询一下想要删除的数据对象详情。 db.test.remove(query,&#123;justOne: boolean;&#125;); 其中，justOne是可选的，它代表是否只删除，多个符合删除条件中的，一条数据。如果选择只删除一条，那么置为1（true）。官方推荐使用deleteOne()和deleteMany()方法： 如删除集合下全部文档： 删除全部文档： db.test.deleteMany(&#123;&#125;) 删除 status 等于 B 的一个文档： db.test.deleteOne( &#123; status: &quot;B&quot; &#125; ) MongoDB 查询文档相关命令与语法 MongoDB查询文档并以非结构化形式显示的方法为find()命令。 而pretty()方法是以易读的形式显示。 db.test.find().pretty(); 各种RDBMS（关系型数据库管理系统）中where条件的表达方式： 等于：&#123;key:value&#125; 小于：&#123;key: &#123;$lt:value&#125;&#125; 大于：&#123;key: &#123;$gt:value&#125;&#125; 小于或等于：&#123;key: &#123;$lte:value&#125;&#125; 大于或等于：&#123;key: &#123;$gte:value&#125;&#125; 不等于：&#123;key: &#123;$ne:value&#125;&#125; MongoDB AND 和条件 MongoDB中的查询可以传入多个值，其中用，逗号隔开就行。 &gt; db.test.find(&#123;&quot;name&quot;:&quot;vincent&quot;, &quot;age&quot;:&quot;18&quot;&#125;).pretty(); MongoDB OR 或条件 MongoDB中的查询除了可以传入和条件，也可以传入OR条件 &gt; db.test.find(&#123;$or: [&#123;key1: value1&#125;, &#123;key2:value2&#125;]&#125;).pretty(); MongoDB $type 操作符相关命令与语法 常见数据类型： Integer 数值类型，在计算机中可以是32也可以是64位 String 字符串类型，UTF-8编码 Double 浮点类型 Boolean 布尔类型，true或者false Arrays 数组类型，可以存储多个相同类型的值 NULL 空值类型 Timestamp 时间戳 Code 存储JS代码于文档中 Regular expression 正则表达式 Binary data 存储二进制形式的数据 实例 假设已经插入数据名为Vincent的学生信息，其中name属性是以字符串形式存储的。 db.test.insert(&#123; name: &quot;Vincent&quot; &#125;); 现在想要访问name属性为string类型的数据，可以这么查询： db.test.find(&#123;&quot;title&quot;: &#123;$type : 2&#125;&#125;); db.test.find(&#123;&quot;title&quot; : &#123;$type : &#39;string&#39;&#125;&#125;); MongoDB Limit() 分页相关命令与语法 与RDB一样，MongoDB中查询也可以指定读取的数据记录数， 往该方法中写入一个参数，即读取的数量。 db.test.find().limit(num); 其中，如果不指定数量，那么将会显示所有符合条件的数据记录。 实例 假设已经存在三条数据，name属性分别为jack，vincent，rebecca。现在想要查询前两条： db.test.find(&#123;&quot;name&quot; : 1, _id : 0&#125;).limit(2); &#123;&quot;name&quot; : jack&#125; &#123;&quot;name&quot;: vincent&#125; MongoDB sort()相关命令与语法 在MySQL中，排序是通过ORDER BY来实现的，而在 MongoDB 中，排序是通过sort() 方法实现，并指定特定键的排序方式——升序或者降序（1或者-1）： db.test.find().sort(&#123;key_name: 1&#125;); 上述代码将会以key_name升序的结果排序展示。 skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 MongoDB 索引相关命令与语法 在处理非常大的数据时，可以想象，如果没有索引这样特殊的数据结构，查询时间将会花费几倍甚至几十倍的时间， 对网站的维护性能来说无疑是致命的。 createIndex() 创建索引 在MongoDB中使用该方法创建索引，同时可以传入参数，具体语法如下： &gt;db.test.createIndex(keys_name, options) Key_name 值为你要创建的索引字段，可以以逗号隔开作为复合索引，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。options 是可选的额外参数： 参数 类型 介绍 background boolean 指定以“后台”方式建立索引，因为建立索引将会阻塞其他数据库操作，为了不影响多个操作的同时进行，指定为后台方式创建。 unique boolean “唯一”索引，默认值为false，开启则置为true name string 为索引指定一个名称，通过连接索引的字段名和排序顺序生成一个索引名称。 实例 创建一个以name和age属性并且升序的索引： db.test.createIndex(&#123;&quot;name&quot; : 1, &quot;age&quot; : 1&#125;); 常见关于索引的操作：1、查看集合索引db.col.getIndexes() 2、查看集合索引大小db.col.totalIndexSize() 3、删除集合所有索引db.col.dropIndexes() 4、删除集合指定索引db.col.dropIndex(&quot;索引名称&quot;) MongoDB 聚合相关命令与语法 aggregate() 方法 聚合一般用于统计数据，例如求最大值、平均数求和等等； &gt; db.test.aggregate(operation); 假设集合中存在name为vincent、jack和rebecca的数据记录。 并且所学科目名subject相应为： vincent所属分别为：《计算机1》、《计算机2》、《计算机3》， jack所属分别为：《文学1》、《文学2》， rebecca所属分别为：《经济史1》、《经济史2》、《经济史3》、《经济史4》 现在需要得到每个人所阅读的科目总数，可以如下： &gt; db.test.aggregate([&#123;$group : &#123;_id : &quot;$name&quot;, subject : &#123;$sum : 1&#125;&#125;&#125;]) &quot;result&quot; : [ &quot;_id&quot; : &quot;runoob.com&quot;, &quot;num_tutorial&quot; : 2 &#125;, &#123; &quot;_id&quot; : &quot;Neo4j&quot;, &quot;num_tutorial&quot; : 1 &#125; ], &quot;ok&quot; : 1 &#125; 相当于SQL语句： select name, count(*) from mycol group by name 常见的聚合表达式： $sum 计算数据记录条数的总和 $avg 计算平均值 $min 计算对应组的最小值 $max 计算对应组的最大值","categories":[{"name":"非关系型数据库学习笔记","slug":"非关系型数据库学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"非关系型数据库学习笔记","slug":"非关系型数据库学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"HTML学习笔记","slug":"HTML","date":"2021-03-15T08:38:23.000Z","updated":"2021-11-09T07:53:30.189Z","comments":true,"path":"HTML/","link":"","permalink":"https://github.com/Vincent990413/blog/HTML/","excerpt":"","text":"HTMLHyperText Markup Language &nbsp;&nbsp;&nbsp;&nbsp; 前端开发是创建Web页面或app等前端界面呈现给用户的过程， 通过HTML，CSS及JavaScript以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互。 它从网页制作演变而来，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物， 早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主。随着互联网技术的发展和HTML5、CSS3的应用， 现代网页更加美观，交互效果显著，功能更加强大。 移动互联网带来了大量高性能的移动终端设备以及快速的无线网络，HTML5，node.jS的广泛应用，各类框架类库层出不穷。 ——百度百科 笔记前言 一：HTML &nbsp;&nbsp;&nbsp;&nbsp;首先我们需要知道什么是HTML，所谓HTML，就是Hyper Text Markup Language（超文本标记语言）， 虽然它是一种语言，但是千万不要认为HTML是编程语言，它不过是一种标记语言罢了。而超文本，则指的是“超越”文本，比如图 片、超链接、音乐甚至程序；其中包括“头部”与“主体”部分。分别提供了网页信息与具体内容。 二：CSS &nbsp;&nbsp;&nbsp;&nbsp; CSS的全称是：Cascading Style Sheets（层叠样式表），就如同英文表达的那样，它的工作主要是静态地修饰网页，做出你想要的freestyle； 它有着这些特点： 1.丰富的样式定义 2.易于使用与修改 3.多页面应用 三：JavaScript &nbsp;&nbsp;&nbsp;&nbsp; 与HTML、CSS不同的是，JavaScript（后文将直呼JS）才是一门真正的编程语言，也是一门直译式语言。用于动态地对网页中的DOM对象进行修改（增删改查）。 它的主要特点： 1.是一种解释性语言，不需要像C语言那种语言，需要预编译。 2.可以直接嵌入至HTML页面中，也可以将结构与功能进行分离（外部JS） 3.跨平台特性，因为由浏览器支持，所以一处运行，多处使用。 笔记正文 HTML 排版基础 HTML 文档结构 在标准的html网页中，我们可以看到这些关键字（标签） &lt;!DOCTYPE&gt; //代表文档类型 &lt;html&gt; //html文档内容 &lt;head&gt; //网站的头部 &lt;body&gt; //网站的主体部分 HTML 标题h1 - h6 html中的标题通过标签&lt;h1&gt;&lt;/h1&gt;到&lt;h6&gt;&lt;/h6&gt;，字体大小 逐渐变小而实现的。h6标题是最小的，继续添加h7将无效。 &lt;h1&gt; h1标题 &lt;/h1&gt; &lt;h2&gt; h2标题 &lt;/h2&gt; &lt;h3&gt; h3标题 &lt;/h3&gt; ... &lt;h6&gt; h6标题 &lt;/h6&gt; HTML 段落p html中的段落通过标签&lt;p&gt;&lt;/p&gt;实现的。值得注意的是，在p的尾标签结束后，将会自动换行。 这一般也用于段落与段落之间的美化与排版。 HTML 超链接a 有时我们需要网页与网页之间的跳转，可以用到其中一个方法：通过标签&lt;a&gt;&lt;/a&gt;实现。 可以增加属性href指定链接的地址 &lt;a href=\"http://www.baidu.com\"&gt; 点我进入百度 &lt;/a&gt; HTML 图像img 有时我们需要在网页中增加图片美化文档，通过标签&lt;img/&gt;实现。 可以增加属性src指定图像的来源，可以使用绝对路径或者相对路径： 相对路径： &nbsp;&nbsp;&nbsp;&nbsp; 相对路径是指目标相对于当前文件的路径，内部网站设计中多采用这样的结构，以便于寻找资源。 其常用方法如下： ./ : 代表文件所在的目录，通常可以省略不写。 ../ : 代表文件所在的父级目录。 / :代表文件所在的根目录 绝对路径是指完整的网址，比如超链接中的“https://www.baidu.com”这个网址，多用于外部资源url的 引入。开发中应避免在内部网站中使用绝对路径，除了不易维护，也会出现因改变目录地址而无法找到的错误。 &lt;a href=\"http://www.baidu.com\"&gt; 点我进入百度 &lt;/a&gt; 字符实体 &nbsp;&nbsp;&nbsp;&nbsp; 当你在编译器或者文本中敲写html代码时，也许你会发现这样一个有趣的问题：敲下enter键换到下一行继续写后， 网页中的内容，除非超出容器外，否则不会换行；当你想要打出\"&lt;\" 或者\"&gt;\"时，也许会影响到整个HTML文档的格式等等情况。 &nbsp;&nbsp;&nbsp;&nbsp; 这时你需要到一些常见的字符实体或者转义字符，或者相关的标签： 字符 具体含义 br单标签 换行 &+nbsp;(去掉中间的+号) 空格 &+lt; 小于 &+gt; 大于 HTML 表格 HTML 表格结构 通常我们看到的HTML中的表格与excel中的表格，结构上没有太大的区别： 表格由table标签来定义。而每个表格中由行与列构成，即 tr与td构成，且td标签需要内嵌于tr标签中，即若干个列属于同一行 每个td：table data（表格数据）中，可以放入图片、段落、表单甚至表格。 注意：我们在td中写数据，请勿写在tr中td外！ 实例 创建一个一行两列的默认表格： &lt;table&gt; &lt;tr&gt; &lt;td&gt;第一行第一列 &lt;/td&gt; &lt;td&gt;第一行第二列 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; HTML 表格重要属性与其他标签 边框 由于默认的表格是不带有边框的，可能在排版上不那么正规。 因此，引入border属性，其值从1开始递增。 &nbsp;&nbsp;&nbsp;&nbsp; 带有边框的表格： &lt;table border = \"1\" &gt; &lt;tr&gt; &lt;td&gt;第一行第一列 &lt;/td&gt; &lt;td&gt;第一行第二列 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 表格的表头标签th 通常我们需要提示表头来提示用户，该表格的内容或者信息概要， 此时可能会需要表头，类似网站的head头部信息，大多数浏览器会显示为粗体并且居中的文本。 表格的标题标签caption 表格的标题会被显示在，表格的正上方，且不会被边框环绕。 &lt;caption&gt;标题&lt;/caption&gt; &lt;table border = \"1\" &gt; &lt;tr&gt; &lt;td&gt;第一行第一列 &lt;/td&gt; &lt;td&gt;第一行第二列 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; HTML 列表 无序列表ul>li 对于列表，我们可以联想到家里的购物清单。也许是有序，也许是无序。因此我们引入，列表的概念： 无序列表unordered list的语法如下： &lt;ul&gt; &lt;li&gt; 数据 &lt;/li&gt; &lt;/ul&gt; 默认情况下，此列表的数据前会有典型的小黑圆圈标记。 有序列表ol>li 有序列表ordered list的语法如下： &lt;ol&gt; &lt;li&gt; 数据 &lt;/li&gt; &lt;/ol&gt; 默认情况下，此列表的数据前会有数字标记。 我们可以通过更改属性type来更改有序列表数据展示的样式： 可以是\"A\" \"I\" \"i\" \"1\"分别代表不同的排列顺序！ HTML 区块 块级元素div 我们将div元素认定为块级元素，是因为它具有以下几个特点： 1.总是在新行开始内容 2.高度、行高、内外边距均可调整（具体内容将会在CSS中讲到） 3.宽度默认为它容器的100% 语法如下： &lt;div&gt; 其他元素或者内容 &lt;/div&gt; 行内元素span 我们将span元素认定为内联元素（行内元素），是因为它具有以下几个特点： 1.不会在新行开始 2.高度等属性不可改变 3.宽度一般就为容器中的文字或者图片的高度 4.只能容纳文本等行内元素 语法如下： &lt;span&gt; 容器中的内容 &lt;/span&gt; HTML 表单 表单输入form>input 表单form 去应聘的时候，工作人员往往会给你一张表单让你填写你的个人信息，包括姓名，年龄，兴趣爱好，个人介绍等。 表单的语法如下： &lt;form&gt; 填写input各类型的元素 &lt;/form&gt; 表单有如下重要属性： 一：处理程序属性action：URL（表单提交的地址） 二：表单名称name：不同的表单尽量使用不同的名字，避免混淆 三：提交方法，GET与POST： 首先get是默认的提交方式，它会将表单中的输入元素等相关参数，附在网页的URL后； 因此我们可以看出，对于比较敏感的数据，它是不太安全的。 但是，它是主动推送数据给服务器的，因此比起post，它更快速。 四：编码属性：（multipart/form-data）MIME多用途网络邮件 顶级媒体类型/子类型（后缀名） text：文本 application：应用 multipart：多部分媒体 audio：音频文件 image：图片 message：消息 输入input 输入元素的语法如下： &lt;input type = \"input_type\"&gt; 输入元素被包含在form中，常见的元素类型type被列举如下： 文本域text 语法如下： &lt;form&gt; &lt;input type = \"text\"&gt; &lt;/form&gt; 我们通常在文本域中填写可见的文字或者数字，其默认长度为20字符， 密码域password 密码字符不会明码显示（废话），将会以黑色星点或者圆点代替。语法如下： &lt;form&gt; &lt;input type = \"password\"&gt; &lt;/form&gt; 单选框radio 如果限选一个选项，我们需要用单选框，注意，请给他们赋予 相同的name属性；请 将给用户看的选项与你input输入元素的value属性值相等。比如： 吧、 &lt;form&gt; &lt;input type = \"radio\" name = \"sex\" value = \"男\"&gt;男 &lt;input type = \"radio\" name = \"sex\" value = \"女\"&gt;女 &lt;/form&gt; 多选框checkbox 从若干个选项中选取一个或多个，我们需要用多选框，仍旧建议使用相同的name，并且value值与显示出来的值相同： &lt;form&gt; &lt;input type = \"checkbox\" name = \"vehicle\" value = \"轿车\"&gt;轿车 &lt;input type = \"checkbox\" name = \"vehicle\" value = \"自行车\"&gt;自行车 &lt;/form&gt; 提交按钮submit 填写完所有服务器需要的信息后，我们可以添加提交按钮，表示信息准备提交至服务器: &lt;form&gt; &lt;input type = \"submit\" value = \"提交\"&gt;提交 &lt;/form&gt; 请注意 提交按钮submit与普通按钮button的区别： 1.一般submit用于表单提交；而button仅仅是一个按钮，只要绑定不同的事件，就能实现不同的功能。 2.submit与button修改按钮上的文字的方式也不同，对于submit，有自己的属性value， 我们用JS捕获到该DOM对象后，通过修改这个属性值来修改文字；button通过直接修改innerHTML值来修改其按钮上的文本值。 HTML 颜色 HTML中的颜色十六进制或者RGB（Red，Green，Blue） HTML中的颜色可以由十六进制来定义，这个符号由相应RGB的值来确定；每个值的区间是[0(#00),255(#FF)] 下面列举常用颜色的RGB值： #000000 / rgb(0,0,0)： 黑色 #FF0000 / rgb(255,0,0)： 红色 #00FF00 / rgb(0,255,0)： 绿色 #0000FF / rgb(0,0,255)： 蓝色 #FFFFFF / rgb(255,255,255): 白色","categories":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"vincent"},{"title":"翻译作品-替换“我不知道”的八种更好的回答","slug":"翻译作品-回答我不知道的八种方式","date":"2021-03-15T02:04:00.000Z","updated":"2021-11-09T07:53:30.223Z","comments":true,"path":"翻译作品-回答我不知道的八种方式/","link":"","permalink":"https://github.com/Vincent990413/blog/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81-%E5%9B%9E%E7%AD%94%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< Improve your Vocabulary: 8 better ways to say “I don’t know”提高你的词汇量:8种更好的表达“我不知道”的方法When someone asks you something and you don’t know the answer, it’s okay to admit that you don’t know. But you can respond with more than “I don’t know” – you can use richer vocabulary, you can be more polite, or you can offer to help. In this lesson, I’ll give you 8 ways you can respond in English when you don’t know the answer. You’ll learn expressions such as “I’d be happy to...”, “Before I can answer...”, “Honestly, I have no idea”, “If I knew, I would...”, and more. Start having better English conversations by learning and using these expressions. Take the quiz to make sure you understood the lesson! https://www.engvid.com/ 当别人问你什么而你不知道答案的时候，承认自己不知道没什么大不了的。但是你可以用比“我不知道”更多的回答——你可以使用更丰富的词汇，你可以更有礼貌，或者你可以主动提供帮助。这节课，我将告诉你不知道答案时8种用英语回答的方法。你会学到诸如“我很乐意……”，“在我能回答……之前”，“老实说，我不知道”，“如果我知道，我就会……”等等的表达。通过学习和使用这些表达来开始更好的英语对话。做个小测验，确保你理解了课文!https://www.engvid.com/","categories":[{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"author":"vincent"},{"title":"翻译作品_在法国的美国小伙儿","slug":"翻译作品-在法国的美国小伙儿","date":"2021-03-13T06:50:40.000Z","updated":"2021-11-09T07:53:30.223Z","comments":true,"path":"翻译作品-在法国的美国小伙儿/","link":"","permalink":"https://github.com/Vincent990413/blog/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81-%E5%9C%A8%E6%B3%95%E5%9B%BD%E7%9A%84%E7%BE%8E%E5%9B%BD%E5%B0%8F%E4%BC%99%E5%84%BF/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< 该视频由YouTube博主讲述如何作为一名美国人 融入法国的生活第一弹： 第二弹： 第三弹：","categories":[{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"author":"vincent"},{"title":"PYTHON 从入门到精通-Get 与 Post 请求","slug":"PYTHON 从入门到精通-利用BeautifulSoup Get 与 Post 请求","date":"2021-03-11T11:37:23.000Z","updated":"2021-11-09T07:53:30.205Z","comments":true,"path":"PYTHON 从入门到精通-利用BeautifulSoup Get 与 Post 请求/","link":"","permalink":"https://github.com/Vincent990413/blog/PYTHON%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E5%88%A9%E7%94%A8BeautifulSoup%20Get%20%E4%B8%8E%20Post%20%E8%AF%B7%E6%B1%82/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< 实现Get请求 模拟百度搜索1234567891011import requestsimport webbrowserif __name__ == &#x27;__main__&#x27;: # 参数用字典的方式 输入相应的key-value值 param = &#123;&#x27;wd&#x27;: input(&#x27;请输入你要搜索的内容：&#x27;)&#125; # 模拟实现百度搜索 其中地址栏只需要wd参数 后面跟的是 搜索的内容 req = requests.get(&#x27;http://www.baidu.com/s&#x27;, params=param) # 最后利用内嵌的浏览器 打开 webbrowser.open(req.url) 利用Post 请求登录某页面12345678910111213import requestsimport webbrowserif __name__ == &#x27;__main__&#x27;: # 给到服务器要的参数 data = &#123;&#x27;firstname&#x27;: &#x27;vincent&#x27;, &#x27;lastname&#x27;: &#x27;he&#x27;&#125; # 去目标action页面(注意 不总是登录填写账号密码的页面） Network中的FormData查看需要什么参数 response = requests.post(&#x27;https://pythonscraping.com/pages/files/processing.php&#x27;, data=data) print(response.text) 利用Cookies来保持登录状态123456789101112131415161718import requestsimport webbrowserif __name__ == &#x27;__main__&#x27;: # 给到服务器要的参数 data = &#123;&#x27;username&#x27;: &#x27;vincent&#x27;, &#x27;password&#x27;: &#x27;password&#x27;&#125; # 去目标action页面(注意 不总是登录填写账号密码的页面） Network中的FormData查看需要什么参数 response = requests.post(&#x27;http://pythonscraping.com/pages/cookies/welcome.php&#x27;, data=data) # 在登录成功后 拿到相应的cookies值 可以直接用get去到相应的其他页面（这个页面需要登录之后 才能查看的） 不用再次登录！！！ response = requests.get(&#x27;http://pythonscraping.com/pages/cookies/profile.php&#x27;, cookies=response.cookies) print(response.text)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"PYTHON","slug":"python","permalink":"https://github.com/Vincent990413/blog/tags/python/"}],"author":"vincent"},{"title":"PYTHON 从入门到精通-利用BeautifulSoup 如何爬取网站数据","slug":"PYTHON 从入门到精通-利用BeautifulSoup 如何爬取网站数据","date":"2021-03-11T11:37:23.000Z","updated":"2021-11-09T07:53:30.206Z","comments":true,"path":"PYTHON 从入门到精通-利用BeautifulSoup 如何爬取网站数据/","link":"","permalink":"https://github.com/Vincent990413/blog/PYTHON%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E5%88%A9%E7%94%A8BeautifulSoup%20%E5%A6%82%E4%BD%95%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*- coding:UTF-8 -*-# 模拟定义一个完整的HTML源码from attr import attrshtml = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&#x27;title&#x27; name=&#x27;title_name&#x27;&gt;&lt;b&gt;once upon a time&lt;/b&gt;&lt;/p&gt;&lt;p class=&#x27;title1&#x27; name=&#x27;title_name1&#x27;&gt;&lt;b&gt;once upon a time1&lt;/b&gt;&lt;/p&gt;&lt;p class=&#x27;title2&#x27; value=&#x27;123&#x27; name=&#x27;title_name2&#x27;&gt;&lt;b&gt;once upon a time2&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#x27;lxml&#x27;) # lxml是解析方式 html 是模拟的页面# 标准缩进方式# soup.prettify()title = soup.titleprint(title.text) # 选择标签为title的text内容（String属性也可以） 只选择第一个print()head = soup.find(&#x27;head&#x27;)print(head.title.text) # title是head的子节点，那么可以通过逗号 直接索引到title并打印该标签中的内容print()p_one = soup.find(&#x27;p&#x27;) # find函数 一样的做法 p 标签内容 只选择第一个print(p_one.text)print()p_one_class = soup.find(class_=&#x27;title&#x27;) # find函数 类名寻找器 只选择第一个print(p_one_class)print()p_s = soup.find_all(&#x27;p&#x27;) # find_all 也是查找 不过返回的是列表！！！应用for循环迭代其中的元素for i, item in enumerate(p_s): print(i, item.text)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"PYTHON","slug":"python","permalink":"https://github.com/Vincent990413/blog/tags/python/"}],"author":"vincent"},{"title":"PYTHON 从入门到精通-利用selenium 如何爬取网站数据","slug":"PYTHON 从入门到精通-利用selenium 如何爬取网站数据","date":"2021-03-11T11:37:23.000Z","updated":"2021-11-09T07:53:30.206Z","comments":true,"path":"PYTHON 从入门到精通-利用selenium 如何爬取网站数据/","link":"","permalink":"https://github.com/Vincent990413/blog/PYTHON%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E5%88%A9%E7%94%A8selenium%20%E5%A6%82%E4%BD%95%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE/","excerpt":"","text":"一、爬取豆瓣电影td数据代码1234567891011121314151617181920212223242526#-*- coding:UTF-8 -*-# selenium对豆瓣页面进行操作import urllib.requestfrom selenium import webdriverdef print_hi(name): # Use a breakpoint in the code line below to debug your script. print(f&#x27;Hi, &#123;name&#125;&#x27;) # Press Ctrl+F8 to toggle the breakpoint.# Press the green button in the gutter to run the script.#Main函数入口if __name__ == &#x27;__main__&#x27;: browser = webdriver.Chrome() browser.get(&#x27;https://movie.douban.com/&#x27;) tagname = browser.find_elements_by_tag_name(&#x27;td&#x27;) for item in tagname: try: int(item.text) # 这一句出现异常时 except Exception: print(item.text) # 将会走这一步 二、爬取豆瓣电影-轮播图中数据的href数据12345678910111213141516171819202122232425262728#找到相应的轮播图数据的href# This is a sample Python script.# Press Shift+F10 to execute it or replace it with your code.# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.import urllib.requestfrom selenium import webdriverdef print_hi(name): # Use a breakpoint in the code line below to debug your script. print(f&#x27;Hi, &#123;name&#125;&#x27;) # Press Ctrl+F8 to toggle the breakpoint.# Press the green button in the gutter to run the script.#Main函数入口if __name__ == &#x27;__main__&#x27;: browser = webdriver.Chrome() browser.get(&#x27;https://movie.douban.com/&#x27;) tagnames = browser.find_elements_by_class_name(&#x27;list-wp&#x27;) # 找到class为cover-wp所在的标签 for container in tagnames: items = container.find_elements_by_class_name(&#x27;slide-page&#x27;) # 所有的slide-page for item in items: tag = item.find_elements_by_tag_name(&#x27;a&#x27;) # 找到每一个slide-page的a标签 print(len(tag)) for Tag in tag: # 每一个a标签的 href属性 print(Tag.get_property(&#x27;href&#x27;))# See PyCharm help at https://www.jetbrains.com/help/pycharm/","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"PYTHON","slug":"python","permalink":"https://github.com/Vincent990413/blog/tags/python/"}],"author":"vincent"},{"title":"PYTHON 从入门到精通-类Class","slug":"PYTHON 从入门到精通-类Class","date":"2021-03-11T11:37:23.000Z","updated":"2021-11-09T07:53:30.206Z","comments":true,"path":"PYTHON 从入门到精通-类Class/","link":"","permalink":"https://github.com/Vincent990413/blog/PYTHON%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E7%B1%BBClass/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< 类的定义：12345678910111213141516171819202122232425262728class CLASS_NAME: attr1 = 0 # 构造函数__init__ def __init__(self, param1, param2...): # self相当于C++中的this对象 self.param1 = param1 ... # 成员函数 将变量attr1加一 def fun(self): attr1 += 1 # 类方法 调用时直接用CLASSNAME.set_attr_for_all @classmethod def set_attr_for_all(cls, attr1): cls.attr1 = attr1 # 静态方法 一般写不涉及到某个对象 或者类的相关属性或者方法 @staticmethod def hello_class(): print(&#x27;Hello World!&#x27;)# 创建并初始化对象class1 = CLASS_NAME()# class1.xxx 代表对象实例的变量 或者 方法# CLASS_NAME.xxx 代表类的变量或者方法 类的继承 比如有一个类：Human，另外有一个Student类 现在用Student类继承于Human 1234# Human类的构造函数：class Human: def __init__(self, name): self.name = name 12345678# Student比Human类多一个属性studentnum # 而从父类继承来的name属性 可以通过父类的构造方法进行构造class Student(Human): def __init__(self, name, studentnum): # 利用父类的构造方法 构造name属性 super.class().__init__(name) self.studentnum = studentnum","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"PYTHON","slug":"python","permalink":"https://github.com/Vincent990413/blog/tags/python/"}],"author":"vincent"},{"title":"从零基础创建Springboot_Thymelear_layui项目","slug":"从零基础创建Springboot + Thymelear + layui项目","date":"2021-03-11T11:37:23.000Z","updated":"2021-11-09T07:53:30.217Z","comments":true,"path":"从零基础创建Springboot + Thymelear + layui项目/","link":"","permalink":"https://github.com/Vincent990413/blog/%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%9B%E5%BB%BASpringboot%20+%20Thymelear%20+%20layui%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"第一步：打开idea创建项目直接点next下一步； next点完，依赖后面再添加。 依赖删除，重新添加 ①：spring-boot-starter-web ②：spring-boot-starter-thymeleaf 创建默认页面static和templates文件夹1、其中 static 放除pages以外的2、templates 放pages（数据来自ok-admin-master) 百度网盘有 存入之后，项目结构图为（记得加入index.html) 首先测试主页，编写controller访问index（涉及SpringMVC）注意，启动时可能会报相应Test错误（由于改动了相应的依赖） 只需要删除相应Test文件即可 编写相应的Controller 写页面跳转即可 前端若iframe嵌套页面为404则比如：iframe标签中，src属性为welcome那么写一个Controller RequestMapping参数为&quot;welcome&quot; 直接返回相应的前端页面即可 避免404看图： 一级菜单与二级菜单 在menu.json中大致页面如下： localhost:8080 或者 localhost:8080/index （默认欢迎页面为Index）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"SpringBoot","slug":"springboot","permalink":"https://github.com/Vincent990413/blog/tags/springboot/"}],"author":"vincent"},{"title":"不会吧？都2021年了，还有人觉得考研英语简单！？","slug":"不会吧考研英语","date":"2021-03-11T11:37:23.000Z","updated":"2021-11-09T07:53:30.216Z","comments":true,"path":"不会吧考研英语/","link":"","permalink":"https://github.com/Vincent990413/blog/%E4%B8%8D%E4%BC%9A%E5%90%A7%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD/","excerpt":"","text":".back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;} .back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);} >返回顶部< 刚过线低分学长考研英语做题方法分享（全是干货）你还在等什么？等我吗？：作者前言&nbsp;&nbsp;&nbsp;&nbsp;考研英语分为英语一与英语二，其中英语一多为学术型研究生而准备，而英语二多为专业型研究生而准备。本文旨在总结考研一路走来自己对英语二学科的重要总结以及经验之谈，比较适合在经过一段真题复习之后抓重点、查漏补缺！希望阅读到本文的你能够有所得。Respect！ 一、完形填空 Use of English &nbsp;&nbsp;&nbsp;&nbsp;完形填空，一直都是大家不重视的科目，毕竟所占的分数不多，才 “十分”，但是非常重要！（请大家务必重视完形的做题方法）万事开头难，完形也不例外。 Without further ado 废话不多说，我们直接进入正题~ &nbsp;&nbsp;&nbsp;&nbsp;以下笔记以及方法论，自己总结归纳众多名师（其实没怎么看他们本人的课，都在各个网络渠道微博，知乎，哔哩哔哩等看到的方法哈哈哈） 完形填空我建议同学去读读 刘晓燕老师的《真题就这么点儿事》 与有道的赵楠楠老师的相关教学，正文开始！ 1.读懂前两句/段，即读懂文章的 中心主旨句 ！ 读懂文章所围绕写的中心，同时联系作者自身的态度！这一步能否做到，能决定你是否读懂文章大致走向（**同时也是阅读理解做题步骤中，关键的一步！后话。**） 例如：（2015年英语二文章）==In our contemporary culture== , the prospect of communicating with-or even looking at- a stranger is virtually unberable. ==Everyone== around us seems to ==agree== by the way they cling to their phones, even without a __ on a subway. 第一句指出，当代文化（=大众 everyone）认为，与陌生人交谈，甚至看向陌生人都是不可忍受的， // 而作者的观点， 大多“反对”大众文化。 我们看看第二段怎莫硕呢： ==It&#39;s a sad reality== ---our desire to avoid interacting with other human beings---because there&#39;s___to be gained from talking to the stranger standing by you. &quot;sad&quot;表明作者对此观点表示批判（小技巧：附有鲜明态度的形容词，一般很好地体现出作者的态度），同时==表明自己的观点（与大众相反即可）：看向陌生人，与陌生人交谈其实没那么难以忍受。== 在知道作者的观点与态度或者文章的主旨句之后，再去斟酌每个选项，也许可以从更宏观的方面去把握更正确更优的答案。 我们再来看个例子：（2013年英语二文章） Given the advantages of electronic money,==you might think== that we would move quickly to the cashless society in which all payments are made electronically. ___, a ==true== cashless society ==is probably not around the corner==. 如出一辙，you might think = 大众的观点，即认为很快会进入“无纸化社会”，而后提到真正的无纸化社会也许还没有到来，明显提出自己的观点。因此，全文的选项，选择时都应该按照 无纸化不会到来 这个大方向来做。 2.具体填空处前后“词语”的逻辑关系 例如：（2018年英语二文章） The drive to discover is deeply rooted in humans, much the same as the basic drives for __ or shelter. 该文章主要说明：为什么人们总是在网上浏览很负能量的评论，做一些明显很令人痛苦的事情。因为人们习惯去解决“不确定”，可能明知到事情的答案，还是想满足自己内心的好奇心。 而聚焦到问题，说人类探索未知的渴求，如同探求__或避难所（庇护）一样，或者所连接的前后意思相近 A.Food （食物） B.pay（工资） C.Marriage（婚姻） D.schooling（学校教育）根据排除法和常识，我们可以确定答案选 A，与 shelter 避难所含义相近。 譬如active 与 alive 也是具有相同意义的词语。 若文章的中心是反对战争支持和平，那么若某一细节处出现 *** ___war *** 选项中优先考虑 against等表示反对的介词. 3.具体填空处前后“语句”的逻辑关系 例如：（2013年英语二文章） Given the advantages of electronic money,==you might think that we would move quickly to the cashless society in which all payments are made electronically.== ___, ==a true cashless society is probably not around the corner==. 您也许会认为我们很快会进入无纸化社会，但是真正的无纸化社会也许可能不会很快来到。根据插入语（即填空处）前后的逻辑关系，属于虽然但是（让步状语从句），且转折处为作者观点，是重点！聚集选项： A. However (然而)B. Moreover (而且)C. Therefore (因此)D. Othervise (否则) 同样地，对于： 1.总分结构再次强调作者观点句的：For instance, for example, 4.与文章背景相关(context-oriented)的单词更容易成为正确选项 例如：（2013年英语二文章） Dishonest persons 可能会进入电子支付系统并__某人的账户，本文所讲的是无纸化社会不会到了，也就是说作者对无纸化社会的态度是negative的，因而我们首先判断这个动词的褒贬方向：是好的方向，还是坏的方向； 既然针对 “electronic payments system” 那么代表坏的方向，因而我们聚焦到选项：A. 偷窃，盗取B. 选择C. 使受益D. 返回，收益(pl) 了解到出题者的用心良苦后，我想答案不言而喻。 5.填空之处前后的固定搭配&amp;词组辨析 例如：2015年英语二真题! 文章在此处阐述，与其与陌生人交谈，倒不如自己在乘车时独自闭口不谈，而在经历实验之后，大家没有觉得 “与陌生人交谈”让人尴尬。 聚焦选项：go through with 经历 do away with 终结，废除 catch up with 追赶 put up with 容忍，忍受这里用put up with是不恰当的，因为受实验者并没有完全谴责或者反对与陌生人交谈的行为。因为使用经历较好。 利用上文五大点，无论是宏观把握还是细节斟酌都能很好地选出最优答案，剩余的事情，就是从反复研读历年真题。找出选项与所在处前后的共性，不断总结归纳常考词汇。 二、阅读理解1.个人认为，对于考研英语试卷而言，卷子的核心是阅读！阅读是值得我们反复研读的。 2.扎实的词汇基础，严谨的行文思路，最后辅佐于相对正确的小技巧。一定可以拿下高分！ 对于英语而言，夯实词汇基础的重要性不言而喻，单词都不认识，更不用说读文章了。 市面上有太多太多的词汇书。 基础不太好的同学，建议跟相关老师的视频课，撇开阅读而谈词汇： 朱伟老师的词汇课挺不错的！何凯文老师的必考词汇也不错，有些推荐的单词是专八系列。从词汇本身的难度而言，是比较好的，附有相近词与例句。 建议基础较好的同学，可以不用听专门的词汇课，本人反复看《十天搞定考研词汇》再辅佐历年真题（真题词汇，建议自己总结！！！），可以达到一样的效果， 阅读方法正文：（本段以历年真题为例子） 拿到文章先看选项，只看选项即可（预热） 考研阅读板块，我建议跟名师：1.有道唐迟老师、赵楠楠老师2.前文都、现新文道教育何凯文老师 唐迟而言，串联题干而避免选项干扰 是对锁定文章内容、排除错误方向起着重要作用的。 看完选项后，根据零散的记忆，是否可以推测以下大致围绕什么主题讲。 经济？社会问题？现象？文化板块.... 直接上题：2020年英语二真题Text1 第一问：第二问：第三问：第四问：第五问：总览所有选项，几乎不离 Rat 老鼠 and Robot 机器人（文中的机器鼠） 单词，因而我们在读完题目之后。思考：本文或许是阐述，有关于老鼠的实验，从实验中，我们应该找到： 1.具体人物表达的观点或态度 2.作者的态度/若无明显态度，则作者不反对的态度基本与作者态度一致 再读完题目后，回到文章本身，精读文章首段/首两段 熟悉吗？没错，就是完形填空的第一步！精读文章第一段，再对文章大致主题的主观推测基础上，用作者自己的话再次佐证文章的中心话题。譬如本文第一段：第一句中，挑出比较重要的部分，to attuned to 意为 “ 适应，调整 或 对...敏感”。因此，开篇提到老鼠对社会信号高度敏感，以此来认清敌友。 因此纵观全文，作者应探讨老鼠与 “社会信号” 的关系。 再比如：2018年英语二Text2这种以 “while” 引导的让步状语从句，是考研长句中比较普遍的句式。while 此时作 “尽管，虽然” 的意思，从句不重要！重要的是主句，即逗号后面的内容（未来属于例如风能、太阳能等新能源）这一句同时也是文章围绕讲的内容。因此作者既然说出来了未来是属于新能源的，那么作者对新能源应持正面，支持的态度！ 细节题目怎么做？难，难在什么地方？ 个人认为，只需要将文章分为： 1.主旨题， 2.细节题， 3.例证题 4.态度题 凡是不属于主旨题（中心思想，文章题目，文章大致内容）、例证题（某某例子说明什么？作者通过xx想表达什么？）以及态度题（不管是作者还是出现的某某某）的，都归于细节题，从文章某处本身上下文寻找最优答案。 看几个例子： 做法因人而异，但个人觉得比较适合大家的是：1.通读全文，一顿勾勾画画2.定位到相应的句子，读懂句子，联系中心！！！3.找选项中错误的句子，找与关键句子同意替换的表达式4.与文章中心靠拢！排除与中心相反或根本无关的句子 其中，2，3，4，是较为困难的过程，同时需要大量的反复练习。揣摩到底这个选项是不是符合中心内容的，是不是对的？哪里有相应同意的表达句，或者是不是正话反说？（出现过，概率不大） 仍然聚焦 2020年英语二 Text1：Q与同事对老鼠进行测试是想看看老鼠是否会___? 明显属于细节题，看文章内容：其中，蓝色划线句是文章背景句。而红色划线句是相应重点句，文章说：为了看看这种敏感程度是否会延伸到 “非动物”身上即：（老鼠是否会对来自机器鼠的社交信号而敏感），因而与选项中比对，是否有与其同意表达的，排除与中心内容无关的，排除说法相反的。 选项：答案一定是来自文章的句子的，绝不是经过主观理解臆断出来的。 这是考研英语阅读不变应万变的宗旨。因而，A选项提到是否老鼠能够获得来自“机器鼠”的社交信号 ，即是细节句的同意表达。因而正确！因为是细节句的同意表达，因而在A选项的存在情况下，其他选项不具备更优答案的气质。 再举个例子：2020年 Text4 M认为，相比较于 millennials（千禧一代） ，Z世代比较___？ 根据定位出题处，** 注意：题中问的Z世代如何？因此选项中可以排除千禧一代所具有的特点(flexible)。而文中提到因为零工经济 (gig economy) Z世代者寻求更多的确定性、稳定性 ，有这一关键句就够了。从选项中找“确定性” “稳定性” 的同义词，同时排除相反的词。聚焦选项： A 更加勤奋 （中心无关）B 更加慷慨（同理）C 没那么追求实际 （相反含义应排除，因为正是零工经济，所以追求实际情况）D 没那么冒险、比较谨慎 （more certainty、stability 的同义词 = 谨慎，不冒险） 因此，该类型的题目的核心点： 答案文中找，不找无关的，找同意替换、更贴近中心的。 例证题不找例子？那找什么？ 相信听过唐迟老师课程的同学都知道， 例子不重要，重要的是例子所欲支撑的观点。 没错，我们的目的就是找例子前后的观点。说来简单，做来实属不易。 举个例子：2019年Text2作者谈到 “艰难的挑战之一” ，何意？ 回归文章： 句子很长，内容比较多。但是挑出与题目更直接相关的内容。可以看到，开篇作者提出森林给了我们庇护，给了我们在应对环境变化中出现的艰难挑战 ，fight against climate change 是好事情啊，为何提到是 challenge 挑战呢？原来，The climate change 会使得森林排放比自身吸收得更多的碳元素 = 入不敷出 ，因而有了这一关键句就够了。做题时，抓住好事会变成坏事，找森林给了我们艰难挑战的同意表达： 相比较而言，森林给了我们艰难挑战对应同意表达的选项是【B】forests may become a potential threat 森林有可能成为潜在的威胁 = 艰难挑战 = 排放出多于自身吸收的碳元素 再看一个例子：2021年 Text 2 L大学的报告显示，在英国，____ 回归文章： 划线句子是关键句，根据报道，在英国，全国85%的土地与肉产品、奶制品直接相关。 读文章时，有些必要成分是一定要揣摩的，比如 “数字” “书名号” “感叹号” 作者不会无缘无故提到数字，不会无缘无故地提到某书的命名，同时也不会无缘无故地感叹、发表观点。 比如这里，文中出现 85% ，心中就要想，这个数字代表什么？想要强调什么？好事还是坏事？会不会与作者态度相关？ 找到关键句后，回归选项： [A] farmland has been inefficiently utilised [B] factory style production needs reforming [C] most land is used for meat and dairy production [D] more green fields will be converted for farming 因而经过关键句的同意表达：85% percent = most land 再三斟酌，可以选出正确答案 C选项。 “主旨题” 约等于 ≈ 观点态度题？文章的主旨就是整个文章的心脏，文章主旨当然大部分是与作者观点态度直接相关的。因而，做文章时，应首先明确自己的做题目标： ①、文章主旨/文章中心 ②、作者观点（是否相同/相反） 这一块我还是力挺唐迟老师的做法：回文法。如果给你ABCD四个标题，或者四个文章主旨，你会怎么写文章？ 例如：2016年text3直接看第一段，思考中心话题 每个人都太忙了，这已经是Cliche（陈词滥调，老生常谈）了。而抱怨声尤其来自：没时间阅读。 至此，我们已经可以猜测到，这篇文章是讲没时间阅读这个现象，作者一定会围绕这个中心话题展开探讨。 因而，答案一目了然。 How to Find Time to Read 如何空出时间来阅读？ 这不就是中心话题吗？反过来说，如果是命题作文：如何空出时间阅读？ 第一步当然就是陈述现象！阐述随着当今世界发展，越来越多的人哀嚎：没有时间阅读。然后继续行文... 再举个例子： 问作者态度，针对英国政府目前在运动方面所作出的努力。 回归文章： The Parkrun phenomenon 本地公园跑现象的成功，更加凸显伦敦奥运遗风的失败！，为全文点出批评英国政府的总基调。作者提到：十年前，Planning documents 承诺人们会更苗条，更健康，然后事情并不如人意，Officials 并没有激励新一代更多地参与体育！ 聚焦选项：A 忍受，容忍B 批判，批评C 不确定的D 同情的 根据作者所表达的态度，伦敦奥运遗风的失败！ 批评英国政府的总基调, Officials 并没有激励新一代更多地参与体育！ 我们可以确定，作者对英国政府持批评态度！ 三、新题型（阅读理解的“儿子”：定位-关键句-比对） 为什么这么说？很简单，不管是小标题题型（每段话缺标题，给出若干个标题，一一对应） 还是概括句题 （文章后有一个表格，将左边的事物与右边的表述一一正确对应） 均是在在阅读文章，完全理解了文章之后！对阅读到的信息进行归纳总结。 新题型板块，我建议：有道赵楠楠老师 可以说对于两种题型，方法大同小异： 1.定位 2.找同义替换 3.回归选项 带着做题思路做真题，例如2018年小标题题型，放出链接如下： 2018年真题及答案（转载自百度文库） 第一步：读选项，混个眼熟第二步：读文章标题第三步：直接聚焦相应段落：找段落重要句 该文章的标题：与人交谈的五种方法 红色是关键句，作者提到：I know the feeling and here is my advice: just get it (想说的话) out. 读完回归众多选项，进行同义替换： Just say it = Just get it out 同意替换，因此相比之下，A为正确答案 再比如： Find the things which you and that person have in common 说白了就是找到你与交谈对象所具有的共同点！找到共同点后，两人才能建立connection，才能使得谈话更顺利！ 聚焦选项，找与表达 “找共同点” 的同义替换： 再三斟酌，Find the “me too”s = have in common 能够形象地表达出共同点！因而，E成为正确答案。 四、翻译 翻译是可以说是，英语学科中，最难也是最重要的板块！这个板块中，我建议 前新东方名师，现跟谁学名师-教翻译的唐静老师 唐静老师所讲授的知识点特别他的《拆分与组合》，能够从根本上解决无法对句子进行长句断翻、短句补译、整理中英译法之差别等技巧。踏踏实实学翻译。 我建议： 1.跟唐静老师学视频课2.利用学到的技巧，用在历年阅读真题上，精读文章中的句子！ 五、作文 作文板块，我推荐王江涛老师的《考研英语高分写作》，基础不好的同学需要听王江涛老师的视频课，反复听！较好的有该书即可，并辅佐自己平时的总结！英语作文范文不在于多，而在于精，因此我建议范文处理方法： 针对历年真题的五篇不同话题/类型范文 《高分写作》老师所给预测五篇不同话题/类型 《高分写作》上每个板块的作文拓展词汇 最后，利用已有反复诵读的范文模板，尝试去做新题，输出学到的相应必备句型！模板的作用是在于用，不在于记！因而，要多用，否则考场上也无法很快地进入状态。","categories":[{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"}],"tags":[{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"}],"author":"vincent"},{"title":"C/C++力扣LeetCode转载","slug":"C_C++力扣LeetCode转载","date":"2021-03-11T09:51:27.000Z","updated":"2021-11-09T07:53:30.182Z","comments":true,"path":"C_C++力扣LeetCode转载/","link":"","permalink":"https://github.com/Vincent990413/blog/C_C++%E5%8A%9B%E6%89%A3LeetCode%E8%BD%AC%E8%BD%BD/","excerpt":"","text":"27.原地移出某数后的数组给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 示例 1： 输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。示例 2： 输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011121314151617181920212223242526class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if(nums.size() == 0) return 0; //一个指针指向头 一个指向尾部 int i = 0, index = nums.size()-1; while(i &lt;= index) &#123; //如果当前是要删除的值 if(nums[i] == val) &#123; //将该数字与最后一个数字交换 //同时数组缩减 int temp = nums[index]; nums[index] = nums[i]; nums[i] = temp; --index; &#125; //如果不是要删除的值 继续往后推进 else ++i; &#125; return i; &#125;&#125;; 作者：Xiaohu9527链接：https://leetcode-cn.com/problems/remove-element/solution/cyi-ci-li-bian-bu-xu-yao-bao-li-gan-jue-82cz7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 58.返回最后一个单词的长度给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。（注意本题最后 可能出现连续的空格）单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。 示例 1： 输入：s = &quot;Hello World&quot;输出：5示例 2： 输入：s = &quot; &quot;输出：0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/length-of-last-word著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011int lengthOfLastWord(string s) &#123; int count = 0, end = s.size()-1; //直到最后一个变成第一个 //未遇到第一个字母前 若有连续的空格 直接跳过 while(end &gt;= 0 &amp;&amp; s[end] == &#x27; &#x27;) --end; //如果没有遇到最后一个字母前的空格 就count++ 且每次指针 end-- while(end &gt;= 0 &amp;&amp; s[end--] != &#x27; &#x27;) ++count ; return count; &#125; 动态规划实现斐波那契数列假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 示例 1：输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2：输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/climbing-stairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789101112131415//一定看懂本题的动态规划//利用dp[i]将可能用到的值存起来 return dp[n]int climbStairs(int n) &#123; vector&lt;int&gt; dp(n+3, 0); //元素个数为n+3 默认为0 dp[0] = 0; dp[1] = 1; dp[2] = 2; //用数组把值存储起来 如果下次需要 直接调用相应的数组值即可 for(int i=3; i&lt;=n; i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125; 合并有序数组使其有序给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 （本来都有序，想要合并之后仍有序）初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 示例 1：输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6] 示例 2：输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789101112class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; //从将nums2的全部内容 排在nums1的数组后面 for(int k=m,j=0; k&lt;m+n; k++,j++)&#123; nums1[k] = nums2[j]; &#125; //整体对nums1第一个元素 以及加进来之后的最后一个元素进行排序即可 注意排序的长度是容纳n1 n2的长度之和 sort(nums1.begin(), nums1.begin()+(m+n)); &#125;&#125;; 找到值的索引 或者理应插入的位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2示例 2: 输入: [1,3,5,6], 2输出: 1示例 3: 输入: [1,3,5,6], 7输出: 4示例 4: 输入: [1,3,5,6], 0输出: 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int pos = 0; int end = nums.size(); //处理特殊情况 当小于第一个或者大于最后一个时 if(target &lt; nums[0])&#123; return pos; &#125; if(target &gt; nums[end-1])&#123; pos = end; return pos; &#125; //如果中间有 那么返回该位置 for(int i=0; i&lt;end; i++)&#123; if(target == nums[i])&#123; pos = i; return pos; &#125; &#125; //如果下一个比它大 则返回下一个位置 for(int i=0; i&lt;end; i++)&#123; if(target &gt;nums[i] &amp;&amp; target &lt; nums[i+1])&#123; pos = i+1; return pos; &#125; &#125; return pos; &#125;&#125;; 121. 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1：输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int profit=0, minValue=prices[0]; //假设第一个是最小值 for(int i=1; i&lt;prices.size(); i++)&#123; //从第二个到最后一个开始 minValue = min(minValue, prices[i]); //每次比较minValue与当前值的最小值 profit = max(profit, prices[i]-minValue); //利润就是当前值减去最小值的最大差值 &#125; return profit; &#125;&#125;; 202. 快乐数编写一个算法来判断一个数 n 是不是快乐数。「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为? 1，那么这个数就是快乐数。如果 n 是快乐数就返回 true ；不是，则返回 false 。 示例 1：输入：19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 示例 2：输入：n = 2输出：false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/happy-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: //拿到相应的各数之和函数 int getNum(int n)&#123; int sum=0; while(n)&#123; sum += (pow(n%10, 2)); n /= 10; &#125; return sum; &#125; bool isHappy(int n) &#123; set&lt;int&gt; s; //定义一个集合 因为如果结果不为1 相加一定有重复的数字 while(1)&#123; //一直循环 int sum = getNum(n); //每次将结果放入集合之前 先判断集合是否已经存在该元素 //如果已经出现了 说明结果肯定不会等于1 if(s.count(sum) == 1)&#123; return false; &#125; //如果没有重复 则加入 s.insert(sum); //如果结果等于1 则返回true if(sum == 1)&#123; return true; &#125; //对每一次得到的sum重复计算！ n = sum; &#125; &#125;&#125;; 136. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 示例 1:输入: [2,2,1]输出: 1 示例 2:输入: [4,1,2,1,2]输出: 4 12345678910111213141516171819class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; s; int res = 0; for(int i=0; i&lt;nums.size(); i++)&#123; if(s.count(nums[i]) == 1)&#123; //如果集合中有这个元素 那么删除它 s.erase(nums[i]); &#125;else&#123;//如果集合中没有这个元素 就添加进去 s.insert(nums[i]); &#125; &#125; set&lt;int&gt;::iterator it; for(it=s.begin();it != s.end(); it++)&#123; res = *it;//最后剩余的元素 一定是不重复的元素 &#125; return res; &#125;&#125;; 204. 计数质数统计所有小于非负整数 n 的质数的数量。 示例 1：输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2：输入：n = 0输出：0 示例 3：输入：n = 1输出：0 12345678910111213141516171819202122class Solution &#123;public: bool isPrime(int x) &#123; //在0~根号x的范围内 即可判断是否是质数 for (int i = 2; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; return false; &#125; &#125; return true; &#125; //在C++中 true的数字代表1 多少个true相加 //就代表有多少个质数 从2~n-1判断即可 int countPrimes(int n) &#123; int ans = 0; for (int i = 2; i &lt; n; ++i) &#123; ans += isPrime(i); &#125; return ans; &#125;&#125;; 217. 存在重复元素给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1:输入: [1,2,3,1]输出: true 示例 2:输入: [1,2,3,4]输出: false 示例?3:输入: [1,1,1,3,3,4,3,2,4,2]输出: true 123456789101112131415161718class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; s; for(int i=0; i&lt;nums.size(); i++)&#123; //如果集合中存在重复元素 直接return真 if(s.count(nums[i]) == 1)&#123; return true; &#125; //否则持续向集合中 添加数组中的元素 s.insert(nums[i]); &#125; return false; &#125;&#125;; 258. 各位相加给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例:输入: 38输出: 2解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 123456789101112131415161718192021222324252627class Solution &#123;public: //计算各数之和的方法 int getNum(int num)&#123; int res = 0; while(num)&#123; res += num%10; num /= 10; &#125; return res; &#125; int addDigits(int num) &#123; int res = 0; //不到跳出循环的条件不罢休 while(1)&#123; //算出num的各数之和 res = getNum(num); //直到算到个数之和小于10 if(res&lt;10)&#123; return res; &#125; //下一次计算新结果的个数之和 num = res; &#125; &#125;&#125;; 28.实现 strStr()给定一个?haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回? -1。 示例 1:输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2:输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 当?needle?是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当?needle?是空字符串时我们应当返回 0 。这与C语言的?strstr()?以及 Java的?indexOf()?定义相符。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910111213141516171819class Solution &#123;public: int strStr(string haystack, string needle) &#123; int pos = 0; //如果是空字符串 返回0 if(needle == &quot; &quot;)&#123; return pos; &#125;else&#123; //如果不为空 则找到对应的位置 pos = haystack.find(needle); //如果找得到 返回位置 if( pos != string::npos)&#123; return pos; &#125; &#125; //如果找不到 就返回-1 return -1; &#125;&#125;; 83. 删除排序链表中的重复元素给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1:输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2:输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* cur = head; while(cur != NULL &amp;&amp; cur-&gt;next != NULL)&#123; if(cur-&gt;val == cur-&gt;next-&gt;val)&#123; cur-&gt;next = cur-&gt;next-&gt;next; &#125;else&#123; cur = cur-&gt;next; &#125; &#125; return head; &#125;&#125;; 344. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1：输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2：输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910111213141516171819class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; //给俩指针 一个指针指向第一个元素 //再给一个指针给最后一个元素 int i = 0; int end = s.size()-1; //直到俩指针相遇 while(i&lt;=end)&#123; //交换首尾元素 char temp = s[i]; s[i] = s[end]; s[end] = temp; i++; end--; &#125; &#125;&#125;; 383. 赎金信给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 示例 1：输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2：输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3：输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ransom-note著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; int count = 0; //count用来标记r串中 可以找到的个数 int r_i = 0; int r_len = ransomNote.size(); int m_end = magazine.size(); //从ran字符串中 一个一个判断 while(r_i &lt; r_len)&#123; int pos = magazine.find(ransomNote[r_i]); if( pos != string::npos)&#123; count++; //从mag中原地删除字符 int temp = magazine[pos]; magazine[pos] = magazine[m_end-1]; magazine[m_end-1] = temp; //删除最后一个字符 magazine.erase(m_end-1); &#125; r_i++; &#125; //如果都可以找到 就代表true if(count == ransomNote.size())&#123; return true; &#125; return false; &#125;&#125;; 387. 字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例：s = &quot;leetcode&quot;返回 0 s = &quot;loveleetcode&quot;返回 2 提示：你可以假定该字符串只包含小写字母。 1234567891011121314151617181920class Solution &#123;public: int firstUniqChar(string s) &#123; unordered_map&lt;char, int&gt; frequency; //将字符串中的每个字符 遇到一个自增 for (char ch: s) &#123; ++frequency[ch]; &#125; //从头到尾 输出第一个频度为1的 for (int i = 0; i &lt; s.size(); ++i) &#123; if (frequency[s[i]] == 1) &#123; return i; &#125; &#125; return -1; &#125;&#125;; 268. 丢失的数字给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 示例 1：输入：nums = [3,0,1]输出：2解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2：输入：nums = [0,1]输出：2解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3：输入：nums = [9,6,4,2,3,5,7,0,1]输出：8解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4：输入：nums = [0]输出：1解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示：n == nums.length1 &lt;= n &lt;= 1040 &lt;= nums[i] &lt;= nnums 中的所有数字都 独一无二 12345678910111213141516class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; //首先从小到大进行排序 sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;nums.size();i++)&#123; //如果n在数组当中 从小到大一次判断哪个数不在数组中 if(nums[i] != i)&#123; return i; &#125; &#125; //否则没有找到 那么就是n这个数 return n; &#125;&#125;; 414. 第三大的数给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。 示例 1：输入：[3, 2, 1]输出：1解释：第三大的数是 1 。 示例 2：输入：[1, 2]输出：2解释：第三大的数不存在, 所以返回最大的数 2 。 示例 3：输入：[2, 2, 3, 1]输出：1解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。 提示：1 &lt;= nums.length &lt;= 104-231 &lt;= nums[i] &lt;= 231 - 1 123456789101112131415161718192021222324252627282930class Solution &#123;public:int thirdMax(vector&lt;int&gt;&amp; nums) &#123; //对所给数组进行从小到大排序 sort(nums.begin(), nums.end()); set&lt;int&gt; s; int len = nums.size(); for(int i=0; i&lt;len; i++)&#123; //将元素加入无重复的集合中 s.insert( nums[i] ); &#125; //清空vector nums.clear(); for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123; //将集合中的元素 加入数组中 nums.push_back(*it); &#125; //如果数组的长度小于3 那么返回数组的最后一个元素 if(nums.size()&lt;3) return nums[nums.size()-1]; //否则返回倒数第三个 return nums[nums.size()-3];&#125;&#125;; 1004: 母牛的故事题目描述有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ 输入输入数据由多个测试实例组成，每个测试实例占一行，包括**一个整数n(0&lt;n&lt;55)**，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 输出对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;#define N 100using namespace std;int fun(int n)&#123; int a[N]; int i; //避免索引错位 因此直接让a[1]=1... for(int i=1; i&lt;=4; i++)&#123; a[i] = i; &#125; //索引从第五年开始 状态转移方程是 ai = ai-1 + ai-3 for(i=5; i&lt;=n; i++)&#123; a[i] = a[i-1] + a[i-3]; &#125; //返回该数的数组位置 return a[n]; &#125;int main()&#123; int y = 0; while(cin &gt;&gt; y)&#123; if(y == 0) break; cout &lt;&lt; fun(y) &lt;&lt;endl; &#125; return 0; &#125; 434. 字符串中的单词数统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例: 输入: &quot;Hello, my name is John&quot;输出: 5解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。 12345678910111213141516171819class Solution &#123;public: int countSegments(string s) &#123; //flag stands for if it is the Number //count stands for the number of Num int flag=0,count = 0; for(int i=0; s[i] != &#x27;\\0&#x27;; i++) &#123; if(s[i] == &#x27; &#x27;)&#123; flag = 0; &#125;else if(flag == 0)&#123; count++; flag = 1; &#125; &#125; return count;&#125;&#125;; 392. 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 示例 1：输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;输出：true 示例 2：输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;输出：false?提示：0 &lt;= s.length &lt;= 1000 &lt;= t.length &lt;= 10^4两个字符串都只由小写字符组成。 1234567891011121314151617181920212223class Solution &#123;public:bool isSubsequence(string s, string t) &#123; bool flag = true; int i,j = -1; for(int i=0; s[i] != &#x27;\\0&#x27;; i++) &#123; //从s中找各个字符 对应在t中的位置 j = t.find(s[i]); if(j != string::npos)&#123; //如果没找到 就返回false //否则截取找到的位置 下一个位置到结束 //继续往后找 t = t.substr(j+1); &#125;else&#123; flag = false; return flag; &#125; &#125; return flag;&#125;&#125;; 551. 学生出勤记录 I给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： &#39;A&#39; : Absent，缺勤&#39;L&#39; : Late，迟到&#39;P&#39; : Present，到场如果一个学生的出勤记录中不超过一个&#39;A&#39;(缺勤)并且不超过两个连续的&#39;L&#39;(迟到),那么这个学生会被奖赏。 你需要根据这个学生的出勤记录判断他是否会被奖赏。 示例 1:输入: &quot;PPALLP&quot;输出: True 示例 2:输入: &quot;PPALLL&quot;输出: False 123456789101112131415161718192021class Solution &#123;public: bool checkRecord(string s) &#123; bool flag = false; int countA=0, countL=s.find(&quot;LLL&quot;); for(int i=0; i&lt;s.size(); i++)&#123; if(s[i] == &#x27;A&#x27;)&#123; //对于不用连续出现的A 通过统计即可 countA++; &#125; &#125; //对于连续出现L 可以看成是否出现 不满足题目要求的“字串” &quot;LLL&quot;即可 if(countL==string::npos &amp;&amp; countA &lt;= 1)&#123; flag = true; &#125; return flag;&#125;&#125;; 面试题 01.03. URL化URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。） 示例 1：输入：&quot;Mr John Smith &quot;, 13输出：&quot;Mr%20John%20Smith&quot;?示例 2：输入：&quot; &quot;, 5输出：&quot;%20%20%20%20%20&quot; 123456789101112131415class Solution &#123;public: string replaceSpaces(string S, int length) &#123; string s = &quot;&quot;; //用一个新的字符串来装 for(int i=0; i&lt;length; i++)&#123; if(S[i] == &#x27; &#x27;)&#123; s += &quot;%20&quot;; &#125;else&#123; s.push_back(S[i]); &#125; &#125; cout &lt;&lt; s; return s; &#125;&#125;; 459. 重复的子字符串(巧妙)给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1:输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。 示例 2:输入: &quot;aba&quot;输出: False 示例 3:输入: &quot;abcabcabcabc&quot;输出: True解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。) 12345678910111213class Solution &#123;public: bool repeatedSubstringPattern(string s) &#123; //如果是可用 子串重复 的串（比如abab） //那么本身轮回一圈后 下次找一定可以在 小于这个串长度的位置里 //找到自身的串首次出现的位置 //否则如果不是可重复的（比如ab） //本身轮回一圈后 下次再找到自己的串ab 一定不在自身的长度以内 abab return (s + s).find(s, 1) != s.size(); &#125;&#125;; 506. 相对名次给出?N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;）。(注：分数越高的选手，排名越靠前。) 示例 1:输入: [5, 4, 3, 2, 1]输出: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” (&quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;).余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: static bool cmp(int a, int b)&#123; return a&gt;b;&#125;vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; score) &#123; vector&lt;string&gt; v; unordered_map&lt;int, int&gt; m; int num = 1; //根据分数 从高（第一名）到低进行排名 string gold = &quot;Gold Medal&quot;; string silver = &quot;Silver Medal&quot;; string bronze = &quot;Bronze Medal&quot;; vector&lt;int&gt; score1 = score; //新建一个数组 用来记录分数对应的名词 sort(score1.begin(), score1.end(), cmp); //最高分的排在前面 for(int i=0; i&lt;score1.size(); i++)&#123; m[score1[i]] = num++; //开始记录 &#125; for(int i=0; i&lt;score.size(); i++)&#123; int n = m[score[i]]; //根据自己的元素 原地取对应的排名 //修改前三名的string（金银铜） if(n == 1)&#123; v.push_back(gold); continue; &#125; if(n == 2)&#123; v.push_back(silver); continue; &#125; if(n == 3)&#123; v.push_back(bronze); continue; &#125; v.push_back(to_string(n)); &#125; for(string str:v)&#123; cout &lt;&lt; str &lt;&lt; &quot; &quot;; &#125; return v; &#125;&#125;;","categories":[{"name":"经典C++算法","slug":"经典c-算法","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BB%8F%E5%85%B8c-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"c语言","permalink":"https://github.com/Vincent990413/blog/tags/c%E8%AF%AD%E8%A8%80/"}],"author":"vincent"},{"title":"C/C++ 编程常见代码","slug":"C_C++ 编程常见代码","date":"2021-03-11T09:51:27.000Z","updated":"2021-11-09T07:53:30.182Z","comments":true,"path":"C_C++ 编程常见代码/","link":"","permalink":"https://github.com/Vincent990413/blog/C_C++%20%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81/","excerpt":"","text":"1.加法器、累加器：（多实现 1+2+...+n 以及阶乘 n! 的功能）一、求累加12345678910111213141516int main()&#123; int i =0; int res = 0; int n; cin &gt;&gt; n; while(i&lt;=n)&#123; res += i; i++; &#125; //其中 res为最终结果 n表示加到多少 i表示每次加的数 cout &lt;&lt; res &lt;&lt;endl; return 0; &#125; 二、求某数阶乘12345678910111213141516171819int main()&#123; int i = 1; int sum = 1; int n; cin &gt;&gt; n; while(i &lt;=n)&#123; sum *=i; // 1. sum = 1*1 =1 i++; // 2. i =2; // 3. sum = 1*2=2 以此类推 &#125; cout &lt;&lt; &quot;其阶乘为：&quot; &lt;&lt; sum &lt;&lt;endl; return 0;&#125; 2. 求两个数或数组中的最大值与最小值int main(){ 123456789101112131415161718192021222324 int a, b,max; cout &lt;&lt; &quot;请连续输入待比较的两个数，空格隔开：&quot; &lt;&lt;endl; cin &gt;&gt; a &gt;&gt; b; max = (a&gt;b) ? a : b; //使用双目运算符取得最大值 cout &lt;&lt; max &lt;&lt;endl; int arr[5] = &#123;5, 2, 13, 23, 66&#125;; int arr_max, arr_min; arr_max = arr[0]; //默认第一位元素为最值 arr_min = arr[0]; for(int i =0; i &lt;5; i++) &#123; if(arr_max &lt; arr[i]) &#123; arr_max = arr[i]; &#125;else if(arr_min &gt; arr[i])&#123; //往后遍历，若还有更大的则更新最值 否则最小值更新 arr_min = arr[i]; &#125; &#125; cout &lt;&lt; arr_min &lt;&lt; &quot; &quot; &lt;&lt;arr_max &lt;&lt;endl; return 0;&#125; 3.冒泡排序，必须会默写12345678910111213141516#define LEN 5int main()&#123; int a[LEN] = &#123;2, 13, 5, 55, 20&#125;; for(int i=0; i&lt;LEN; i++) &#123; for(int j=0; j&lt;LEN-i-1; j++)&#123; //注意两个for循环的初始条件与终止条件 都从0k开始 if(a[j] &gt; a[j+1])&#123; int t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; &#125; return 0;&#125; 4.简单的switch-case多分支条件语句12345678910111213141516171819202122232425262728int main()&#123; int score; cout &lt;&lt; &quot;请在0~100范围内输入你的分数(满分100分)：&quot; &lt;&lt;endl; cout &lt;&lt; &quot; 60分以下不及格 60~70及格 70~80良好 80以上优秀 &quot; &lt;&lt;endl; cin &gt;&gt; score; switch(score/10)&#123; case 6 : cout&lt;&lt;&quot;及格&quot;&lt;&lt;endl; break; case 7 : cout&lt;&lt;&quot;良好&quot;&lt;&lt;endl; break; case 8 : cout&lt;&lt;&quot;优秀&quot;&lt;&lt;endl; break; case 9 : cout&lt;&lt;&quot;优秀&quot;&lt;&lt;endl; break; case 10 : cout&lt;&lt;&quot;满分&quot;&lt;&lt;endl; break; default: cout&lt;&lt;&quot;不及格&quot;&lt;&lt;endl; break; &#125; return 0;&#125; 5.求两个数的最大公约数、最小公倍数(不可含0) (谭浩强C语言例题）123456789101112131415161718192021222324252627int main()&#123; int x, y, r; cout &lt;&lt; &quot;请输入待运算的两个数, 中间用空格隔开&quot; &lt;&lt;endl; cin &gt;&gt; x &gt;&gt; y; int mul = x * y; if(x &gt; y) //将比如 8,2 与 2,8 的操作统一输出 &#123; r = x; x = y; y = r; &#125; r = x % y; //直接判断两数是否可以整除 while(r)&#123; x = y; y = r; r = x % y; //辗转相除法 //直到余数不为0 //将余数作为除数 较小者作为被除数 继续求余判断 &#125; cout &lt;&lt; &quot;最大公约数:&quot; &lt;&lt; y &lt;&lt; &quot;，最小公倍数:&quot; &lt;&lt; mul / y &lt;&lt;endl; return 0;&#125; 6.斐波那契数列递归123456789101112int fib(int n)&#123; if(n == 1)&#123; return 1; &#125;else if(n == 2)&#123; return 1; &#125;else&#123; return fib(n-2) + fib(n-1); &#125;&#125; 1, 1, 2, 3, 5...以此类推 7.判断某数是否是素数 (谭浩强C语言例题）1234567891011121314151617181920212223int main()&#123; int n, i; bool isPrime = true; cout &lt;&lt; &quot;输入一个正整数: &quot;; cin &gt;&gt; n; for(i = 2; i &lt;= n / 2; ++i) &#123; if(n % i == 0) //只能被1 和 自身整除的数 才能是素数 &#123; isPrime = false; break; &#125; &#125; if (isPrime) cout &lt;&lt; &quot;是素数&quot;; else cout &lt;&lt; &quot;不是素数&quot;; return 0;&#125; 8.大写字母转化为小写字母12345678910 int main()&#123; char a; a = getchar(); printf(&quot;%c&quot;, a+32); // C或C语言中字符数据均以ASCII值存储 大写字母与小写字母相差32 return 0;&#125; 9.统计输入字符中单词的个数 (谭浩强C语言例题）123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;#define N 30using namespace std;int main()&#123; char b[N]; int word,count=0,i; //word代表是否是单词 1代表是 0代表不是单词 而是空格 //count 代表单词个数 puts(&quot;输入的字符长度要小于等于N&quot;); // 例如-&gt; hello world gets(b); for(i=0;b[i]!=&#x27;\\0&#x27;;i++) if(b[i]==&#x27; &#x27;) //若为空格则不是单词 word=0; else if(word==0) //若是空格则遇到的新单词使得count加一 &#123; count++; word=1; &#125; printf(&quot;%d&quot;,count); return 0;&#125; 10.求Sn=a+aa+aaa+…+aa…aaa（有n个a）之值，其中a是一个数字，为2。 例如，n=5时=2+22+222+2222+22222，n由键盘输入。 (谭浩强C语言例题）123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; int n,i,Sn =0,a=0; cin &gt;&gt; n; //n代表循环次数 for(i=0; i&lt;n; i++)&#123; a = a*10 +2; // 0, 2, 22, 222 Sn += a; /0+2+22 &#125; cout &lt;&lt; Sn; return 0;&#125; 11.求Sn=1!+2!+3!+4!+5!+…+n!之值，其中n是一个数字(n不超过20) 注意使用int类型 当n为19时会溢出 (谭浩强C语言例题）12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;long long fac(long long n)&#123; long long i = 1; long long sum = 1; while(i &lt;=n)&#123; sum *=i; // 1. sum = 1*1 =1 i++; // 2. i =2; // 3. sum = 1*2=2 以此类推 &#125; return sum;&#125;int main()&#123; long long n,sum=0,a = 0; cin &gt;&gt; n; for(long long i=n; i&gt;0; i--)&#123; sum += fac(i); &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 12.求一个3×3矩阵对角线元素之和。 (谭浩强C语言例题） 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main()&#123; int a[3][3]; for(int i=0; i&lt;3; i++) &#123; for(int j=0;j&lt;3; j++)&#123; cin &gt;&gt; a[i][j]; &#125; &#125; //两个for循环输入二维数组 int sum1 = 0; int sum2 = 0; for(int i=0; i&lt;3;i++) &#123; sum1 += a[i][i]; //主对角线求和 &#125; int j=2; for(int i=0;i&lt;3;i++) &#123; sum2 += a[i][j]; //副对角线求和 注意变量j定义在循环外 不然值不会发生改变 //j分别是2 1 0 j--; &#125; cout &lt;&lt; sum1 &lt;&lt; &quot; &quot; &lt;&lt; sum2; return 0;&#125; 13.用选择法对10个整数从小到大排序。 (谭浩强C语言例题） 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#define LEN 10using namespace std;void swap(int *a,int *b) //交换两个数 引用&amp; 或者指针* 均可&#123; int temp = *a; *a = *b; *b = temp;&#125;void selection_sort(int arr[], int len)&#123; int i,j; for (i = 0 ; i &lt; len - 1 ; i++) &#123; int min = i; //默认选择最小值 for (j = i + 1; j &lt; len; j++) if (arr[j] &lt; arr[min]) min = j; swap(&amp;arr[min], &amp;arr[i]); //调用数组元素时 元素前加引用 &#125;&#125;int main()&#123; int a[LEN]; for(int i=0; i&lt;LEN; i++) cin &gt;&gt; a[i]; selection_sort(a, LEN); for(int i=0; i&lt;LEN; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; endl; &#125; return 0;&#125; 14.数组插入处理，对一个排好序的数组，按原来的规律插入某数 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main()&#123; int a[5],x; for(int i=0; i&lt;5; i++)&#123; scanf(&quot;%d&quot; ,&amp;a[i]); //输入数组 &#125; scanf(&quot;%d&quot;, &amp;x); //输入待插入元素 for(int i=0; i&lt;5; i++)&#123; if(a[i]&lt;x &amp;&amp; a[i+1]&gt;x) //满足条件模拟“插入” 并输入前后元素 cout &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt;x &lt;&lt;&quot; &quot;; else printf(&quot;%d &quot;, a[i]); //否则正常输入 &#125; return 0;&#125; 15.写一个函数，使给定的一个二维数组（３×３）转置，即行列互换。 (谭浩强C语言例题）1234567891011121314151617181920212223#include&lt;iostream&gt;#define N 3 using namespace std;int main()&#123; int a[N][N]; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;N;j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;N;j++) &#123; cout &lt;&lt; a[j][i] &lt;&lt;&quot; &quot;; //行列互换即可 &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 16.自定义函数之字符串反转123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstring&gt;#define N 100 using namespace std;int main()&#123; char a[N]; cin &gt;&gt; a; //遇tab、空格、回车都结束 //适合输入单个字符串且中间不含空格 //若需输入含空格的字符串 可用gets(str); int len = strlen(a); for(int i=len-1; i&gt;=0; i--)&#123; //注意字符数组的最后一个字符是 &#x27;\\0&#x27;因而从倒数第二个开始 printf(&quot;%c&quot;, a[i]); &#125; return 0;&#125; 17.写一函数，将两个字符串连接123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstring&gt;#define N 100 using namespace std;int main()&#123; char a[N], b[N]; cin &gt;&gt; a; cin &gt;&gt; b; int len_a = strlen(a); int len_b = strlen(b); for(int j = len_a,k=0; j &lt; len_a + len_b; j++,k++ ) &#123; a[j] = b[k]; //后半部分赋新值即可 &#125; cout &lt;&lt; a &lt;&lt;endl; return 0;&#125; 18.写一函数，输入一个四位数字，要求输出这四个数字字符，但每两个数字间空格。如输入1990，应输出&quot;1 9 9 0&quot;。 (谭浩强C语言例题）12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define N 100using namespace std;int main()&#123; //1990 int a; stack&lt;int&gt; s; //利用栈stack从个位到最高位 进栈 cin &gt;&gt; a; while(a&gt;0)&#123; s.push(a%10); a /= 10; &#125; while(!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; &quot; &quot;; //根据栈的FILO原则 出栈即可 s.pop(); &#125; return 0;&#125; 19.定义一个带参的宏，使两个参数的值互换，并写出程序，输入两个数作为使用宏时的实参。输出已交换后的两个值。1234567891011121314#include&lt;iostream&gt;#include&lt;cmath&gt;#define exchange(a,b) t=a;a=b;b=t; //相当于整段代码替换 using namespace std;int main()&#123; int a, b, t=0; cin &gt;&gt; a &gt;&gt; b; exchange(a,b); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt;endl;&#125; 20.输入两个整数，求他们相除的余数。用带参的宏来实现，编程序。1234567891011121314#include&lt;iostream&gt;#include&lt;cmath&gt;#define MOD(a,b,res) res = a % b; //相当于整段代码替换 using namespace std;int main()&#123; int a, b, res=0; cin &gt;&gt; a &gt;&gt; b; MOD(a,b,res); cout &lt;&lt; res &lt;&lt;endl;&#125; 21.输入一行电报文字，将字母变成其下一字母（如’a’变成’b’……’z’变成’ａ’其它字符不变）。12345678910111213141516171819202122232425#include&lt;iostream&gt;#define N 100using namespace std;int main()&#123; char a[N]; gets(a); //输入字符串 for(int i=0; a[i] != &#x27;\\0&#x27;; i++)&#123; if(a[i] &gt;= &#x27;a&#x27; &amp;&amp; a[i] &lt; &#x27;z&#x27;|| a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt; &#x27;Z&#x27;)&#123; a[i] += 1; //C++与C一样 字符变量都由ASCII码整数存储 //因而 相应ASCII码自增1即可 &#125; if(a[i]==&#x27;z&#x27;) a[i] = &#x27;a&#x27;; if(a[i]==&#x27;Z&#x27;) a[i] = &#x27;A&#x27;; &#125; puts(a); //打印字符串 return 0; &#125; 22.现有N个学生的数据记录，每个记录包括学号、姓名、三科成绩。 编写一个函数input,用来输入一个学生的数据记录。 编写一个函数print,打印一个学生的数据记录。 在主函数调用这两个函数，读取N条记录输入，再按要求输出。 N&lt;100 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#define N 100//class://私有属性：学号，姓名，三科成绩//公有方法：void input(); void print(); using namespace std;class Student&#123; //类名可以不大写，但是推荐大写 符合Java命名规范 public: void input(); void print(); private: string num; //字符串类型 涉及到char 跟 int 的组合 //C++中的字符串是string类 Java中是String类 string name; int Chinese; int Math; int English;&#125;; //记得有分号； void Student::input()&#123; //记得域名符:: 表示实现Student类的方法 cin &gt;&gt; num &gt;&gt; name &gt;&gt; Chinese &gt;&gt; Math &gt;&gt; English; //加上域名符直接引用属性 &#125;void Student::print()&#123; cout &lt;&lt; num &lt;&lt; &quot;,&quot; &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; Chinese &lt;&lt; &quot;,&quot; &lt;&lt; Math &lt;&lt; &quot;,&quot; &lt;&lt; English &lt;&lt;endl;&#125;int main()&#123; int n; Student stu[N]; cin &gt;&gt; n; for(int i=0; i&lt;n; i++)&#123; stu[i].input(); &#125; for(int i=0; i&lt;n; i++)&#123; stu[i].print(); &#125; return 0;&#125; 23.将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#define N 100using namespace std;int main()&#123; char str[N]; gets(str); int len = strlen(str); for(int i=len-1; i&gt;=0; i--)&#123; //利用for循环颠倒该数组即可 //由于C++中最后一个字符是&#x27;\\0&#x27; 因此从倒数第二个字符开始自减 cout &lt;&lt; str[i]; &#125; &#125; 24.解一元二次方程 (谭浩强C语言例题） 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;cstring&gt;#define N 100using namespace std;int main()&#123;// a*x^2+b*x+c=0 int a, b, c; double res1, res2; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; double delta = pow(b,2) - 4 * a * c; if(delta == 0)&#123; res1 = (-b + sqrt(delta) ) / 2 * a; res2 = res1; &#125;else&#123; res1 = (-b + sqrt(delta) ) / 2 * a; res2 = (-b - sqrt(delta) ) / 2 * a; &#125; printf(&quot;%.2f %.2f&quot;, res1, res2); return 0;&#125; 25.输入字符串 将组成字符的所有非英文字母的字符删除后输出 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;cstring&gt;#define N 100using namespace std;int main()&#123; //a ASCII是97 char str[N]; //定义所输入的字符数组 gets(str); //输入该数组的数据 int len = strlen(str); vector&lt;char&gt; v; //定义vector模板类 for(int i=0; i&lt;len; i++)&#123; if(str[i] &lt; &#x27;A&#x27;|| str[i] &gt;&#x27;Z&#x27;&amp;&amp; str[i] &lt;&#x27;a&#x27; || str[i]&gt;&#x27;z&#x27;)&#123; &#125;else&#123; //所输入数据是大小写字母时 存入动态数组vector中 v.push_back(str[i]); &#125; &#125; for(int i=0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v[i]; &#125; return 0;&#125; 谭浩强第四版课后习题答案：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183### 第二章：2.4#1、以参数形式交换两个数（记得参数加引用）#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;void swap(int &amp;a, int &amp;b)&#123; //什么时候用引用？ 当需要将操作后的值 传递回去 int t = a; a = b; b = t;&#125;int main()&#123; int num1, num2; cin &gt;&gt; num1 &gt;&gt; num2; swap(num1, num2); cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2; return 0;&#125; #2.依次输入5个值 要求输入其中的最大值#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define L 5using namespace std;int main()&#123; int a[L],max; for(int i=0; i&lt;L; i++)&#123; cin &gt;&gt; a[i]; &#125; max = a[0]; for(int i=1; i&lt;=5; i++)&#123; if(max &lt; a[i]) max = a[i]; &#125; cout &lt;&lt; &quot;Max is:&quot; &lt;&lt; max &lt;&lt; endl; return 0;&#125; #3.有三个数a,b,c 要求输出最大值#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define L 5using namespace std;int main()&#123; int num1, num2, num3; int max; cin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3; max = (num1 &gt; num2)? num1 : num2; //第一个数与第二个数比较 结果是max max = (max &gt; num3)? max : num3; //max与第三个数比较 重新赋max的值 cout &lt;&lt; max &lt;&lt;endl; return 0;&#125; #4.求1+2+3+...+100#include&lt;iostream&gt;#include&lt;stdio.h&gt; using namespace std;int main()&#123; int i, sum=0; while(i&lt;=100)&#123; sum += i; i++; &#125; cout &lt;&lt; sum &lt;&lt;endl; return 0;&#125; #5.判断一个数是否同时被3和5整除#include&lt;iostream&gt;#include&lt;stdio.h&gt; using namespace std;int main()&#123; int num; cin &gt;&gt; num; if(num%3==0 &amp;&amp; num%5 ==0)&#123; printf(&quot;该数%d可以被3和5整除&quot;, num); &#125;else&#123; printf(&quot;不行&quot;); &#125; return 0;&#125; #6.输出100~200之间的素数#include&lt;iostream&gt;#include&lt;stdio.h&gt; using namespace std;bool fac(int x)&#123; bool flag = true; for(int i=2; i&lt;x/2; i++)&#123; //注意 对素数的判断 是需要判断2~n/2即可 if(x%i==0)&#123; flag = false; &#125; &#125; return flag;&#125;int main()&#123; for(int i=100; i&lt;=200; i++) &#123; if(fac(i) == true) &#123; printf(&quot;%d是素数\\n&quot;, i); &#125; &#125; return 0;&#125; #7 求两个数的最大公约数#include&lt;iostream&gt;#include&lt;stdio.h&gt; using namespace std;void fun(int a, int b)&#123; //传参进来a大于b int c = a%b; //辗转相除法 若余数为0 则小者为最大公约数 while(c != 0)&#123; //如果余数不为0 a = b; //否则将余数作为除数 b = c; //小者作为被除数 c = a % b; &#125; cout &lt;&lt; b &lt;&lt;&quot;是最大公约数&quot; &lt;&lt; endl;&#125;void swap(int &amp;a, int &amp;b)&#123; int t = a; a = b; b = t;&#125;int main()&#123; int num1, num2; cin &gt;&gt; num1 &gt;&gt; num2; if(num1 &lt; num2) swap(num1, num2); //对大小相反做处理 交换即可 fun(num1, num2); return 0;&#125; #8. 求一元二次方程的根 #include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt; using namespace std;int main()&#123; //ax^2 + bx + c double a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; double delt = pow(b,2) - 4 * a * c; double x1 = (-b+sqrt(delt))/(2*a); double x2 = (-b-sqrt(delt))/(2*a); if(delt &gt; 0)&#123; cout &lt;&lt; &quot;实根分别为：&quot; &lt;&lt; x1 &lt;&lt; &quot; &quot; &lt;&lt; x2 &lt;&lt;endl; &#125;else&#123; if(delt == 0)&#123; cout &lt;&lt; &quot;实根为:&quot; &lt;&lt; x1 &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;无实根&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 第三章1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465第三章：#3-5：#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a,b; float x; double y; char c1, c2; printf(&quot;input the Integer a,b:\\n&quot;); scanf(&quot;%d %d&quot;,&amp;a, &amp;b); printf(&quot;input the Float x:\\n&quot;); scanf(&quot;%f&quot;,&amp;x); printf(&quot;input the Double y:\\n&quot;); scanf(&quot;%lf&quot;,&amp;y); printf(&quot;input the char c1:\\n&quot;); c1 = getchar(); printf(&quot;input the char c2:\\n&quot;); c2 = getchar(); printf(&quot;%d,%d,%.2f,%.2lf,%c,%c&quot;,a,b,x,y,c1,c2); return 0;&#125;#3.6加密 将China译成密码 利用char字符在计算机中存储ASCII码值 每个字符相加四个单位即可#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; char c1,c2,c3,c4,c5; c1 = &#x27;C&#x27;; c2 = &#x27;h&#x27;; c3 = &#x27;i&#x27;; c4 = &#x27;n&#x27;; c5 = &#x27;a&#x27;; c1+=4; c2+=4; c3+=4; c4+=4; c5+=4; putchar(c1); putchar(c2); putchar(c3); putchar(c4); putchar(c5); printf(&quot;\\n&quot;); printf(&quot;%c%c%c%c%c&quot;,c1,c2,c3,c4,c5); return 0;&#125; 第五章123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192第五章：5.3 求最大公约数与最小公倍数5.3.1:最大公约数：#include&lt;stdio.h&gt;#include&lt;iostream&gt; #include&lt;stack&gt;#define N 100using namespace std;int main()&#123; //求a b两个数字的最大公约数 （辗转相除法） int a, b, res = 0; cin &gt;&gt; a &gt;&gt; b; if(a &lt; b) //默认a&gt;b &#123; int t = a; a = b; b = t; &#125; if(a % b == 0)&#123; //如果a是b的倍数 那么最大公因数就是b res = b; &#125;else&#123; int c = a % b; //否则先取余 余数在else语句中肯定是不为0的 while(c != 0)&#123; //若若满足不为0 则较小数作为a 余数作为b c重新被a b取余 a = b; b = c; c = a % b; &#125; res = b; &#125; cout &lt;&lt; res; return 0;&#125;5.3.2：最小公倍数：#include&lt;stdio.h&gt;#include&lt;iostream&gt; #include&lt;stack&gt;#define N 100using namespace std;int main()&#123; //求a b两个数字的最小公倍数 int a,b,res=0; cin &gt;&gt; a &gt;&gt; b; if(a &lt; b)&#123; //默认a大于b int t = a; a = b; b = t; &#125; if(a % b == 0)&#123; //如果a是b的倍数 那么最小公倍数就是a res = a; &#125;else&#123; int temp=b; while(temp&lt;=a*b)&#123; //直到temp变成a*b if(temp%a==0&amp;&amp;temp%b==0)&#123; //如果从较小数开始 一直自增 如果能同时取余两个数 那么就是公倍数 res = temp; break; &#125; temp++; &#125; &#125; cout &lt;&lt; res &lt;&lt;endl; return 0;&#125;5.8 输出所有水仙花数(三位数，且各数的立方和等于该数本身)：#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;iostream&gt; #include&lt;stack&gt;#define N 100using namespace std;bool isNum(int num)&#123; int sum = 0; vector&lt;int&gt; v(1, num); vector&lt;int&gt;::iterator it; bool flag = false; while(num)&#123; v.push_back(num%10); num /= 10; &#125; for(it=v.begin()+1; it != v.end(); it++)&#123; sum += (pow(*it, 3)); &#125; if(sum == v[0])&#123; flag = true; &#125; return flag;&#125; int main()&#123; //求所有的水仙花 int num; for(int i =100; i&lt;1000; i++)&#123; if(isNum(i))&#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; &#125; return 0;&#125;5.9求1000之内的所有完数#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;iostream&gt; #include&lt;stack&gt;#define N 100using namespace std;void getNum(int num)&#123; int sum=0; vector&lt;int&gt; v(1, num); vector&lt;int&gt;::iterator it; for(int i=1; i&lt;num; i++)&#123; //千万注意 取余的两边绝对！绝对不能为0 因此i不能是0 if(num%i==0) v.push_back(i); &#125; for(it=v.begin()+1; it!=v.end(); it++)&#123; sum += (*it); &#125; if(sum == v[0])&#123; cout &lt;&lt; sum &lt;&lt; &quot;是完数&quot; &lt;&lt; endl; &#125; v.clear();&#125;int main()&#123; //求完数 即一个数等于它所有的因子之和 int num,end = 1000; while(num++ &lt; end)&#123; getNum(num); &#125; return 0;&#125;5.10：求 2/1 + 3/2 + 5/3 +... 数列的前20项和#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;iostream&gt; #include&lt;stack&gt;#define N 100using namespace std;int main()&#123; double up=2, down=1,res = 0; //up代表分母 down代表分子 int i=0; while(i++&lt;20)&#123; res += (up/down); up = up + down; down = up - down; //注意 这里不能用down = up 因为up 已经是 up+down //而应该是新的up减去之前的down &#125; cout &lt;&lt; res; return 0;&#125;5.11: 一个球从100M高度落下 每次落地反弹回原高度的一般 再落下...求第10次 共经过多少米 反弹多高？#include &lt;stdio.h&gt;main()&#123;float height=100.0,sum_height=100;int i;for(i=1;i&lt;10;i++) &#123; height=height/2; sum_height+=height*2;&#125;printf(&quot;%fm\\n&quot;,sum_height);printf(&quot;%fm\\n&quot;,height);return 0;&#125; 第六章：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768第六章： 例题：输入字符串 从中打印出单词的个数#include &lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std; main()&#123; char str[N]; int num,word=0; gets(str); for(int i=0; str[i]!=&#x27;\\0&#x27;; i++)&#123; if(str[i] == &#x27; &#x27;)&#123; //如果一开始就是空格 那么不是单词 word = 0; &#125;else if(word==0)&#123; //空格之后 认为是单词 记为遇到1个 word = 1; num++; &#125; &#125; cout &lt;&lt; num &lt;&lt;endl; return 0;&#125;6.5：逆序存放升序的数组 比如处理前：1 2 3 4 5 存放后为：5 4 3 2 1 #include &lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std; main()&#123; int arr[N],len; stack&lt;int&gt; s; cin &gt;&gt; len; for(int i=0; i&lt;len; i++) &#123; cin &gt;&gt; arr[i]; s.push(arr[i]); //利用栈的FILO原理 从头到尾将元素进行入栈 &#125; cout &lt;&lt; &quot;处理前的数组元素分别为：&quot; &lt;&lt;endl; for(int i =0; i&lt;len; i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for(int i=0; i&lt;len; i++)&#123; arr[i] = s.top(); s.pop(); &#125; cout &lt;&lt; &quot;处理后的数组元素分别为：&quot; &lt;&lt;endl; for(int i =0; i&lt;len; i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511526.9：有若干个数字在有序数组中 此时要求实现折半查找方式来查找某个元素并给出它的位置 若找不到该数 则输出 无此数#include &lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std; int main()&#123; int a[6] = &#123;1, 4, 6, 32, 58, 66&#125;; int left = 0; int right = 5; //注意是最后一个元素 即 长度-1 int mid,num; cout &lt;&lt; &quot;输入欲查找的数字：&quot; &lt;&lt;endl; cin &gt;&gt; num; while(left &lt;= right)&#123; //注意条件 mid = (left + right) / 2; if(a[mid] == num)&#123; cout &lt;&lt; &quot;已找到，是第&quot; &lt;&lt; mid+1 &lt;&lt; &quot;个元素&quot; &lt;&lt;endl; break; &#125;else if(a[mid] &lt; num)&#123; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; if(left &gt; right)&#123; cout &lt;&lt; &quot;无此数&quot; &lt;&lt;endl; &#125; return 0;&#125;统计各字符#include &lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std; int main()&#123; char str[2][10]; for(int i =0; i&lt;2; i++) gets(str[i]); //for循环每次输入该行 cout &lt;&lt; endl; //统计大写字母 小写字母 数字 空格以及其他字符 int num=0, U_char=0, L_char=0, space=0, oth=0; for(int i =0; i&lt;2; i++) &#123; for(int j=0; j&lt;10; j++)&#123; char ch= str[i][j]; if(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27; )&#123; num++; &#125;else if(ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;)&#123; U_char++; &#125;else if(ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;)&#123; L_char++; &#125;else if(ch == &#x27; &#x27;)&#123; space++; &#125;else&#123; oth++; &#125; &#125; &#125; cout &lt;&lt; &quot;数字：&quot; &lt;&lt; num&lt;&lt;endl; cout &lt;&lt; &quot;大写字母：&quot; &lt;&lt; U_char &lt;&lt;endl; cout &lt;&lt; &quot;小写字母:&quot; &lt;&lt; L_char &lt;&lt; endl; cout &lt;&lt; &quot;空格：&quot; &lt;&lt;space &lt;&lt;endl; cout &lt;&lt; &quot;其他：&quot; &lt;&lt; oth &lt;&lt;endl; return 0;&#125;6.14比较两个字符串 其中返回正数 该正数表示相差的总值#include &lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std; int main()&#123; //两个字符串的比较 返回总相差的ASCII码值 char c1[N], c2[N]; int len1, len2; int sum=0; cout &lt;&lt; &quot;请输入字符串一：&quot; &lt;&lt;endl; gets(c1); len1 = strlen(c1); cout &lt;&lt; &quot;请输入字符串二：&quot; &lt;&lt;endl; gets(c2); len2 = strlen(c2); int len = (len1&gt;len2)? len1: len2; for(int i=0; i&lt;len; i++)&#123; sum += abs(c1[i]-c2[i]); &#125; cout &lt;&lt; &quot;两者相差：&quot; &lt;&lt; sum &lt;&lt;endl; return 0;&#125;6.15 将字符数组a2的所有字符都复制到a1中去 其中包括a2的结束字符&#x27;\\0&#x27;#include &lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std; int main()&#123; //两个字符串的比较 返回总相差的ASCII码值 char c1[N], c2[N]=&#123;&#x27;v&#x27;,&#x27;i&#x27;,&#x27;n&#x27;,&#x27;c&#x27;,&#x27;\\0&#x27;&#125;; int len1, len2; cout &lt;&lt; &quot;请输入字符串一：&quot; &lt;&lt;endl; gets(c1); len1 = strlen(c1); cout &lt;&lt; &quot;请输入字符串二：&quot; &lt;&lt;endl; len2 = strlen(c2)+1; for(int k = len1,i=0; k&lt;len1+len2; k++,i++)&#123; c1[k] = c2[i]; &#125; for(int k = 0; k&lt;len1+len2; k++)&#123; printf(&quot;%c它的ASCII值为%d\\n&quot;, c1[k],c1[k]); &#125; return 0;&#125; 第七章：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482497.10：写一个函数，输入一行字符，将最长的单词输出：【转】：https://blog.csdn.net/navicheung/article/details/77990479#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std;//最长单词函数void getLongWord(char str[])&#123; int max_length=0, len=0; char temp[N], res[N]; int n = strlen(str); for (int i=0; i&lt;=n; i++)&#123; //如果字符是单词的一部分 加入到temp数组 if ((str[i]&gt;=&#x27;a&#x27;&amp;&amp;str[i]&lt;=&#x27;z&#x27;)||(str[i]&gt;=&#x27;A&#x27;&amp;&amp;str[i]&lt;=&#x27;Z&#x27;)) temp[len++]=str[i]; else&#123; //若不是单词 那么temp数组不再增添元素 而是结束 temp[len]=&#x27;\\0&#x27;; //如果每次长度有更长的 更新 且记得len重新赋值为0 以下一次判断 //最终的结果存入ma数组中 关键语句 len&gt;max_length ? max_length=len, strcpy(res, temp), len=0 : len=0; &#125; &#125; printf(&quot;最长的单词是： &quot;); puts(res);&#125;int main()&#123; char str[N]; printf(&quot;请输入字符串：\\n &quot;); //输入一行字符 gets(str); getLongWord(str); //调用最长单词函数 return 0;&#125;7.11 利用起泡法对输入的n个字符进行升序排序：#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std;void swap(char &amp;a, char &amp;b)&#123; char t = a; a = b; b = t;&#125;int main()&#123; char str[N]; int length; cout &lt;&lt; &quot;你要输入几个字符：&quot; &lt;&lt;endl; cin &gt;&gt; length; cout &lt;&lt; &quot;依次输入这些字符：&quot; &lt;&lt;endl; for(int i=0; i&lt;length; i++)&#123; cin &gt;&gt; str[i]; &#125; for(int i=0; i&lt;length; i++)&#123; for(int j=0; j&lt;length-i-1; j++)&#123; if(str[j] &gt; str[j+1])&#123; swap(str[j], str[j+1]); &#125; &#125; &#125; cout &lt;&lt; &quot;起泡法排序结果：&quot; &lt;&lt;endl; for(int i=0; i&lt;length; i++) cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;; return 0;&#125;7.16 输入一个十六进制数字（字符串的形式），输出相应的十进制数字：#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std;//十六进制数转换为十进制数//相应的位置 按权展开即可//A2 = A*10^1 + 2*10^0 int fun(char str[])&#123; int n = strlen(str); //n代表字符串的长度 即代表十六进制数是n位数 int sum =0; for(int i=n-1,j=0; i&gt;=0; i--)&#123; int temp = 0; if(str[i]==&#x27;A&#x27;)&#123; temp = 10; &#125;else if(str[i]==&#x27;B&#x27;)&#123; temp = 11; &#125;else if(str[i]==&#x27;C&#x27;)&#123; temp = 12; &#125;else if(str[i]==&#x27;D&#x27;)&#123; temp = 13; &#125;else if(str[i]==&#x27;E&#x27;)&#123; temp = 14; &#125;else if(str[i]==&#x27;F&#x27;)&#123; temp = 15; &#125;else&#123; temp = str[i] - &#x27;0&#x27;; &#125; sum += (temp * pow(16, j++)); &#125; return sum;&#125;int main()&#123; char str[N]; gets(str); cout &lt;&lt; &quot;十进制数是：&quot; &lt;&lt;endl; cout &lt;&lt; fun(str) &lt;&lt;endl; return 0;&#125;7.17 递归法 将一个整数转换为字符串#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std;//将一个整数 转换成字符串 void fun(int n)&#123; char ch; //每次输出的字符 //1.递归的第一步 首先想好边界情况 这里每次i位数每次取i-1 直到结果为0 if(n==0)&#123; return; &#125;else&#123; //2.否则 执行每一次的操作具体的行为 //注意这里fun一直到边界才输出！因此结果是12（假如n=12） //如果fun放在末尾 那么会先输出数字 因而结果会是21 fun(n/10); printf(&quot;%c&quot;, (n%10) + &#x27;0&#x27;); &#125;&#125;int main()&#123; int num =0; cin &gt;&gt; num; fun(num); return 0;&#125;6.18：给出年、月、日 计算是该年的第几天#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define N 100 using namespace std;bool isLeapYear(int year)&#123; bool flag = false; if( year%400==0 || (year%4==0&amp;&amp;year%100!=0) )&#123; //1.被400整除的年份是闰年 //2.被4整除同时不能被100所整除的年份是闰年 flag = true; &#125; return flag; &#125;//输入某年某月某日 判断这是该年中的第几天void fun(int year, int month, int day)&#123; int months[12] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; //非闰年的各月份天数数组 int days_sum = 0,i=0; if(month&lt;2)&#123; //如果没到2月 则不用计算是不是闰年 days_sum = day; cout &lt;&lt; &quot;该日期是第&quot; &lt;&lt; days_sum &lt;&lt; &quot;天&quot; &lt;&lt;endl; &#125;else&#123; if(isLeapYear(year))&#123; months[1] = 29; //闰年2月有29天 &#125; while(i&lt;month-1)&#123; //计算该月之前有多少天 days_sum += months[i]; i++; &#125; //然后该月第几天加上去 cout &lt;&lt; &quot;该日期是第&quot; &lt;&lt; days_sum+day &lt;&lt; &quot;天&quot; &lt;&lt;endl; &#125; &#125;int main()&#123; int year, month, day; cout &lt;&lt; &quot;输入年份：&quot; &lt;&lt;endl; cin &gt;&gt; year; cout &lt;&lt; &quot;输入月：&quot; &lt;&lt;endl; cin &gt;&gt; month; cout &lt;&lt; &quot;输入日：&quot; &lt;&lt; endl; cin &gt;&gt; day; //可以添加判断日期是否合法的函数... 现假设合法 正确输入格式 fun(year, month, day); return 0;&#125;","categories":[{"name":"经典C++算法","slug":"经典c-算法","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BB%8F%E5%85%B8c-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"c语言","permalink":"https://github.com/Vincent990413/blog/tags/c%E8%AF%AD%E8%A8%80/"}],"author":"vincent"},{"title":"Volantis 主题个性化修改合集","slug":"blogs/2017-10-25-inkss-theme","date":"2017-10-24T16:00:00.000Z","updated":"2017-10-24T16:00:00.000Z","comments":true,"path":"blogs/2017-10-25-inkss-theme/","link":"https://inkss.cn/blog/610620a9/","permalink":"https://github.com/Vincent990413/blog/blogs/2017-10-25-inkss-theme/","excerpt":"","text":"","categories":[{"name":"进阶玩法","slug":"进阶玩法","permalink":"https://github.com/Vincent990413/blog/categories/%E8%BF%9B%E9%98%B6%E7%8E%A9%E6%B3%95/"}],"tags":[],"author":"inkss"}],"categories":[{"name":"中间件","slug":"中间件","permalink":"https://github.com/Vincent990413/blog/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"注解学习","slug":"注解学习","permalink":"https://github.com/Vincent990413/blog/categories/%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"},{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/categories/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"SSM学习笔记","slug":"ssm学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/ssm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Spring 全家桶学习","slug":"spring-全家桶学习","permalink":"https://github.com/Vincent990413/blog/categories/spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0/"},{"name":"Linux 学习","slug":"linux-学习","permalink":"https://github.com/Vincent990413/blog/categories/linux-%E5%AD%A6%E4%B9%A0/"},{"name":"项目","slug":"项目","permalink":"https://github.com/Vincent990413/blog/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"},{"name":"Gitee上传项目","slug":"gitee上传项目","permalink":"https://github.com/Vincent990413/blog/categories/gitee%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"},{"name":"毕业答辩","slug":"毕业答辩","permalink":"https://github.com/Vincent990413/blog/categories/%E6%AF%95%E4%B8%9A%E7%AD%94%E8%BE%A9/"},{"name":"Hexo 学习笔记","slug":"hexo-学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/hexo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"英语学习","slug":"英语学习","permalink":"https://github.com/Vincent990413/blog/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"前端项目","slug":"前端项目","permalink":"https://github.com/Vincent990413/blog/categories/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"},{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"},{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"},{"name":"非关系型数据库学习笔记","slug":"非关系型数据库学习笔记","permalink":"https://github.com/Vincent990413/blog/categories/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"},{"name":"经典C++算法","slug":"经典c-算法","permalink":"https://github.com/Vincent990413/blog/categories/%E7%BB%8F%E5%85%B8c-%E7%AE%97%E6%B3%95/"},{"name":"进阶玩法","slug":"进阶玩法","permalink":"https://github.com/Vincent990413/blog/categories/%E8%BF%9B%E9%98%B6%E7%8E%A9%E6%B3%95/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://github.com/Vincent990413/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"注解学习","slug":"注解学习","permalink":"https://github.com/Vincent990413/blog/tags/%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"},{"name":"Java编程实用小技巧","slug":"java编程实用小技巧","permalink":"https://github.com/Vincent990413/blog/tags/java%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/Vincent990413/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"SSM学习笔记","slug":"ssm学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/ssm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Spring 全家桶学习","slug":"spring-全家桶学习","permalink":"https://github.com/Vincent990413/blog/tags/spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0/"},{"name":"Linux 学习","slug":"linux-学习","permalink":"https://github.com/Vincent990413/blog/tags/linux-%E5%AD%A6%E4%B9%A0/"},{"name":"项目","slug":"项目","permalink":"https://github.com/Vincent990413/blog/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"前端框架学习","slug":"前端框架学习","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"},{"name":"Gitee上传项目","slug":"gitee上传项目","permalink":"https://github.com/Vincent990413/blog/tags/gitee%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"},{"name":"毕业答辩","slug":"毕业答辩","permalink":"https://github.com/Vincent990413/blog/tags/%E6%AF%95%E4%B8%9A%E7%AD%94%E8%BE%A9/"},{"name":"Hexo 学习笔记","slug":"hexo-学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/hexo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"英语学习","slug":"英语学习","permalink":"https://github.com/Vincent990413/blog/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"前端项目","slug":"前端项目","permalink":"https://github.com/Vincent990413/blog/tags/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"},{"name":"编程语言","slug":"编程语言","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"研究生入学考试经验贴","slug":"研究生入学考试经验贴","permalink":"https://github.com/Vincent990413/blog/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B4%B4/"},{"name":"翻译作品","slug":"翻译作品","permalink":"https://github.com/Vincent990413/blog/tags/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"},{"name":"非关系型数据库学习笔记","slug":"非关系型数据库学习笔记","permalink":"https://github.com/Vincent990413/blog/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"PYTHON","slug":"python","permalink":"https://github.com/Vincent990413/blog/tags/python/"},{"name":"SpringBoot","slug":"springboot","permalink":"https://github.com/Vincent990413/blog/tags/springboot/"},{"name":"C语言","slug":"c语言","permalink":"https://github.com/Vincent990413/blog/tags/c%E8%AF%AD%E8%A8%80/"}]}